# This is a shell archive.  Save it in a file, remove anything before
# this line, and then unpack it by entering "sh file".  Note, it may
# create directories; files and directories will be owned by you and
# have default permissions.
#
# This archive contains:
#
#	cglm
#	cglm/version.h
#	cglm/common.h
#	cglm/types.h
#	cglm/types-struct.h
#	cglm/cglm.h
#	cglm/call.h
#	cglm/struct.h
#	cglm/cam.h
#	cglm/io.h
#	cglm/mat4.h
#	cglm/mat3.h
#	cglm/affine.h
#	cglm/vec3.h
#	cglm/vec3-ext.h
#	cglm/vec4.h
#	cglm/vec4-ext.h
#	cglm/euler.h
#	cglm/util.h
#	cglm/quat.h
#	cglm/affine-mat.h
#	cglm/plane.h
#	cglm/frustum.h
#	cglm/box.h
#	cglm/color.h
#	cglm/project.h
#	cglm/sphere.h
#	cglm/ease.h
#	cglm/curve.h
#	cglm/bezier.h
#	cglm/applesimd.h
#	cglm/call
#	cglm/call/mat4.h
#	cglm/call/mat3.h
#	cglm/call/vec3.h
#	cglm/call/vec4.h
#	cglm/call/affine.h
#	cglm/call/io.h
#	cglm/call/cam.h
#	cglm/call/quat.h
#	cglm/call/euler.h
#	cglm/call/plane.h
#	cglm/call/frustum.h
#	cglm/call/box.h
#	cglm/call/project.h
#	cglm/call/sphere.h
#	cglm/call/ease.h
#	cglm/call/curve.h
#	cglm/call/bezier.h
#	cglm/simd
#	cglm/simd/intrin.h
#	cglm/simd/x86.h
#	cglm/simd/arm.h
#	cglm/simd/avx
#	cglm/simd/avx/mat4.h
#	cglm/simd/avx/affine.h
#	cglm/simd/neon
#	cglm/simd/neon/mat4.h
#	cglm/simd/sse2
#	cglm/simd/sse2/affine.h
#	cglm/simd/sse2/mat4.h
#	cglm/simd/sse2/mat3.h
#	cglm/simd/sse2/quat.h
#	cglm/struct
#	cglm/struct/mat4.h
#	cglm/struct/mat3.h
#	cglm/struct/vec3.h
#	cglm/struct/vec3-ext.h
#	cglm/struct/vec4.h
#	cglm/struct/vec4-ext.h
#	cglm/struct/affine.h
#	cglm/struct/io.h
#	cglm/struct/cam.h
#	cglm/struct/quat.h
#	cglm/struct/euler.h
#	cglm/struct/plane.h
#	cglm/struct/frustum.h
#	cglm/struct/box.h
#	cglm/struct/project.h
#	cglm/struct/sphere.h
#	cglm/struct/color.h
#	cglm/struct/curve.h
#
echo c - cglm
mkdir -p cglm > /dev/null 2>&1
echo x - cglm/version.h
sed 's/^X//' >cglm/version.h << '50b96efae597911eaecef81f66f605ed'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_version_h
X#define cglm_version_h
X
X#define CGLM_VERSION_MAJOR 0
X#define CGLM_VERSION_MINOR 6
X#define CGLM_VERSION_PATCH 1
X
X#endif /* cglm_version_h */
50b96efae597911eaecef81f66f605ed
echo x - cglm/common.h
sed 's/^X//' >cglm/common.h << 'f8694d16671dbd8b06cd994499637ea4'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_common_h
X#define cglm_common_h
X
X#define _USE_MATH_DEFINES /* for windows */
X
X#include <stdint.h>
X#include <stddef.h>
X#include <math.h>
X#include <float.h>
X#include <stdbool.h>
X
X#if defined(_MSC_VER)
X#  ifdef CGLM_DLL
X#    define CGLM_EXPORT __declspec(dllexport)
X#  else
X#    define CGLM_EXPORT __declspec(dllimport)
X#  endif
X#  define CGLM_INLINE __forceinline
X#else
X#  define CGLM_EXPORT __attribute__((visibility("default")))
X#  define CGLM_INLINE static inline __attribute((always_inline))
X#endif
X
X#define GLM_SHUFFLE4(z, y, x, w) (((z) << 6) | ((y) << 4) | ((x) << 2) | (w))
X#define GLM_SHUFFLE3(z, y, x)    (((z) << 4) | ((y) << 2) | (x))
X
X#include "types.h"
X#include "simd/intrin.h"
X
X#endif /* cglm_common_h */
f8694d16671dbd8b06cd994499637ea4
echo x - cglm/types.h
sed 's/^X//' >cglm/types.h << '189468ec18902b3f4b3d9ac24c5866ed'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_types_h
X#define cglm_types_h
X
X#if defined(_MSC_VER)
X/* do not use alignment for older visual studio versions */
X#  if _MSC_VER < 1913 /*  Visual Studio 2017 version 15.6  */
X#    define CGLM_ALL_UNALIGNED
X#    define CGLM_ALIGN(X) /* no alignment */
X#  else
X#    define CGLM_ALIGN(X) __declspec(align(X))
X#  endif
X#else
X#  define CGLM_ALIGN(X) __attribute((aligned(X)))
X#endif
X
X#ifndef CGLM_ALL_UNALIGNED
X#  define CGLM_ALIGN_IF(X) CGLM_ALIGN(X)
X#else
X#  define CGLM_ALIGN_IF(X) /* no alignment */
X#endif
X
X#ifdef __AVX__
X#  define CGLM_ALIGN_MAT CGLM_ALIGN(32)
X#else
X#  define CGLM_ALIGN_MAT CGLM_ALIGN(16)
X#endif
X
Xtypedef float                   vec2[2];
Xtypedef float                   vec3[3];
Xtypedef int                    ivec3[3];
Xtypedef CGLM_ALIGN_IF(16) float vec4[4];
Xtypedef vec4                    versor;
Xtypedef vec3                    mat3[3];
Xtypedef CGLM_ALIGN_MAT vec4     mat4[4];
X
X#define GLM_E         2.71828182845904523536028747135266250   /* e           */
X#define GLM_LOG2E     1.44269504088896340735992468100189214   /* log2(e)     */
X#define GLM_LOG10E    0.434294481903251827651128918916605082  /* log10(e)    */
X#define GLM_LN2       0.693147180559945309417232121458176568  /* loge(2)     */
X#define GLM_LN10      2.30258509299404568401799145468436421   /* loge(10)    */
X#define GLM_PI        3.14159265358979323846264338327950288   /* pi          */
X#define GLM_PI_2      1.57079632679489661923132169163975144   /* pi/2        */
X#define GLM_PI_4      0.785398163397448309615660845819875721  /* pi/4        */
X#define GLM_1_PI      0.318309886183790671537767526745028724  /* 1/pi        */
X#define GLM_2_PI      0.636619772367581343075535053490057448  /* 2/pi        */
X#define GLM_2_SQRTPI  1.12837916709551257389615890312154517   /* 2/sqrt(pi)  */
X#define GLM_SQRT2     1.41421356237309504880168872420969808   /* sqrt(2)     */
X#define GLM_SQRT1_2   0.707106781186547524400844362104849039  /* 1/sqrt(2)   */
X
X#define GLM_Ef        ((float)GLM_E)
X#define GLM_LOG2Ef    ((float)GLM_LOG2E)
X#define GLM_LOG10Ef   ((float)GLM_LOG10E)
X#define GLM_LN2f      ((float)GLM_LN2)
X#define GLM_LN10f     ((float)GLM_LN10)
X#define GLM_PIf       ((float)GLM_PI)
X#define GLM_PI_2f     ((float)GLM_PI_2)
X#define GLM_PI_4f     ((float)GLM_PI_4)
X#define GLM_1_PIf     ((float)GLM_1_PI)
X#define GLM_2_PIf     ((float)GLM_2_PI)
X#define GLM_2_SQRTPIf ((float)GLM_2_SQRTPI)
X#define GLM_SQRT2f    ((float)GLM_SQRT2)
X#define GLM_SQRT1_2f  ((float)GLM_SQRT1_2)
X
X/* DEPRECATED! use GLM_PI and friends */
X#define CGLM_PI       GLM_PIf
X#define CGLM_PI_2     GLM_PI_2f
X#define CGLM_PI_4     GLM_PI_4f
X
X#endif /* cglm_types_h */
189468ec18902b3f4b3d9ac24c5866ed
echo x - cglm/types-struct.h
sed 's/^X//' >cglm/types-struct.h << 'dc70e5ed76127b1afd69a7aa1c4f9510'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_types_struct_h
X#define cglm_types_struct_h
X
X#include "types.h"
X
X/*
X * Anonymous structs are available since C11, but we'd like to be compatible
X * with C99 and C89 too. So let's figure out if we should be using them or not.
X * It's simply a convenience feature, you can e.g. build the library with
X * anonymous structs and your application without them and they'll still be
X * compatible, cglm doesn't use the anonymous structs internally.
X */
X#ifndef CGLM_USE_ANONYMOUS_STRUCT
X    /* If the user doesn't explicitly specify if they want anonymous structs or
X     * not, then we'll try to intuit an appropriate choice. */
X#   if defined(CGLM_NO_ANONYMOUS_STRUCT)
X        /* The user has defined CGLM_NO_ANONYMOUS_STRUCT. This used to be the
X         * only #define governing the use of anonymous structs, so for backward
X         * compatibility, we still honor that choice and disable them. */
X#       define CGLM_USE_ANONYMOUS_STRUCT 0
X#   elif __STDC_VERSION__ >= 20112L || defined(_MSVC_VER)
X        /* We're compiling for C11 or this is the MSVC compiler. In either
X         * case, anonymous structs are available, so use them. */
X#       define CGLM_USE_ANONYMOUS_STRUCT 1
X#   else
X        /* Otherwise, we're presumably building for C99 or C89 and can't rely
X         * on anonymous structs being available. Turn them off. */
X#       define CGLM_USE_ANONYMOUS_STRUCT 0
X#   endif
X#endif
X
Xtypedef union vec2s {
X  vec2 raw;
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float x;
X    float y;
X  };
X#endif
X} vec2s;
X
Xtypedef union vec3s {
X  vec3 raw;
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float x;
X    float y;
X    float z;
X  };
X#endif
X} vec3s;
X
Xtypedef union ivec3s {
X  ivec3 raw;
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    int x;
X    int y;
X    int z;
X  };
X#endif
X} ivec3s;
X
Xtypedef union CGLM_ALIGN_IF(16) vec4s {
X  vec4 raw;
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float x;
X    float y;
X    float z;
X    float w;
X  };
X#endif
X} vec4s;
X
Xtypedef union CGLM_ALIGN_IF(16) versors {
X  vec4 raw;
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float x;
X    float y;
X    float z;
X    float w;
X  };
X
X  struct {
X    vec3s imag;
X    float real;
X  };
X#endif
X} versors;
X
Xtypedef union mat3s {
X  mat3 raw;
X  vec3s col[3];
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float m00, m01, m02;
X    float m10, m11, m12;
X    float m20, m21, m22;
X  };
X#endif
X} mat3s;
X
Xtypedef union CGLM_ALIGN_MAT mat4s {
X  mat4 raw;
X  vec4s col[4];
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float m00, m01, m02, m03;
X    float m10, m11, m12, m13;
X    float m20, m21, m22, m23;
X    float m30, m31, m32, m33;
X  };
X#endif
X} mat4s;
X
X#endif /* cglm_types_struct_h */
dc70e5ed76127b1afd69a7aa1c4f9510
echo x - cglm/cglm.h
sed 's/^X//' >cglm/cglm.h << 'a5fcc937e4d34d183c96ec7c4bd88a0f'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_h
X#define cglm_h
X
X#include "common.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X#include "mat3.h"
X#include "affine.h"
X#include "cam.h"
X#include "frustum.h"
X#include "quat.h"
X#include "euler.h"
X#include "plane.h"
X#include "box.h"
X#include "color.h"
X#include "util.h"
X#include "io.h"
X#include "project.h"
X#include "sphere.h"
X#include "ease.h"
X#include "curve.h"
X#include "bezier.h"
X
X#endif /* cglm_h */
a5fcc937e4d34d183c96ec7c4bd88a0f
echo x - cglm/call.h
sed 's/^X//' >cglm/call.h << 'ac58acf258a0b9cdcb9f5734227a7165'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_call_h
X#define cglm_call_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "cglm.h"
X#include "call/vec3.h"
X#include "call/vec4.h"
X#include "call/mat4.h"
X#include "call/mat3.h"
X#include "call/affine.h"
X#include "call/cam.h"
X#include "call/quat.h"
X#include "call/euler.h"
X#include "call/plane.h"
X#include "call/frustum.h"
X#include "call/box.h"
X#include "call/io.h"
X#include "call/project.h"
X#include "call/sphere.h"
X#include "call/ease.h"
X#include "call/curve.h"
X#include "call/bezier.h"
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglm_call_h */
ac58acf258a0b9cdcb9f5734227a7165
echo x - cglm/struct.h
sed 's/^X//' >cglm/struct.h << 'a683b829014b67a33bc0c25da4c9f05b'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_structs_h
X#define cglm_structs_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "cglm.h"
X#include "types-struct.h"
X#include "struct/vec3.h"
X#include "struct/vec4.h"
X#include "struct/mat3.h"
X#include "struct/mat4.h"
X#include "struct/affine.h"
X#include "struct/frustum.h"
X#include "struct/plane.h"
X#include "struct/box.h"
X#include "struct/color.h"
X#include "struct/io.h"
X#include "struct/cam.h"
X#include "struct/quat.h"
X#include "struct/euler.h"
X#include "struct/project.h"
X#include "struct/sphere.h"
X#include "struct/curve.h"
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglm_structs_h */
a683b829014b67a33bc0c25da4c9f05b
echo x - cglm/cam.h
sed 's/^X//' >cglm/cam.h << 'c05f36a363c9ccfab46c96ce5e53d161'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void  glm_frustum(float left,    float right,
X                                 float bottom,  float top,
X                                 float nearVal, float farVal,
X                                 mat4  dest)
X   CGLM_INLINE void  glm_ortho(float left,    float right,
X                               float bottom,  float top,
X                               float nearVal, float farVal,
X                               mat4  dest)
X   CGLM_INLINE void  glm_ortho_aabb(vec3 box[2], mat4 dest)
X   CGLM_INLINE void  glm_ortho_aabb_p(vec3 box[2],  float padding, mat4 dest)
X   CGLM_INLINE void  glm_ortho_aabb_pz(vec3 box[2], float padding, mat4 dest)
X   CGLM_INLINE void  glm_ortho_default(float aspect, mat4  dest)
X   CGLM_INLINE void  glm_ortho_default_s(float aspect, float size, mat4 dest)
X   CGLM_INLINE void  glm_perspective(float fovy,
X                                     float aspect,
X                                     float nearVal,
X                                     float farVal,
X                                     mat4  dest)
X   CGLM_INLINE void  glm_perspective_default(float aspect, mat4 dest)
X   CGLM_INLINE void  glm_perspective_resize(float aspect, mat4 proj)
X   CGLM_INLINE void  glm_lookat(vec3 eye, vec3 center, vec3 up, mat4 dest)
X   CGLM_INLINE void  glm_look(vec3 eye, vec3 dir, vec3 up, mat4 dest)
X   CGLM_INLINE void  glm_look_anyup(vec3 eye, vec3 dir, mat4 dest)
X   CGLM_INLINE void  glm_persp_decomp(mat4   proj,
X                                      float *nearVal, float *farVal,
X                                      float *top,     float *bottom,
X                                      float *left,    float *right)
X   CGLM_INLINE void  glm_persp_decompv(mat4 proj, float dest[6])
X   CGLM_INLINE void  glm_persp_decomp_x(mat4 proj, float *left, float *right)
X   CGLM_INLINE void  glm_persp_decomp_y(mat4 proj, float *top,  float *bottom)
X   CGLM_INLINE void  glm_persp_decomp_z(mat4 proj, float *nearv, float *farv)
X   CGLM_INLINE void  glm_persp_decomp_far(mat4 proj, float *farVal)
X   CGLM_INLINE void  glm_persp_decomp_near(mat4 proj, float *nearVal)
X   CGLM_INLINE float glm_persp_fovy(mat4 proj)
X   CGLM_INLINE float glm_persp_aspect(mat4 proj)
X   CGLM_INLINE void  glm_persp_sizes(mat4 proj, float fovy, vec4 dest)
X */
X
X#ifndef cglm_vcam_h
X#define cglm_vcam_h
X
X#include "common.h"
X#include "plane.h"
X
X/*!
X * @brief set up perspective peprojection matrix
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearVal near clipping plane
X * @param[in]  farVal  far clipping plane
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_frustum(float left,    float right,
X            float bottom,  float top,
X            float nearVal, float farVal,
X            mat4  dest) {
X  float rl, tb, fn, nv;
X
X  glm_mat4_zero(dest);
X
X  rl = 1.0f / (right  - left);
X  tb = 1.0f / (top    - bottom);
X  fn =-1.0f / (farVal - nearVal);
X  nv = 2.0f * nearVal;
X
X  dest[0][0] = nv * rl;
X  dest[1][1] = nv * tb;
X  dest[2][0] = (right  + left)    * rl;
X  dest[2][1] = (top    + bottom)  * tb;
X  dest[2][2] = (farVal + nearVal) * fn;
X  dest[2][3] =-1.0f;
X  dest[3][2] = farVal * nv * fn;
X}
X
X/*!
X * @brief set up orthographic projection matrix
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearVal near clipping plane
X * @param[in]  farVal  far clipping plane
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho(float left,    float right,
X          float bottom,  float top,
X          float nearVal, float farVal,
X          mat4  dest) {
X  float rl, tb, fn;
X
X  glm_mat4_zero(dest);
X
X  rl = 1.0f / (right  - left);
X  tb = 1.0f / (top    - bottom);
X  fn =-1.0f / (farVal - nearVal);
X
X  dest[0][0] = 2.0f * rl;
X  dest[1][1] = 2.0f * tb;
X  dest[2][2] = 2.0f * fn;
X  dest[3][0] =-(right  + left)    * rl;
X  dest[3][1] =-(top    + bottom)  * tb;
X  dest[3][2] = (farVal + nearVal) * fn;
X  dest[3][3] = 1.0f;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box   AABB
X * @param[out] dest  result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb(vec3 box[2], mat4 dest) {
X  glm_ortho(box[0][0],  box[1][0],
X            box[0][1],  box[1][1],
X           -box[1][2], -box[0][2],
X            dest);
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb_p(vec3 box[2], float padding, mat4 dest) {
X  glm_ortho(box[0][0] - padding,    box[1][0] + padding,
X            box[0][1] - padding,    box[1][1] + padding,
X          -(box[1][2] + padding), -(box[0][2] - padding),
X            dest);
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding for near and far
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb_pz(vec3 box[2], float padding, mat4 dest) {
X  glm_ortho(box[0][0],              box[1][0],
X            box[0][1],              box[1][1],
X          -(box[1][2] + padding), -(box[0][2] - padding),
X            dest);
X}
X
X/*!
X * @brief set up unit orthographic projection matrix
X *
X * @param[in]  aspect aspect ration ( width / height )
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_default(float aspect, mat4 dest) {
X  if (aspect >= 1.0f) {
X    glm_ortho(-aspect, aspect, -1.0f, 1.0f, -100.0f, 100.0f, dest);
X    return;
X  }
X
X  aspect = 1.0f / aspect;
X
X  glm_ortho(-1.0f, 1.0f, -aspect, aspect, -100.0f, 100.0f, dest);
X}
X
X/*!
X * @brief set up orthographic projection matrix with given CUBE size
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[in]  size   cube size
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_default_s(float aspect, float size, mat4 dest) {
X  if (aspect >= 1.0f) {
X    glm_ortho(-size * aspect,
X               size * aspect,
X              -size,
X               size,
X              -size - 100.0f,
X               size + 100.0f,
X               dest);
X    return;
X  }
X
X  glm_ortho(-size,
X             size,
X            -size / aspect,
X             size / aspect,
X            -size - 100.0f,
X             size + 100.0f,
X             dest);
X}
X
X/*!
X * @brief set up perspective projection matrix
X *
X * @param[in]  fovy    field of view angle
X * @param[in]  aspect  aspect ratio ( width / height )
X * @param[in]  nearVal near clipping plane
X * @param[in]  farVal  far clipping planes
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective(float fovy,
X                float aspect,
X                float nearVal,
X                float farVal,
X                mat4  dest) {
X  float f, fn;
X
X  glm_mat4_zero(dest);
X
X  f  = 1.0f / tanf(fovy * 0.5f);
X  fn = 1.0f / (nearVal - farVal);
X
X  dest[0][0] = f / aspect;
X  dest[1][1] = f;
X  dest[2][2] = (nearVal + farVal) * fn;
X  dest[2][3] =-1.0f;
X  dest[3][2] = 2.0f * nearVal * farVal * fn;
X}
X
X/*!
X * @brief extend perspective projection matrix's far distance
X *
X * this function does not guarantee far >= near, be aware of that!
X *
X * @param[in, out] proj      projection matrix to extend
X * @param[in]      deltaFar  distance from existing far (negative to shink)
X */
XCGLM_INLINE
Xvoid
Xglm_persp_move_far(mat4 proj, float deltaFar) {
X  float fn, farVal, nearVal, p22, p32;
X
X  p22        = proj[2][2];
X  p32        = proj[3][2];
X
X  nearVal    = p32 / (p22 - 1.0f);
X  farVal     = p32 / (p22 + 1.0f) + deltaFar;
X  fn         = 1.0f / (nearVal - farVal);
X
X  proj[2][2] = (nearVal + farVal) * fn;
X  proj[3][2] = 2.0f * nearVal * farVal * fn;
X}
X
X/*!
X * @brief set up perspective projection matrix with default near/far
X *        and angle values
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective_default(float aspect, mat4 dest) {
X  glm_perspective(GLM_PI_4f, aspect, 0.01f, 100.0f, dest);
X}
X
X/*!
X * @brief resize perspective matrix by aspect ratio ( width / height )
X *        this makes very easy to resize proj matrix when window /viewport
X *        reized
X *
X * @param[in]      aspect aspect ratio ( width / height )
X * @param[in, out] proj   perspective projection matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective_resize(float aspect, mat4 proj) {
X  if (proj[0][0] == 0.0f)
X    return;
X
X  proj[0][0] = proj[1][1] / aspect;
X}
X
X/*!
X * @brief set up view matrix
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  center center vector
X * @param[in]  up     up vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_lookat(vec3 eye,
X           vec3 center,
X           vec3 up,
X           mat4 dest) {
X  CGLM_ALIGN(8) vec3 f, u, s;
X
X  glm_vec3_sub(center, eye, f);
X  glm_vec3_normalize(f);
X
X  glm_vec3_crossn(f, up, s);
X  glm_vec3_cross(s, f, u);
X
X  dest[0][0] = s[0];
X  dest[0][1] = u[0];
X  dest[0][2] =-f[0];
X  dest[1][0] = s[1];
X  dest[1][1] = u[1];
X  dest[1][2] =-f[1];
X  dest[2][0] = s[2];
X  dest[2][1] = u[2];
X  dest[2][2] =-f[2];
X  dest[3][0] =-glm_vec3_dot(s, eye);
X  dest[3][1] =-glm_vec3_dot(u, eye);
X  dest[3][2] = glm_vec3_dot(f, eye);
X  dest[0][3] = dest[1][3] = dest[2][3] = 0.0f;
X  dest[3][3] = 1.0f;
X}
X
X/*!
X * @brief set up view matrix
X *
X * convenient wrapper for lookat: if you only have direction not target self
X * then this might be useful. Because you need to get target from direction.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[in]  up     up vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_look(vec3 eye, vec3 dir, vec3 up, mat4 dest) {
X  CGLM_ALIGN(8) vec3 target;
X  glm_vec3_add(eye, dir, target);
X  glm_lookat(eye, target, up, dest);
X}
X
X/*!
X * @brief set up view matrix
X *
X * convenient wrapper for look: if you only have direction and if you don't
X * care what UP vector is then this might be useful to create view matrix
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_look_anyup(vec3 eye, vec3 dir, mat4 dest) {
X  CGLM_ALIGN(8) vec3 up;
X  glm_vec3_ortho(dir, up);
X  glm_look(eye, dir, up, dest);
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection.
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearVal near
X * @param[out] farVal  far
X * @param[out] top     top
X * @param[out] bottom  bottom
X * @param[out] left    left
X * @param[out] right   right
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp(mat4 proj,
X                 float * __restrict nearVal, float * __restrict farVal,
X                 float * __restrict top,     float * __restrict bottom,
X                 float * __restrict left,    float * __restrict right) {
X  float m00, m11, m20, m21, m22, m32, n, f;
X  float n_m11, n_m00;
X
X  m00 = proj[0][0];
X  m11 = proj[1][1];
X  m20 = proj[2][0];
X  m21 = proj[2][1];
X  m22 = proj[2][2];
X  m32 = proj[3][2];
X
X  n = m32 / (m22 - 1.0f);
X  f = m32 / (m22 + 1.0f);
X
X  n_m11 = n / m11;
X  n_m00 = n / m00;
X
X  *nearVal = n;
X  *farVal  = f;
X  *bottom  = n_m11 * (m21 - 1.0f);
X  *top     = n_m11 * (m21 + 1.0f);
X  *left    = n_m00 * (m20 - 1.0f);
X  *right   = n_m00 * (m20 + 1.0f);
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection.
X *        this makes easy to get all values at once
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] dest   array
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decompv(mat4 proj, float dest[6]) {
X  glm_persp_decomp(proj, &dest[0], &dest[1], &dest[2],
X                         &dest[3], &dest[4], &dest[5]);
X}
X
X/*!
X * @brief decomposes left and right values of perspective projection.
X *        x stands for x axis (left / right axis)
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] left  left
X * @param[out] right right
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_x(mat4 proj,
X                   float * __restrict left,
X                   float * __restrict right) {
X  float nearVal, m20, m00;
X
X  m00 = proj[0][0];
X  m20 = proj[2][0];
X
X  nearVal = proj[3][2] / (proj[3][3] - 1.0f);
X  *left   = nearVal * (m20 - 1.0f) / m00;
X  *right  = nearVal * (m20 + 1.0f) / m00;
X}
X
X/*!
X * @brief decomposes top and bottom values of perspective projection.
X *        y stands for y axis (top / botom axis)
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] top    top
X * @param[out] bottom bottom
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_y(mat4 proj,
X                   float * __restrict top,
X                   float * __restrict bottom) {
X  float nearVal, m21, m11;
X
X  m21 = proj[2][1];
X  m11 = proj[1][1];
X
X  nearVal = proj[3][2] / (proj[3][3] - 1.0f);
X  *bottom = nearVal * (m21 - 1) / m11;
X  *top    = nearVal * (m21 + 1) / m11;
X}
X
X/*!
X * @brief decomposes near and far values of perspective projection.
X *        z stands for z axis (near / far axis)
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearVal near
X * @param[out] farVal  far
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_z(mat4 proj,
X                   float * __restrict nearVal,
X                   float * __restrict farVal) {
X  float m32, m22;
X
X  m32 = proj[3][2];
X  m22 = proj[2][2];
X
X  *nearVal = m32 / (m22 - 1.0f);
X  *farVal  = m32 / (m22 + 1.0f);
X}
X
X/*!
X * @brief decomposes far value of perspective projection.
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] farVal far
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_far(mat4 proj, float * __restrict farVal) {
X  *farVal = proj[3][2] / (proj[2][2] + 1.0f);
X}
X
X/*!
X * @brief decomposes near value of perspective projection.
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearVal near
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_near(mat4 proj, float * __restrict nearVal) {
X  *nearVal = proj[3][2] / (proj[2][2] - 1.0f);
X}
X
X/*!
X * @brief returns field of view angle along the Y-axis (in radians)
X *
X * if you need to degrees, use glm_deg to convert it or use this:
X * fovy_deg = glm_deg(glm_persp_fovy(projMatrix))
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglm_persp_fovy(mat4 proj) {
X  return 2.0f * atanf(1.0f / proj[1][1]);
X}
X
X/*!
X * @brief returns aspect ratio of perspective projection
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglm_persp_aspect(mat4 proj) {
X  return proj[1][1] / proj[0][0];
X}
X
X/*!
X * @brief returns sizes of near and far planes of perspective projection
X *
X * @param[in]  proj perspective projection matrix
X * @param[in]  fovy fovy (see brief)
X * @param[out] dest sizes order: [Wnear, Hnear, Wfar, Hfar]
X */
XCGLM_INLINE
Xvoid
Xglm_persp_sizes(mat4 proj, float fovy, vec4 dest) {
X  float t, a, nearVal, farVal;
X
X  t = 2.0f * tanf(fovy * 0.5f);
X  a = glm_persp_aspect(proj);
X
X  glm_persp_decomp_z(proj, &nearVal, &farVal);
X
X  dest[1]  = t * nearVal;
X  dest[3]  = t * farVal;
X  dest[0]  = a * dest[1];
X  dest[2]  = a * dest[3];
X}
X
X#endif /* cglm_vcam_h */
c05f36a363c9ccfab46c96ce5e53d161
echo x - cglm/io.h
sed 's/^X//' >cglm/io.h << '63693ed6831842533808e4e88fabc9d9'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_mat4_print(mat4 matrix, FILE *ostream);
X   CGLM_INLINE void glm_mat3_print(mat3 matrix, FILE *ostream);
X   CGLM_INLINE void glm_vec4_print(vec4 vec, FILE *ostream);
X   CGLM_INLINE void glm_vec3_print(vec3 vec, FILE *ostream);
X   CGLM_INLINE void glm_ivec3_print(ivec3 vec, FILE *ostream);
X   CGLM_INLINE void glm_versor_print(versor vec, FILE *ostream);
X */
X
X#ifndef cglm_io_h
X#define cglm_io_h
X
X#include "common.h"
X
X#include <stdio.h>
X#include <stdlib.h>
X
XCGLM_INLINE
Xvoid
Xglm_mat4_print(mat4              matrix,
X               FILE * __restrict ostream) {
X  int i;
X  int j;
X
X#define m 4
X#define n 4
X
X  fprintf(ostream, "Matrix (float%dx%d):\n", m, n);
X
X  for (i = 0; i < m; i++) {
X    fprintf(ostream, "\t|");
X    for (j = 0; j < n; j++) {
X      fprintf(ostream, "%0.4f", matrix[j][i]);;
X
X      if (j != n - 1)
X        fprintf(ostream, "\t");
X    }
X
X    fprintf(ostream, "|\n");
X  }
X
X  fprintf(ostream, "\n");
X
X#undef m
X#undef n
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat3_print(mat3              matrix,
X               FILE * __restrict ostream) {
X  int i;
X  int j;
X
X#define m 3
X#define n 3
X
X  fprintf(ostream, "Matrix (float%dx%d):\n", m, n);
X
X  for (i = 0; i < m; i++) {
X    fprintf(ostream, "\t|");
X    for (j = 0; j < n; j++) {
X      fprintf(ostream, "%0.4f", matrix[j][i]);;
X
X      if (j != n - 1)
X        fprintf(ostream, "\t");
X    }
X
X    fprintf(ostream, "|\n");
X  }
X
X  fprintf(ostream, "\n");
X
X#undef m
X#undef n
X}
X
XCGLM_INLINE
Xvoid
Xglm_vec4_print(vec4              vec,
X               FILE * __restrict ostream) {
X  int i;
X
X#define m 4
X
X  fprintf(ostream, "Vector (float%d):\n\t|", m);
X
X  for (i = 0; i < m; i++) {
X    fprintf(ostream, "%0.4f", vec[i]);
X
X    if (i != m - 1)
X      fprintf(ostream, "\t");
X  }
X
X  fprintf(ostream, "|\n\n");
X
X#undef m
X}
X
XCGLM_INLINE
Xvoid
Xglm_vec3_print(vec3              vec,
X               FILE * __restrict ostream) {
X  int i;
X
X#define m 3
X
X  fprintf(ostream, "Vector (float%d):\n\t|", m);
X
X  for (i = 0; i < m; i++) {
X    fprintf(ostream, "%0.4f", vec[i]);
X
X    if (i != m - 1)
X      fprintf(ostream, "\t");
X  }
X
X  fprintf(ostream, "|\n\n");
X
X#undef m
X}
X
XCGLM_INLINE
Xvoid
Xglm_ivec3_print(ivec3             vec,
X                FILE * __restrict ostream) {
X  int i;
X
X#define m 3
X
X  fprintf(ostream, "Vector (int%d):\n\t|", m);
X
X  for (i = 0; i < m; i++) {
X    fprintf(ostream, "%d", vec[i]);
X
X    if (i != m - 1)
X      fprintf(ostream, "\t");
X  }
X
X  fprintf(ostream, "|\n\n");
X  
X#undef m
X}
X
XCGLM_INLINE
Xvoid
Xglm_versor_print(versor            vec,
X                 FILE * __restrict ostream) {
X  int i;
X
X#define m 4
X
X  fprintf(ostream, "Versor (float%d):\n\t|", m);
X
X  for (i = 0; i < m; i++) {
X    fprintf(ostream, "%0.4f", vec[i]);
X
X    if (i != m - 1)
X      fprintf(ostream, "\t");
X  }
X
X  fprintf(ostream, "|\n\n");
X
X#undef m
X}
X
XCGLM_INLINE
Xvoid
Xglm_aabb_print(vec3                    bbox[2],
X               const char * __restrict tag,
X               FILE       * __restrict ostream) {
X  int i, j;
X
X#define m 3
X
X  fprintf(ostream, "AABB (%s):\n", tag ? tag: "float");
X
X  for (i = 0; i < 2; i++) {
X    fprintf(ostream, "\t|");
X
X    for (j = 0; j < m; j++) {
X      fprintf(ostream, "%0.4f", bbox[i][j]);
X
X      if (j != m - 1)
X        fprintf(ostream, "\t");
X    }
X
X    fprintf(ostream, "|\n");
X  }
X
X  fprintf(ostream, "\n");
X
X#undef m
X}
X
X#endif /* cglm_io_h */
63693ed6831842533808e4e88fabc9d9
echo x - cglm/mat4.h
sed 's/^X//' >cglm/mat4.h << '774cfd8e89178f3fdb72f4057ad163f9'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*!
X * Most of functions in this header are optimized manually with SIMD
X * if available. You dont need to call/incude SIMD headers manually
X */
X
X/*
X Macros:
X   GLM_MAT4_IDENTITY_INIT
X   GLM_MAT4_ZERO_INIT
X   GLM_MAT4_IDENTITY
X   GLM_MAT4_ZERO
X
X Functions:
X   CGLM_INLINE void  glm_mat4_ucopy(mat4 mat, mat4 dest);
X   CGLM_INLINE void  glm_mat4_copy(mat4 mat, mat4 dest);
X   CGLM_INLINE void  glm_mat4_identity(mat4 mat);
X   CGLM_INLINE void  glm_mat4_identity_array(mat4 * restrict mat, size_t count);
X   CGLM_INLINE void  glm_mat4_zero(mat4 mat);
X   CGLM_INLINE void  glm_mat4_pick3(mat4 mat, mat3 dest);
X   CGLM_INLINE void  glm_mat4_pick3t(mat4 mat, mat3 dest);
X   CGLM_INLINE void  glm_mat4_ins3(mat3 mat, mat4 dest);
X   CGLM_INLINE void  glm_mat4_mul(mat4 m1, mat4 m2, mat4 dest);
X   CGLM_INLINE void  glm_mat4_mulN(mat4 *matrices[], int len, mat4 dest);
X   CGLM_INLINE void  glm_mat4_mulv(mat4 m, vec4 v, vec4 dest);
X   CGLM_INLINE void  glm_mat4_mulv3(mat4 m, vec3 v, vec3 dest);
X   CGLM_INLINE float glm_mat4_trace(mat4 m);
X   CGLM_INLINE float glm_mat4_trace3(mat4 m);
X   CGLM_INLINE void  glm_mat4_quat(mat4 m, versor dest) ;
X   CGLM_INLINE void  glm_mat4_transpose_to(mat4 m, mat4 dest);
X   CGLM_INLINE void  glm_mat4_transpose(mat4 m);
X   CGLM_INLINE void  glm_mat4_scale_p(mat4 m, float s);
X   CGLM_INLINE void  glm_mat4_scale(mat4 m, float s);
X   CGLM_INLINE float glm_mat4_det(mat4 mat);
X   CGLM_INLINE void  glm_mat4_inv(mat4 mat, mat4 dest);
X   CGLM_INLINE void  glm_mat4_inv_fast(mat4 mat, mat4 dest);
X   CGLM_INLINE void  glm_mat4_swap_col(mat4 mat, int col1, int col2);
X   CGLM_INLINE void  glm_mat4_swap_row(mat4 mat, int row1, int row2);
X   CGLM_INLINE float glm_mat4_rmc(vec4 r, mat4 m, vec4 c);
X */
X
X#ifndef cglm_mat_h
X#define cglm_mat_h
X
X#include "common.h"
X#include "vec4.h"
X#include "vec3.h"
X
X#ifdef CGLM_SSE_FP
X#  include "simd/sse2/mat4.h"
X#endif
X
X#ifdef CGLM_AVX_FP
X#  include "simd/avx/mat4.h"
X#endif
X
X#ifdef CGLM_NEON_FP
X#  include "simd/neon/mat4.h"
X#endif
X
X#ifdef DEBUG
X# include <assert.h>
X#endif
X
X#define GLM_MAT4_IDENTITY_INIT  {{1.0f, 0.0f, 0.0f, 0.0f},                    \
X                                 {0.0f, 1.0f, 0.0f, 0.0f},                    \
X                                 {0.0f, 0.0f, 1.0f, 0.0f},                    \
X                                 {0.0f, 0.0f, 0.0f, 1.0f}}
X
X#define GLM_MAT4_ZERO_INIT      {{0.0f, 0.0f, 0.0f, 0.0f},                    \
X                                 {0.0f, 0.0f, 0.0f, 0.0f},                    \
X                                 {0.0f, 0.0f, 0.0f, 0.0f},                    \
X                                 {0.0f, 0.0f, 0.0f, 0.0f}}
X
X/* for C only */
X#define GLM_MAT4_IDENTITY ((mat4)GLM_MAT4_IDENTITY_INIT)
X#define GLM_MAT4_ZERO     ((mat4)GLM_MAT4_ZERO_INIT)
X
X/* DEPRECATED! use _copy, _ucopy versions */
X#define glm_mat4_udup(mat, dest) glm_mat4_ucopy(mat, dest)
X#define glm_mat4_dup(mat, dest)  glm_mat4_copy(mat, dest)
X
X/* DEPRECATED! default is precise now. */
X#define glm_mat4_inv_precise(mat, dest) glm_mat4_inv(mat, dest)
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * matrix may not be aligned, u stands for unaligned, this may be useful when
X * copying a matrix from external source e.g. asset importer...
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_ucopy(mat4 mat, mat4 dest) {
X  dest[0][0] = mat[0][0];  dest[1][0] = mat[1][0];
X  dest[0][1] = mat[0][1];  dest[1][1] = mat[1][1];
X  dest[0][2] = mat[0][2];  dest[1][2] = mat[1][2];
X  dest[0][3] = mat[0][3];  dest[1][3] = mat[1][3];
X
X  dest[2][0] = mat[2][0];  dest[3][0] = mat[3][0];
X  dest[2][1] = mat[2][1];  dest[3][1] = mat[3][1];
X  dest[2][2] = mat[2][2];  dest[3][2] = mat[3][2];
X  dest[2][3] = mat[2][3];  dest[3][3] = mat[3][3];
X}
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_copy(mat4 mat, mat4 dest) {
X#ifdef __AVX__
X  glmm_store256(dest[0], glmm_load256(mat[0]));
X  glmm_store256(dest[2], glmm_load256(mat[2]));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest[0], glmm_load(mat[0]));
X  glmm_store(dest[1], glmm_load(mat[1]));
X  glmm_store(dest[2], glmm_load(mat[2]));
X  glmm_store(dest[3], glmm_load(mat[3]));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest[0], vld1q_f32(mat[0]));
X  vst1q_f32(dest[1], vld1q_f32(mat[1]));
X  vst1q_f32(dest[2], vld1q_f32(mat[2]));
X  vst1q_f32(dest[3], vld1q_f32(mat[3]));
X#else
X  glm_mat4_ucopy(mat, dest);
X#endif
X}
X
X/*!
X * @brief make given matrix identity. It is identical with below, 
X *        but it is more easy to do that with this func especially for members
X *        e.g. glm_mat4_identity(aStruct->aMatrix);
X *
X * @code
X * glm_mat4_copy(GLM_MAT4_IDENTITY, mat); // C only
X *
X * // or
X * mat4 mat = GLM_MAT4_IDENTITY_INIT;
X * @endcode
X *
X * @param[in, out]  mat  destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_identity(mat4 mat) {
X  CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;
X  glm_mat4_copy(t, mat);
X}
X
X/*!
X * @brief make given matrix array's each element identity matrix
X *
X * @param[in, out]  mat   matrix array (must be aligned (16/32)
X *                        if alignment is not disabled)
X *
X * @param[in]       count count of matrices
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_identity_array(mat4 * __restrict mat, size_t count) {
X  CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;
X  size_t i;
X
X  for (i = 0; i < count; i++) {
X    glm_mat4_copy(t, mat[i]);
X  }
X}
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_zero(mat4 mat) {
X  CGLM_ALIGN_MAT mat4 t = GLM_MAT4_ZERO_INIT;
X  glm_mat4_copy(t, mat);
X}
X
X/*!
X * @brief copy upper-left of mat4 to mat3
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_pick3(mat4 mat, mat3 dest) {
X  dest[0][0] = mat[0][0];
X  dest[0][1] = mat[0][1];
X  dest[0][2] = mat[0][2];
X
X  dest[1][0] = mat[1][0];
X  dest[1][1] = mat[1][1];
X  dest[1][2] = mat[1][2];
X
X  dest[2][0] = mat[2][0];
X  dest[2][1] = mat[2][1];
X  dest[2][2] = mat[2][2];
X}
X
X/*!
X * @brief copy upper-left of mat4 to mat3 (transposed)
X *
X * the postfix t stands for transpose
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_pick3t(mat4 mat, mat3 dest) {
X  dest[0][0] = mat[0][0];
X  dest[0][1] = mat[1][0];
X  dest[0][2] = mat[2][0];
X
X  dest[1][0] = mat[0][1];
X  dest[1][1] = mat[1][1];
X  dest[1][2] = mat[2][1];
X
X  dest[2][0] = mat[0][2];
X  dest[2][1] = mat[1][2];
X  dest[2][2] = mat[2][2];
X}
X
X/*!
X * @brief copy mat3 to mat4's upper-left
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_ins3(mat3 mat, mat4 dest) {
X  dest[0][0] = mat[0][0];
X  dest[0][1] = mat[0][1];
X  dest[0][2] = mat[0][2];
X
X  dest[1][0] = mat[1][0];
X  dest[1][1] = mat[1][1];
X  dest[1][2] = mat[1][2];
X
X  dest[2][0] = mat[2][0];
X  dest[2][1] = mat[2][1];
X  dest[2][2] = mat[2][2];
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * m1, m2 and dest matrices can be same matrix, it is possible to write this:
X *
X * @code
X * mat4 m = GLM_MAT4_IDENTITY_INIT;
X * glm_mat4_mul(m, m, m);
X * @endcode
X *
X * @param[in]  m1   left matrix
X * @param[in]  m2   right matrix
X * @param[out] dest destination matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_mul(mat4 m1, mat4 m2, mat4 dest) {
X#ifdef __AVX__
X  glm_mat4_mul_avx(m1, m2, dest);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat4_mul_sse2(m1, m2, dest);
X#elif defined(CGLM_NEON_FP)
X  glm_mat4_mul_neon(m1, m2, dest);
X#else
X  float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2], a03 = m1[0][3],
X        a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2], a13 = m1[1][3],
X        a20 = m1[2][0], a21 = m1[2][1], a22 = m1[2][2], a23 = m1[2][3],
X        a30 = m1[3][0], a31 = m1[3][1], a32 = m1[3][2], a33 = m1[3][3],
X
X        b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2], b03 = m2[0][3],
X        b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2], b13 = m2[1][3],
X        b20 = m2[2][0], b21 = m2[2][1], b22 = m2[2][2], b23 = m2[2][3],
X        b30 = m2[3][0], b31 = m2[3][1], b32 = m2[3][2], b33 = m2[3][3];
X
X  dest[0][0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
X  dest[0][1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
X  dest[0][2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
X  dest[0][3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
X  dest[1][0] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
X  dest[1][1] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
X  dest[1][2] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
X  dest[1][3] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
X  dest[2][0] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
X  dest[2][1] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
X  dest[2][2] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
X  dest[2][3] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
X  dest[3][0] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
X  dest[3][1] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
X  dest[3][2] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
X  dest[3][3] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
X#endif
X}
X
X/*!
X * @brief mupliply N mat4 matrices and store result in dest
X *
X * this function lets you multiply multiple (more than two or more...) matrices
X * <br><br>multiplication will be done in loop, this may reduce instructions
X * size but if <b>len</b> is too small then compiler may unroll whole loop,
X * usage:
X * @code
X * mat m1, m2, m3, m4, res;
X *
X * glm_mat4_mulN((mat4 *[]){&m1, &m2, &m3, &m4}, 4, res);
X * @endcode
X *
X * @warning matrices parameter is pointer array not mat4 array!
X *
X * @param[in]  matrices mat4 * array
X * @param[in]  len      matrices count
X * @param[out] dest     result
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_mulN(mat4 * __restrict matrices[], uint32_t len, mat4 dest) {
X  uint32_t i;
X
X#ifdef DEBUG
X  assert(len > 1 && "there must be least 2 matrices to go!");
X#endif
X
X  glm_mat4_mul(*matrices[0], *matrices[1], dest);
X
X  for (i = 2; i < len; i++)
X    glm_mat4_mul(dest, *matrices[i], dest);
X}
X
X/*!
X * @brief multiply mat4 with vec4 (column vector) and store in dest vector
X *
X * @param[in]  m    mat4 (left)
X * @param[in]  v    vec4 (right, column vector)
X * @param[out] dest vec4 (result, column vector)
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_mulv(mat4 m, vec4 v, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat4_mulv_sse2(m, v, dest);
X#else
X  vec4 res;
X  res[0] = m[0][0] * v[0] + m[1][0] * v[1] + m[2][0] * v[2] + m[3][0] * v[3];
X  res[1] = m[0][1] * v[0] + m[1][1] * v[1] + m[2][1] * v[2] + m[3][1] * v[3];
X  res[2] = m[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2] + m[3][2] * v[3];
X  res[3] = m[0][3] * v[0] + m[1][3] * v[1] + m[2][3] * v[2] + m[3][3] * v[3];
X  glm_vec4_copy(res, dest);
X#endif
X}
X
X/*!
X * @brief trace of matrix
X *
X * sum of the elements on the main diagonal from upper left to the lower right
X *
X * @param[in]  m matrix
X */
XCGLM_INLINE
Xfloat
Xglm_mat4_trace(mat4 m) {
X  return m[0][0] + m[1][1] + m[2][2] + m[3][3];
X}
X
X/*!
X * @brief trace of matrix (rotation part)
X *
X * sum of the elements on the main diagonal from upper left to the lower right
X *
X * @param[in]  m matrix
X */
XCGLM_INLINE
Xfloat
Xglm_mat4_trace3(mat4 m) {
X  return m[0][0] + m[1][1] + m[2][2];
X}
X
X/*!
X * @brief convert mat4's rotation part to quaternion
X *
X * @param[in]  m    affine matrix
X * @param[out] dest destination quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_quat(mat4 m, versor dest) {
X  float trace, r, rinv;
X
X  /* it seems using like m12 instead of m[1][2] causes extra instructions */
X
X  trace = m[0][0] + m[1][1] + m[2][2];
X  if (trace >= 0.0f) {
X    r       = sqrtf(1.0f + trace);
X    rinv    = 0.5f / r;
X
X    dest[0] = rinv * (m[1][2] - m[2][1]);
X    dest[1] = rinv * (m[2][0] - m[0][2]);
X    dest[2] = rinv * (m[0][1] - m[1][0]);
X    dest[3] = r    * 0.5f;
X  } else if (m[0][0] >= m[1][1] && m[0][0] >= m[2][2]) {
X    r       = sqrtf(1.0f - m[1][1] - m[2][2] + m[0][0]);
X    rinv    = 0.5f / r;
X
X    dest[0] = r    * 0.5f;
X    dest[1] = rinv * (m[0][1] + m[1][0]);
X    dest[2] = rinv * (m[0][2] + m[2][0]);
X    dest[3] = rinv * (m[1][2] - m[2][1]);
X  } else if (m[1][1] >= m[2][2]) {
X    r       = sqrtf(1.0f - m[0][0] - m[2][2] + m[1][1]);
X    rinv    = 0.5f / r;
X
X    dest[0] = rinv * (m[0][1] + m[1][0]);
X    dest[1] = r    * 0.5f;
X    dest[2] = rinv * (m[1][2] + m[2][1]);
X    dest[3] = rinv * (m[2][0] - m[0][2]);
X  } else {
X    r       = sqrtf(1.0f - m[0][0] - m[1][1] + m[2][2]);
X    rinv    = 0.5f / r;
X
X    dest[0] = rinv * (m[0][2] + m[2][0]);
X    dest[1] = rinv * (m[1][2] + m[2][1]);
X    dest[2] = r    * 0.5f;
X    dest[3] = rinv * (m[0][1] - m[1][0]);
X  }
X}
X
X/*!
X * @brief multiply vector with mat4
X *
X * actually the result is vec4, after multiplication the last component
X * is trimmed. if you need it don't use this func.
X *
X * @param[in]  m    mat4(affine transform)
X * @param[in]  v    vec3
X * @param[in]  last 4th item to make it vec4
X * @param[out] dest result vector (vec3)
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_mulv3(mat4 m, vec3 v, float last, vec3 dest) {
X  vec4 res;
X  glm_vec4(v, last, res);
X  glm_mat4_mulv(m, res, res);
X  glm_vec3(res, dest);
X}
X
X/*!
X * @brief transpose mat4 and store in dest
X *
X * source matrix will not be transposed unless dest is m
X *
X * @param[in]  m    matrix
X * @param[out] dest result
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_transpose_to(mat4 m, mat4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat4_transp_sse2(m, dest);
X#else
X  dest[0][0] = m[0][0]; dest[1][0] = m[0][1];
X  dest[0][1] = m[1][0]; dest[1][1] = m[1][1];
X  dest[0][2] = m[2][0]; dest[1][2] = m[2][1];
X  dest[0][3] = m[3][0]; dest[1][3] = m[3][1];
X  dest[2][0] = m[0][2]; dest[3][0] = m[0][3];
X  dest[2][1] = m[1][2]; dest[3][1] = m[1][3];
X  dest[2][2] = m[2][2]; dest[3][2] = m[2][3];
X  dest[2][3] = m[3][2]; dest[3][3] = m[3][3];
X#endif
X}
X
X/*!
X * @brief tranpose mat4 and store result in same matrix
X *
X * @param[in, out] m source and dest
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_transpose(mat4 m) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat4_transp_sse2(m, m);
X#else
X  mat4 d;
X  glm_mat4_transpose_to(m, d);
X  glm_mat4_ucopy(d, m);
X#endif
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix without simd optimization
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]      s scalar
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_scale_p(mat4 m, float s) {
X  m[0][0] *= s; m[0][1] *= s; m[0][2] *= s; m[0][3] *= s;
X  m[1][0] *= s; m[1][1] *= s; m[1][2] *= s; m[1][3] *= s;
X  m[2][0] *= s; m[2][1] *= s; m[2][2] *= s; m[2][3] *= s;
X  m[3][0] *= s; m[3][1] *= s; m[3][2] *= s; m[3][3] *= s;
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]      s scalar
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_scale(mat4 m, float s) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat4_scale_sse2(m, s);
X#elif defined(CGLM_NEON_FP)
X  float32x4_t v0;
X  v0 = vdupq_n_f32(s);
X  vst1q_f32(m[0], vmulq_f32(vld1q_f32(m[0]), v0));
X  vst1q_f32(m[1], vmulq_f32(vld1q_f32(m[1]), v0));
X  vst1q_f32(m[2], vmulq_f32(vld1q_f32(m[2]), v0));
X  vst1q_f32(m[3], vmulq_f32(vld1q_f32(m[3]), v0));
X#else
X  glm_mat4_scale_p(m, s);
X#endif
X}
X
X/*!
X * @brief mat4 determinant
X *
X * @param[in] mat matrix
X *
X * @return determinant
X */
XCGLM_INLINE
Xfloat
Xglm_mat4_det(mat4 mat) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  return glm_mat4_det_sse2(mat);
X#else
X  /* [square] det(A) = det(At) */
X  float t[6];
X  float a = mat[0][0], b = mat[0][1], c = mat[0][2], d = mat[0][3],
X        e = mat[1][0], f = mat[1][1], g = mat[1][2], h = mat[1][3],
X        i = mat[2][0], j = mat[2][1], k = mat[2][2], l = mat[2][3],
X        m = mat[3][0], n = mat[3][1], o = mat[3][2], p = mat[3][3];
X
X  t[0] = k * p - o * l;
X  t[1] = j * p - n * l;
X  t[2] = j * o - n * k;
X  t[3] = i * p - m * l;
X  t[4] = i * o - m * k;
X  t[5] = i * n - m * j;
X
X  return a * (f * t[0] - g * t[1] + h * t[2])
X       - b * (e * t[0] - g * t[3] + h * t[4])
X       + c * (e * t[1] - f * t[3] + h * t[5])
X       - d * (e * t[2] - f * t[4] + g * t[5]);
X#endif
X}
X
X/*!
X * @brief inverse mat4 and store in dest
X *
X * @param[in]  mat  matrix
X * @param[out] dest inverse matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_inv(mat4 mat, mat4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat4_inv_sse2(mat, dest);
X#else
X  float t[6];
X  float det;
X  float a = mat[0][0], b = mat[0][1], c = mat[0][2], d = mat[0][3],
X        e = mat[1][0], f = mat[1][1], g = mat[1][2], h = mat[1][3],
X        i = mat[2][0], j = mat[2][1], k = mat[2][2], l = mat[2][3],
X        m = mat[3][0], n = mat[3][1], o = mat[3][2], p = mat[3][3];
X
X  t[0] = k * p - o * l; t[1] = j * p - n * l; t[2] = j * o - n * k;
X  t[3] = i * p - m * l; t[4] = i * o - m * k; t[5] = i * n - m * j;
X
X  dest[0][0] =  f * t[0] - g * t[1] + h * t[2];
X  dest[1][0] =-(e * t[0] - g * t[3] + h * t[4]);
X  dest[2][0] =  e * t[1] - f * t[3] + h * t[5];
X  dest[3][0] =-(e * t[2] - f * t[4] + g * t[5]);
X
X  dest[0][1] =-(b * t[0] - c * t[1] + d * t[2]);
X  dest[1][1] =  a * t[0] - c * t[3] + d * t[4];
X  dest[2][1] =-(a * t[1] - b * t[3] + d * t[5]);
X  dest[3][1] =  a * t[2] - b * t[4] + c * t[5];
X
X  t[0] = g * p - o * h; t[1] = f * p - n * h; t[2] = f * o - n * g;
X  t[3] = e * p - m * h; t[4] = e * o - m * g; t[5] = e * n - m * f;
X
X  dest[0][2] =  b * t[0] - c * t[1] + d * t[2];
X  dest[1][2] =-(a * t[0] - c * t[3] + d * t[4]);
X  dest[2][2] =  a * t[1] - b * t[3] + d * t[5];
X  dest[3][2] =-(a * t[2] - b * t[4] + c * t[5]);
X
X  t[0] = g * l - k * h; t[1] = f * l - j * h; t[2] = f * k - j * g;
X  t[3] = e * l - i * h; t[4] = e * k - i * g; t[5] = e * j - i * f;
X
X  dest[0][3] =-(b * t[0] - c * t[1] + d * t[2]);
X  dest[1][3] =  a * t[0] - c * t[3] + d * t[4];
X  dest[2][3] =-(a * t[1] - b * t[3] + d * t[5]);
X  dest[3][3] =  a * t[2] - b * t[4] + c * t[5];
X
X  det = 1.0f / (a * dest[0][0] + b * dest[1][0]
X              + c * dest[2][0] + d * dest[3][0]);
X
X  glm_mat4_scale_p(dest, det);
X#endif
X}
X
X/*!
X * @brief inverse mat4 and store in dest
X *
X * this func uses reciprocal approximation without extra corrections
X * e.g Newton-Raphson. this should work faster than normal,
X * to get more precise use glm_mat4_inv version.
X *
X * NOTE: You will lose precision, glm_mat4_inv is more accurate
X *
X * @param[in]  mat  matrix
X * @param[out] dest inverse matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_inv_fast(mat4 mat, mat4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat4_inv_fast_sse2(mat, dest);
X#else
X  glm_mat4_inv(mat, dest);
X#endif
X}
X
X/*!
X * @brief swap two matrix columns
X *
X * @param[in,out] mat  matrix
X * @param[in]     col1 col1
X * @param[in]     col2 col2
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_swap_col(mat4 mat, int col1, int col2) {
X  CGLM_ALIGN(16) vec4 tmp;
X  glm_vec4_copy(mat[col1], tmp);
X  glm_vec4_copy(mat[col2], mat[col1]);
X  glm_vec4_copy(tmp, mat[col2]);
X}
X
X/*!
X * @brief swap two matrix rows
X *
X * @param[in,out] mat  matrix
X * @param[in]     row1 row1
X * @param[in]     row2 row2
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_swap_row(mat4 mat, int row1, int row2) {
X  CGLM_ALIGN(16) vec4 tmp;
X  tmp[0] = mat[0][row1];
X  tmp[1] = mat[1][row1];
X  tmp[2] = mat[2][row1];
X  tmp[3] = mat[3][row1];
X
X  mat[0][row1] = mat[0][row2];
X  mat[1][row1] = mat[1][row2];
X  mat[2][row1] = mat[2][row2];
X  mat[3][row1] = mat[3][row2];
X
X  mat[0][row2] = tmp[0];
X  mat[1][row2] = tmp[1];
X  mat[2][row2] = tmp[2];
X  mat[3][row2] = tmp[3];
X}
X
X/*!
X * @brief helper for  R (row vector) * M (matrix) * C (column vector)
X *
X * rmc stands for Row * Matrix * Column
X *
X * the result is scalar because R * M = Matrix1x4 (row vector),
X * then Matrix1x4 * Vec4 (column vector) = Matrix1x1 (Scalar)
X *
X * @param[in]  r   row vector or matrix1x4
X * @param[in]  m   matrix4x4
X * @param[in]  c   column vector or matrix4x1
X *
X * @return scalar value e.g. B(s)
X */
XCGLM_INLINE
Xfloat
Xglm_mat4_rmc(vec4 r, mat4 m, vec4 c) {
X  vec4 tmp;
X  glm_mat4_mulv(m, c, tmp);
X  return glm_vec4_dot(r, tmp);
X}
X
X#endif /* cglm_mat_h */
774cfd8e89178f3fdb72f4057ad163f9
echo x - cglm/mat3.h
sed 's/^X//' >cglm/mat3.h << '7b299bcaf63cee6af26f15e451462141'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_MAT3_IDENTITY_INIT
X   GLM_MAT3_ZERO_INIT
X   GLM_MAT3_IDENTITY
X   GLM_MAT3_ZERO
X   glm_mat3_dup(mat, dest)
X
X Functions:
X   CGLM_INLINE void  glm_mat3_copy(mat3 mat, mat3 dest);
X   CGLM_INLINE void  glm_mat3_identity(mat3 mat);
X   CGLM_INLINE void  glm_mat3_identity_array(mat3 * restrict mat, size_t count);
X   CGLM_INLINE void  glm_mat3_zero(mat3 mat);
X   CGLM_INLINE void  glm_mat3_mul(mat3 m1, mat3 m2, mat3 dest);
X   CGLM_INLINE void  glm_mat3_transpose_to(mat3 m, mat3 dest);
X   CGLM_INLINE void  glm_mat3_transpose(mat3 m);
X   CGLM_INLINE void  glm_mat3_mulv(mat3 m, vec3 v, vec3 dest);
X   CGLM_INLINE float glm_mat3_trace(mat3 m);
X   CGLM_INLINE void  glm_mat3_quat(mat3 m, versor dest);
X   CGLM_INLINE void  glm_mat3_scale(mat3 m, float s);
X   CGLM_INLINE float glm_mat3_det(mat3 mat);
X   CGLM_INLINE void  glm_mat3_inv(mat3 mat, mat3 dest);
X   CGLM_INLINE void  glm_mat3_swap_col(mat3 mat, int col1, int col2);
X   CGLM_INLINE void  glm_mat3_swap_row(mat3 mat, int row1, int row2);
X   CGLM_INLINE float glm_mat3_rmc(vec3 r, mat3 m, vec3 c);
X */
X
X#ifndef cglm_mat3_h
X#define cglm_mat3_h
X
X#include "common.h"
X#include "vec3.h"
X
X#ifdef CGLM_SSE_FP
X#  include "simd/sse2/mat3.h"
X#endif
X
X#define GLM_MAT3_IDENTITY_INIT  {{1.0f, 0.0f, 0.0f},                          \
X                                 {0.0f, 1.0f, 0.0f},                          \
X                                 {0.0f, 0.0f, 1.0f}}
X#define GLM_MAT3_ZERO_INIT      {{0.0f, 0.0f, 0.0f},                          \
X                                 {0.0f, 0.0f, 0.0f},                          \
X                                 {0.0f, 0.0f, 0.0f}}
X
X
X/* for C only */
X#define GLM_MAT3_IDENTITY ((mat3)GLM_MAT3_IDENTITY_INIT)
X#define GLM_MAT3_ZERO     ((mat3)GLM_MAT3_ZERO_INIT)
X
X/* DEPRECATED! use _copy, _ucopy versions */
X#define glm_mat3_dup(mat, dest) glm_mat3_copy(mat, dest)
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_copy(mat3 mat, mat3 dest) {
X  dest[0][0] = mat[0][0];
X  dest[0][1] = mat[0][1];
X  dest[0][2] = mat[0][2];
X
X  dest[1][0] = mat[1][0];
X  dest[1][1] = mat[1][1];
X  dest[1][2] = mat[1][2];
X
X  dest[2][0] = mat[2][0];
X  dest[2][1] = mat[2][1];
X  dest[2][2] = mat[2][2];
X}
X
X/*!
X * @brief make given matrix identity. It is identical with below,
X *        but it is more easy to do that with this func especially for members
X *        e.g. glm_mat3_identity(aStruct->aMatrix);
X *
X * @code
X * glm_mat3_copy(GLM_MAT3_IDENTITY, mat); // C only
X *
X * // or
X * mat3 mat = GLM_MAT3_IDENTITY_INIT;
X * @endcode
X *
X * @param[in, out]  mat  destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_identity(mat3 mat) {
X  CGLM_ALIGN_MAT mat3 t = GLM_MAT3_IDENTITY_INIT;
X  glm_mat3_copy(t, mat);
X}
X
X/*!
X * @brief make given matrix array's each element identity matrix
X *
X * @param[in, out]  mat   matrix array (must be aligned (16/32)
X *                        if alignment is not disabled)
X *
X * @param[in]       count count of matrices
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_identity_array(mat3 * __restrict mat, size_t count) {
X  CGLM_ALIGN_MAT mat3 t = GLM_MAT3_IDENTITY_INIT;
X  size_t i;
X
X  for (i = 0; i < count; i++) {
X    glm_mat3_copy(t, mat[i]);
X  }
X}
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_zero(mat3 mat) {
X  CGLM_ALIGN_MAT mat3 t = GLM_MAT3_ZERO_INIT;
X  glm_mat3_copy(t, mat);
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * m1, m2 and dest matrices can be same matrix, it is possible to write this:
X *
X * @code
X * mat3 m = GLM_MAT3_IDENTITY_INIT;
X * glm_mat3_mul(m, m, m);
X * @endcode
X *
X * @param[in]  m1   left matrix
X * @param[in]  m2   right matrix
X * @param[out] dest destination matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_mul(mat3 m1, mat3 m2, mat3 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat3_mul_sse2(m1, m2, dest);
X#else
X  float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2],
X        a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2],
X        a20 = m1[2][0], a21 = m1[2][1], a22 = m1[2][2],
X
X        b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2],
X        b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2],
X        b20 = m2[2][0], b21 = m2[2][1], b22 = m2[2][2];
X
X  dest[0][0] = a00 * b00 + a10 * b01 + a20 * b02;
X  dest[0][1] = a01 * b00 + a11 * b01 + a21 * b02;
X  dest[0][2] = a02 * b00 + a12 * b01 + a22 * b02;
X  dest[1][0] = a00 * b10 + a10 * b11 + a20 * b12;
X  dest[1][1] = a01 * b10 + a11 * b11 + a21 * b12;
X  dest[1][2] = a02 * b10 + a12 * b11 + a22 * b12;
X  dest[2][0] = a00 * b20 + a10 * b21 + a20 * b22;
X  dest[2][1] = a01 * b20 + a11 * b21 + a21 * b22;
X  dest[2][2] = a02 * b20 + a12 * b21 + a22 * b22;
X#endif
X}
X
X/*!
X * @brief transpose mat3 and store in dest
X *
X * source matrix will not be transposed unless dest is m
X *
X * @param[in]  m     matrix
X * @param[out] dest  result
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_transpose_to(mat3 m, mat3 dest) {
X  dest[0][0] = m[0][0];
X  dest[0][1] = m[1][0];
X  dest[0][2] = m[2][0];
X  dest[1][0] = m[0][1];
X  dest[1][1] = m[1][1];
X  dest[1][2] = m[2][1];
X  dest[2][0] = m[0][2];
X  dest[2][1] = m[1][2];
X  dest[2][2] = m[2][2];
X}
X
X/*!
X * @brief tranpose mat3 and store result in same matrix
X *
X * @param[in, out] m source and dest
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_transpose(mat3 m) {
X  CGLM_ALIGN_MAT mat3 tmp;
X
X  tmp[0][1] = m[1][0];
X  tmp[0][2] = m[2][0];
X  tmp[1][0] = m[0][1];
X  tmp[1][2] = m[2][1];
X  tmp[2][0] = m[0][2];
X  tmp[2][1] = m[1][2];
X
X  m[0][1] = tmp[0][1];
X  m[0][2] = tmp[0][2];
X  m[1][0] = tmp[1][0];
X  m[1][2] = tmp[1][2];
X  m[2][0] = tmp[2][0];
X  m[2][1] = tmp[2][1];
X}
X
X/*!
X * @brief multiply mat3 with vec3 (column vector) and store in dest vector
X *
X * @param[in]  m    mat3 (left)
X * @param[in]  v    vec3 (right, column vector)
X * @param[out] dest vec3 (result, column vector)
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_mulv(mat3 m, vec3 v, vec3 dest) {
X  dest[0] = m[0][0] * v[0] + m[1][0] * v[1] + m[2][0] * v[2];
X  dest[1] = m[0][1] * v[0] + m[1][1] * v[1] + m[2][1] * v[2];
X  dest[2] = m[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2];
X}
X
X/*!
X * @brief trace of matrix
X *
X * sum of the elements on the main diagonal from upper left to the lower right
X *
X * @param[in]  m matrix
X */
XCGLM_INLINE
Xfloat
Xglm_mat3_trace(mat3 m) {
X  return m[0][0] + m[1][1] + m[2][2];
X}
X
X/*!
X * @brief convert mat3 to quaternion
X *
X * @param[in]  m    rotation matrix
X * @param[out] dest destination quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_quat(mat3 m, versor dest) {
X  float trace, r, rinv;
X
X  /* it seems using like m12 instead of m[1][2] causes extra instructions */
X
X  trace = m[0][0] + m[1][1] + m[2][2];
X  if (trace >= 0.0f) {
X    r       = sqrtf(1.0f + trace);
X    rinv    = 0.5f / r;
X
X    dest[0] = rinv * (m[1][2] - m[2][1]);
X    dest[1] = rinv * (m[2][0] - m[0][2]);
X    dest[2] = rinv * (m[0][1] - m[1][0]);
X    dest[3] = r    * 0.5f;
X  } else if (m[0][0] >= m[1][1] && m[0][0] >= m[2][2]) {
X    r       = sqrtf(1.0f - m[1][1] - m[2][2] + m[0][0]);
X    rinv    = 0.5f / r;
X
X    dest[0] = r    * 0.5f;
X    dest[1] = rinv * (m[0][1] + m[1][0]);
X    dest[2] = rinv * (m[0][2] + m[2][0]);
X    dest[3] = rinv * (m[1][2] - m[2][1]);
X  } else if (m[1][1] >= m[2][2]) {
X    r       = sqrtf(1.0f - m[0][0] - m[2][2] + m[1][1]);
X    rinv    = 0.5f / r;
X
X    dest[0] = rinv * (m[0][1] + m[1][0]);
X    dest[1] = r    * 0.5f;
X    dest[2] = rinv * (m[1][2] + m[2][1]);
X    dest[3] = rinv * (m[2][0] - m[0][2]);
X  } else {
X    r       = sqrtf(1.0f - m[0][0] - m[1][1] + m[2][2]);
X    rinv    = 0.5f / r;
X
X    dest[0] = rinv * (m[0][2] + m[2][0]);
X    dest[1] = rinv * (m[1][2] + m[2][1]);
X    dest[2] = r    * 0.5f;
X    dest[3] = rinv * (m[0][1] - m[1][0]);
X  }
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]      s scalar
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_scale(mat3 m, float s) {
X  m[0][0] *= s; m[0][1] *= s; m[0][2] *= s;
X  m[1][0] *= s; m[1][1] *= s; m[1][2] *= s;
X  m[2][0] *= s; m[2][1] *= s; m[2][2] *= s;
X}
X
X/*!
X * @brief mat3 determinant
X *
X * @param[in] mat matrix
X *
X * @return determinant
X */
XCGLM_INLINE
Xfloat
Xglm_mat3_det(mat3 mat) {
X  float a = mat[0][0], b = mat[0][1], c = mat[0][2],
X        d = mat[1][0], e = mat[1][1], f = mat[1][2],
X        g = mat[2][0], h = mat[2][1], i = mat[2][2];
X
X  return a * (e * i - h * f) - d * (b * i - c * h) + g * (b * f - c * e);
X}
X
X/*!
X * @brief inverse mat3 and store in dest
X *
X * @param[in]  mat  matrix
X * @param[out] dest inverse matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_inv(mat3 mat, mat3 dest) {
X  float det;
X  float a = mat[0][0], b = mat[0][1], c = mat[0][2],
X        d = mat[1][0], e = mat[1][1], f = mat[1][2],
X        g = mat[2][0], h = mat[2][1], i = mat[2][2];
X
X  dest[0][0] =   e * i - f * h;
X  dest[0][1] = -(b * i - h * c);
X  dest[0][2] =   b * f - e * c;
X  dest[1][0] = -(d * i - g * f);
X  dest[1][1] =   a * i - c * g;
X  dest[1][2] = -(a * f - d * c);
X  dest[2][0] =   d * h - g * e;
X  dest[2][1] = -(a * h - g * b);
X  dest[2][2] =   a * e - b * d;
X
X  det = 1.0f / (a * dest[0][0] + b * dest[1][0] + c * dest[2][0]);
X
X  glm_mat3_scale(dest, det);
X}
X
X/*!
X * @brief swap two matrix columns
X *
X * @param[in,out] mat  matrix
X * @param[in]     col1 col1
X * @param[in]     col2 col2
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_swap_col(mat3 mat, int col1, int col2) {
X  vec3 tmp;
X  glm_vec3_copy(mat[col1], tmp);
X  glm_vec3_copy(mat[col2], mat[col1]);
X  glm_vec3_copy(tmp, mat[col2]);
X}
X
X/*!
X * @brief swap two matrix rows
X *
X * @param[in,out] mat  matrix
X * @param[in]     row1 row1
X * @param[in]     row2 row2
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_swap_row(mat3 mat, int row1, int row2) {
X  vec3 tmp;
X  tmp[0] = mat[0][row1];
X  tmp[1] = mat[1][row1];
X  tmp[2] = mat[2][row1];
X
X  mat[0][row1] = mat[0][row2];
X  mat[1][row1] = mat[1][row2];
X  mat[2][row1] = mat[2][row2];
X
X  mat[0][row2] = tmp[0];
X  mat[1][row2] = tmp[1];
X  mat[2][row2] = tmp[2];
X}
X
X/*!
X * @brief helper for  R (row vector) * M (matrix) * C (column vector)
X *
X * rmc stands for Row * Matrix * Column
X *
X * the result is scalar because R * M = Matrix1x3 (row vector),
X * then Matrix1x3 * Vec3 (column vector) = Matrix1x1 (Scalar)
X *
X * @param[in]  r   row vector or matrix1x3
X * @param[in]  m   matrix3x3
X * @param[in]  c   column vector or matrix3x1
X *
X * @return scalar value e.g. Matrix1x1
X */
XCGLM_INLINE
Xfloat
Xglm_mat3_rmc(vec3 r, mat3 m, vec3 c) {
X  vec3 tmp;
X  glm_mat3_mulv(m, c, tmp);
X  return glm_vec3_dot(r, tmp);
X}
X
X#endif /* cglm_mat3_h */
7b299bcaf63cee6af26f15e451462141
echo x - cglm/affine.h
sed 's/^X//' >cglm/affine.h << '43b5489fcd1d208f21cb3a378edfce43'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_translate_to(mat4 m, vec3 v, mat4 dest);
X   CGLM_INLINE void glm_translate(mat4 m, vec3 v);
X   CGLM_INLINE void glm_translate_x(mat4 m, float to);
X   CGLM_INLINE void glm_translate_y(mat4 m, float to);
X   CGLM_INLINE void glm_translate_z(mat4 m, float to);
X   CGLM_INLINE void glm_translate_make(mat4 m, vec3 v);
X   CGLM_INLINE void glm_scale_to(mat4 m, vec3 v, mat4 dest);
X   CGLM_INLINE void glm_scale_make(mat4 m, vec3 v);
X   CGLM_INLINE void glm_scale(mat4 m, vec3 v);
X   CGLM_INLINE void glm_scale_uni(mat4 m, float s);
X   CGLM_INLINE void glm_rotate_x(mat4 m, float angle, mat4 dest);
X   CGLM_INLINE void glm_rotate_y(mat4 m, float angle, mat4 dest);
X   CGLM_INLINE void glm_rotate_z(mat4 m, float angle, mat4 dest);
X   CGLM_INLINE void glm_rotate_make(mat4 m, float angle, vec3 axis);
X   CGLM_INLINE void glm_rotate(mat4 m, float angle, vec3 axis);
X   CGLM_INLINE void glm_rotate_at(mat4 m, vec3 pivot, float angle, vec3 axis);
X   CGLM_INLINE void glm_rotate_atm(mat4 m, vec3 pivot, float angle, vec3 axis);
X   CGLM_INLINE void glm_decompose_scalev(mat4 m, vec3 s);
X   CGLM_INLINE bool glm_uniscaled(mat4 m);
X   CGLM_INLINE void glm_decompose_rs(mat4 m, mat4 r, vec3 s);
X   CGLM_INLINE void glm_decompose(mat4 m, vec4 t, mat4 r, vec3 s);
X */
X
X#ifndef cglm_affine_h
X#define cglm_affine_h
X
X#include "common.h"
X#include "util.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X#include "affine-mat.h"
X
XCGLM_INLINE
Xvoid
Xglm_mat4_mul(mat4 m1, mat4 m2, mat4 dest);
X
X/*!
X * @brief translate existing transform matrix by v vector
X *        and stores result in same matrix
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       v  translate vector [x, y, z]
X */
XCGLM_INLINE
Xvoid
Xglm_translate(mat4 m, vec3 v) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(m[3],
X             _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_load(m[0]),
X                                              _mm_set1_ps(v[0])),
X                                   _mm_mul_ps(glmm_load(m[1]),
X                                              _mm_set1_ps(v[1]))),
X                        _mm_add_ps(_mm_mul_ps(glmm_load(m[2]),
X                                              _mm_set1_ps(v[2])),
X                                   glmm_load(m[3]))))
X  ;
X#else
X  vec4 v1, v2, v3;
X
X  glm_vec4_scale(m[0], v[0], v1);
X  glm_vec4_scale(m[1], v[1], v2);
X  glm_vec4_scale(m[2], v[2], v3);
X
X  glm_vec4_add(v1, m[3], m[3]);
X  glm_vec4_add(v2, m[3], m[3]);
X  glm_vec4_add(v3, m[3], m[3]);
X#endif
X}
X
X/*!
X * @brief translate existing transform matrix by v vector
X *        and store result in dest
X *
X * source matrix will remain same
X *
X * @param[in]  m    affine transfrom
X * @param[in]  v    translate vector [x, y, z]
X * @param[out] dest translated matrix
X */
XCGLM_INLINE
Xvoid
Xglm_translate_to(mat4 m, vec3 v, mat4 dest) {
X  glm_mat4_copy(m, dest);
X  glm_translate(dest, v);
X}
X
X/*!
X * @brief translate existing transform matrix by x factor
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       x  x factor
X */
XCGLM_INLINE
Xvoid
Xglm_translate_x(mat4 m, float x) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(m[3],
X             _mm_add_ps(_mm_mul_ps(glmm_load(m[0]),
X                                   _mm_set1_ps(x)),
X                        glmm_load(m[3])))
X  ;
X#else
X  vec4 v1;
X  glm_vec4_scale(m[0], x, v1);
X  glm_vec4_add(v1, m[3], m[3]);
X#endif
X}
X
X/*!
X * @brief translate existing transform matrix by y factor
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       y  y factor
X */
XCGLM_INLINE
Xvoid
Xglm_translate_y(mat4 m, float y) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(m[3],
X             _mm_add_ps(_mm_mul_ps(glmm_load(m[1]),
X                                   _mm_set1_ps(y)),
X                        glmm_load(m[3])))
X  ;
X#else
X  vec4 v1;
X  glm_vec4_scale(m[1], y, v1);
X  glm_vec4_add(v1, m[3], m[3]);
X#endif
X}
X
X/*!
X * @brief translate existing transform matrix by z factor
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       z  z factor
X */
XCGLM_INLINE
Xvoid
Xglm_translate_z(mat4 m, float z) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(m[3],
X             _mm_add_ps(_mm_mul_ps(glmm_load(m[2]),
X                                   _mm_set1_ps(z)),
X                        glmm_load(m[3])))
X  ;
X#else
X  vec4 v1;
X  glm_vec4_scale(m[2], z, v1);
X  glm_vec4_add(v1, m[3], m[3]);
X#endif
X}
X
X/*!
X * @brief creates NEW translate transform matrix by v vector
X *
X * @param[out]  m  affine transfrom
X * @param[in]   v  translate vector [x, y, z]
X */
XCGLM_INLINE
Xvoid
Xglm_translate_make(mat4 m, vec3 v) {
X  glm_mat4_identity(m);
X  glm_vec3_copy(v, m[3]);
X}
X
X/*!
X * @brief scale existing transform matrix by v vector
X *        and store result in dest
X *
X * @param[in]  m    affine transfrom
X * @param[in]  v    scale vector [x, y, z]
X * @param[out] dest scaled matrix
X */
XCGLM_INLINE
Xvoid
Xglm_scale_to(mat4 m, vec3 v, mat4 dest) {
X  glm_vec4_scale(m[0], v[0], dest[0]);
X  glm_vec4_scale(m[1], v[1], dest[1]);
X  glm_vec4_scale(m[2], v[2], dest[2]);
X
X  glm_vec4_copy(m[3], dest[3]);
X}
X
X/*!
X * @brief creates NEW scale matrix by v vector
X *
X * @param[out]  m  affine transfrom
X * @param[in]   v  scale vector [x, y, z]
X */
XCGLM_INLINE
Xvoid
Xglm_scale_make(mat4 m, vec3 v) {
X  glm_mat4_identity(m);
X  m[0][0] = v[0];
X  m[1][1] = v[1];
X  m[2][2] = v[2];
X}
X
X/*!
X * @brief scales existing transform matrix by v vector
X *        and stores result in same matrix
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       v  scale vector [x, y, z]
X */
XCGLM_INLINE
Xvoid
Xglm_scale(mat4 m, vec3 v) {
X  glm_scale_to(m, v, m);
X}
X
X/*!
X * @brief applies uniform scale to existing transform matrix v = [s, s, s]
X *        and stores result in same matrix
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       s  scale factor
X */
XCGLM_INLINE
Xvoid
Xglm_scale_uni(mat4 m, float s) {
X  CGLM_ALIGN(8) vec3 v = { s, s, s };
X  glm_scale_to(m, v, m);
X}
X
X/*!
X * @brief rotate existing transform matrix around X axis by angle
X *        and store result in dest
X *
X * @param[in]   m      affine transfrom
X * @param[in]   angle  angle (radians)
X * @param[out]  dest   rotated matrix
X */
XCGLM_INLINE
Xvoid
Xglm_rotate_x(mat4 m, float angle, mat4 dest) {
X  CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;
X  float c, s;
X
X  c = cosf(angle);
X  s = sinf(angle);
X
X  t[1][1] =  c;
X  t[1][2] =  s;
X  t[2][1] = -s;
X  t[2][2] =  c;
X
X  glm_mul_rot(m, t, dest);
X}
X
X/*!
X * @brief rotate existing transform matrix around Y axis by angle
X *        and store result in dest
X *
X * @param[in]   m      affine transfrom
X * @param[in]   angle  angle (radians)
X * @param[out]  dest   rotated matrix
X */
XCGLM_INLINE
Xvoid
Xglm_rotate_y(mat4 m, float angle, mat4 dest) {
X  CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;
X  float c, s;
X
X  c = cosf(angle);
X  s = sinf(angle);
X
X  t[0][0] =  c;
X  t[0][2] = -s;
X  t[2][0] =  s;
X  t[2][2] =  c;
X
X  glm_mul_rot(m, t, dest);
X}
X
X/*!
X * @brief rotate existing transform matrix around Z axis by angle
X *        and store result in dest
X *
X * @param[in]   m      affine transfrom
X * @param[in]   angle  angle (radians)
X * @param[out]  dest   rotated matrix
X */
XCGLM_INLINE
Xvoid
Xglm_rotate_z(mat4 m, float angle, mat4 dest) {
X  CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;
X  float c, s;
X
X  c = cosf(angle);
X  s = sinf(angle);
X
X  t[0][0] =  c;
X  t[0][1] =  s;
X  t[1][0] = -s;
X  t[1][1] =  c;
X
X  glm_mul_rot(m, t, dest);
X}
X
X/*!
X * @brief creates NEW rotation matrix by angle and axis
X *
X * axis will be normalized so you don't need to normalize it
X *
X * @param[out] m     affine transfrom
X * @param[in]  angle angle (radians)
X * @param[in]  axis  axis
X */
XCGLM_INLINE
Xvoid
Xglm_rotate_make(mat4 m, float angle, vec3 axis) {
X  CGLM_ALIGN(8) vec3 axisn, v, vs;
X  float c;
X
X  c = cosf(angle);
X
X  glm_vec3_normalize_to(axis, axisn);
X  glm_vec3_scale(axisn, 1.0f - c, v);
X  glm_vec3_scale(axisn, sinf(angle), vs);
X
X  glm_vec3_scale(axisn, v[0], m[0]);
X  glm_vec3_scale(axisn, v[1], m[1]);
X  glm_vec3_scale(axisn, v[2], m[2]);
X
X  m[0][0] += c;       m[1][0] -= vs[2];   m[2][0] += vs[1];
X  m[0][1] += vs[2];   m[1][1] += c;       m[2][1] -= vs[0];
X  m[0][2] -= vs[1];   m[1][2] += vs[0];   m[2][2] += c;
X
X  m[0][3] = m[1][3] = m[2][3] = m[3][0] = m[3][1] = m[3][2] = 0.0f;
X  m[3][3] = 1.0f;
X}
X
X/*!
X * @brief rotate existing transform matrix around given axis by angle
X *
X * @param[in, out]  m      affine transfrom
X * @param[in]       angle  angle (radians)
X * @param[in]       axis   axis
X */
XCGLM_INLINE
Xvoid
Xglm_rotate(mat4 m, float angle, vec3 axis) {
X  CGLM_ALIGN_MAT mat4 rot;
X  glm_rotate_make(rot, angle, axis);
X  glm_mul_rot(m, rot, m);
X}
X
X/*!
X * @brief rotate existing transform
X *        around given axis by angle at given pivot point (rotation center)
X *
X * @param[in, out]  m      affine transfrom
X * @param[in]       pivot  rotation center
X * @param[in]       angle  angle (radians)
X * @param[in]       axis   axis
X */
XCGLM_INLINE
Xvoid
Xglm_rotate_at(mat4 m, vec3 pivot, float angle, vec3 axis) {
X  CGLM_ALIGN(8) vec3 pivotInv;
X
X  glm_vec3_negate_to(pivot, pivotInv);
X
X  glm_translate(m, pivot);
X  glm_rotate(m, angle, axis);
X  glm_translate(m, pivotInv);
X}
X
X/*!
X * @brief creates NEW rotation matrix by angle and axis at given point
X *
X * this creates rotation matrix, it assumes you don't have a matrix
X *
X * this should work faster than glm_rotate_at because it reduces
X * one glm_translate.
X *
X * @param[out] m      affine transfrom
X * @param[in]  pivot  rotation center
X * @param[in]  angle  angle (radians)
X * @param[in]  axis   axis
X */
XCGLM_INLINE
Xvoid
Xglm_rotate_atm(mat4 m, vec3 pivot, float angle, vec3 axis) {
X  CGLM_ALIGN(8) vec3 pivotInv;
X
X  glm_vec3_negate_to(pivot, pivotInv);
X
X  glm_translate_make(m, pivot);
X  glm_rotate(m, angle, axis);
X  glm_translate(m, pivotInv);
X}
X
X/*!
X * @brief decompose scale vector
X *
X * @param[in]  m  affine transform
X * @param[out] s  scale vector (Sx, Sy, Sz)
X */
XCGLM_INLINE
Xvoid
Xglm_decompose_scalev(mat4 m, vec3 s) {
X  s[0] = glm_vec3_norm(m[0]);
X  s[1] = glm_vec3_norm(m[1]);
X  s[2] = glm_vec3_norm(m[2]);
X}
X
X/*!
X * @brief returns true if matrix is uniform scaled. This is helpful for
X *        creating normal matrix.
X *
X * @param[in] m m
X *
X * @return boolean
X */
XCGLM_INLINE
Xbool
Xglm_uniscaled(mat4 m) {
X  CGLM_ALIGN(8) vec3 s;
X  glm_decompose_scalev(m, s);
X  return glm_vec3_eq_all(s);
X}
X
X/*!
X * @brief decompose rotation matrix (mat4) and scale vector [Sx, Sy, Sz]
X *        DON'T pass projected matrix here
X *
X * @param[in]  m affine transform
X * @param[out] r rotation matrix
X * @param[out] s scale matrix
X */
XCGLM_INLINE
Xvoid
Xglm_decompose_rs(mat4 m, mat4 r, vec3 s) {
X  CGLM_ALIGN(16) vec4 t = {0.0f, 0.0f, 0.0f, 1.0f};
X  CGLM_ALIGN(8)  vec3 v;
X
X  glm_vec4_copy(m[0], r[0]);
X  glm_vec4_copy(m[1], r[1]);
X  glm_vec4_copy(m[2], r[2]);
X  glm_vec4_copy(t,    r[3]);
X
X  s[0] = glm_vec3_norm(m[0]);
X  s[1] = glm_vec3_norm(m[1]);
X  s[2] = glm_vec3_norm(m[2]);
X
X  glm_vec4_scale(r[0], 1.0f/s[0], r[0]);
X  glm_vec4_scale(r[1], 1.0f/s[1], r[1]);
X  glm_vec4_scale(r[2], 1.0f/s[2], r[2]);
X
X  /* Note from Apple Open Source (asume that the matrix is orthonormal):
X     check for a coordinate system flip.  If the determinant
X     is -1, then negate the matrix and the scaling factors. */
X  glm_vec3_cross(m[0], m[1], v);
X  if (glm_vec3_dot(v, m[2]) < 0.0f) {
X    glm_vec4_negate(r[0]);
X    glm_vec4_negate(r[1]);
X    glm_vec4_negate(r[2]);
X    glm_vec3_negate(s);
X  }
X}
X
X/*!
X * @brief decompose affine transform, TODO: extract shear factors.
X *        DON'T pass projected matrix here
X *
X * @param[in]  m affine transfrom
X * @param[out] t translation vector
X * @param[out] r rotation matrix (mat4)
X * @param[out] s scaling vector [X, Y, Z]
X */
XCGLM_INLINE
Xvoid
Xglm_decompose(mat4 m, vec4 t, mat4 r, vec3 s) {
X  glm_vec4_copy(m[3], t);
X  glm_decompose_rs(m, r, s);
X}
X
X#endif /* cglm_affine_h */
43b5489fcd1d208f21cb3a378edfce43
echo x - cglm/vec3.h
sed 's/^X//' >cglm/vec3.h << '76cbf42507315cc0767578bd22730a73'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_VEC3_ONE_INIT
X   GLM_VEC3_ZERO_INIT
X   GLM_VEC3_ONE
X   GLM_VEC3_ZERO
X   GLM_YUP
X   GLM_ZUP
X   GLM_XUP
X
X Functions:
X   CGLM_INLINE void  glm_vec3(vec4 v4, vec3 dest);
X   CGLM_INLINE void  glm_vec3_copy(vec3 a, vec3 dest);
X   CGLM_INLINE void  glm_vec3_zero(vec3 v);
X   CGLM_INLINE void  glm_vec3_one(vec3 v);
X   CGLM_INLINE float glm_vec3_dot(vec3 a, vec3 b);
X   CGLM_INLINE float glm_vec3_norm2(vec3 v);
X   CGLM_INLINE float glm_vec3_norm(vec3 v);
X   CGLM_INLINE float glm_vec3_norm_one(vec3 v);
X   CGLM_INLINE float glm_vec3_norm_inf(vec3 v);
X   CGLM_INLINE void  glm_vec3_add(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_adds(vec3 a, float s, vec3 dest);
X   CGLM_INLINE void  glm_vec3_sub(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_subs(vec3 a, float s, vec3 dest);
X   CGLM_INLINE void  glm_vec3_mul(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_scale(vec3 v, float s, vec3 dest);
X   CGLM_INLINE void  glm_vec3_scale_as(vec3 v, float s, vec3 dest);
X   CGLM_INLINE void  glm_vec3_div(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_divs(vec3 a, float s, vec3 dest);
X   CGLM_INLINE void  glm_vec3_addadd(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_subadd(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_muladd(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_muladds(vec3 a, float s, vec3 dest);
X   CGLM_INLINE void  glm_vec3_maxadd(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_minadd(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_flipsign(vec3 v);
X   CGLM_INLINE void  glm_vec3_flipsign_to(vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_negate_to(vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_negate(vec3 v);
X   CGLM_INLINE void  glm_vec3_inv(vec3 v);
X   CGLM_INLINE void  glm_vec3_inv_to(vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_normalize(vec3 v);
X   CGLM_INLINE void  glm_vec3_normalize_to(vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_cross(vec3 a, vec3 b, vec3 d);
X   CGLM_INLINE void  glm_vec3_crossn(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE float glm_vec3_angle(vec3 a, vec3 b);
X   CGLM_INLINE void  glm_vec3_rotate(vec3 v, float angle, vec3 axis);
X   CGLM_INLINE void  glm_vec3_rotate_m4(mat4 m, vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_rotate_m3(mat3 m, vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_proj(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_center(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE float glm_vec3_distance(vec3 a, vec3 b);
X   CGLM_INLINE float glm_vec3_distance2(vec3 a, vec3 b);
X   CGLM_INLINE void  glm_vec3_maxv(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_minv(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_ortho(vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_clamp(vec3 v, float minVal, float maxVal);
X   CGLM_INLINE void  glm_vec3_lerp(vec3 from, vec3 to, float t, vec3 dest);
X   CGLM_INLINE void  glm_vec3_lerpc(vec3 from, vec3 to, float t, vec3 dest);
X   CGLM_INLINE void  glm_vec3_mix(vec3 from, vec3 to, float t, vec3 dest);
X   CGLM_INLINE void  glm_vec3_mixc(vec3 from, vec3 to, float t, vec3 dest);
X   CGLM_INLINE void  glm_vec3_step_uni(float edge, vec3 x, vec3 dest);
X   CGLM_INLINE void  glm_vec3_step(vec3 edge, vec3 x, vec3 dest);
X   CGLM_INLINE void  glm_vec3_smoothstep_uni(float edge0, float edge1, vec3 x, vec3 dest);
X   CGLM_INLINE void  glm_vec3_smoothstep(vec3 edge0, vec3 edge1, vec3 x, vec3 dest);
X   CGLM_INLINE void  glm_vec3_smoothinterp(vec3 from, vec3 to, float t, vec3 dest);
X   CGLM_INLINE void  glm_vec3_smoothinterpc(vec3 from, vec3 to, float t, vec3 dest);
X   CGLM_INLINE void  glm_vec3_swizzle(vec3 v, int mask, vec3 dest);
X
X Convenient:
X   CGLM_INLINE void  glm_cross(vec3 a, vec3 b, vec3 d);
X   CGLM_INLINE float glm_dot(vec3 a, vec3 b);
X   CGLM_INLINE void  glm_normalize(vec3 v);
X   CGLM_INLINE void  glm_normalize_to(vec3 v, vec3 dest);
X
X DEPRECATED:
X   glm_vec3_dup
X   glm_vec3_flipsign
X   glm_vec3_flipsign_to
X   glm_vec3_inv
X   glm_vec3_inv_to
X   glm_vec3_mulv
X */
X
X#ifndef cglm_vec3_h
X#define cglm_vec3_h
X
X#include "common.h"
X#include "vec4.h"
X#include "vec3-ext.h"
X#include "util.h"
X
X/* DEPRECATED! use _copy, _ucopy versions */
X#define glm_vec3_dup(v, dest)         glm_vec3_copy(v, dest)
X#define glm_vec3_flipsign(v)          glm_vec3_negate(v)
X#define glm_vec3_flipsign_to(v, dest) glm_vec3_negate_to(v, dest)
X#define glm_vec3_inv(v)               glm_vec3_negate(v)
X#define glm_vec3_inv_to(v, dest)      glm_vec3_negate_to(v, dest)
X#define glm_vec3_mulv(a, b, d)        glm_vec3_mul(a, b, d)
X
X#define GLM_VEC3_ONE_INIT   {1.0f, 1.0f, 1.0f}
X#define GLM_VEC3_ZERO_INIT  {0.0f, 0.0f, 0.0f}
X
X#define GLM_VEC3_ONE  ((vec3)GLM_VEC3_ONE_INIT)
X#define GLM_VEC3_ZERO ((vec3)GLM_VEC3_ZERO_INIT)
X
X#define GLM_YUP  ((vec3){0.0f, 1.0f, 0.0f})
X#define GLM_ZUP  ((vec3){0.0f, 0.0f, 1.0f})
X#define GLM_XUP  ((vec3){1.0f, 0.0f, 0.0f})
X
X#define GLM_XXX GLM_SHUFFLE3(0, 0, 0)
X#define GLM_YYY GLM_SHUFFLE3(1, 1, 1)
X#define GLM_ZZZ GLM_SHUFFLE3(2, 2, 2)
X#define GLM_ZYX GLM_SHUFFLE3(0, 1, 2)
X
X/*!
X * @brief init vec3 using vec4
X *
X * @param[in]  v4   vector4
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3(vec4 v4, vec3 dest) {
X  dest[0] = v4[0];
X  dest[1] = v4[1];
X  dest[2] = v4[2];
X}
X
X/*!
X * @brief copy all members of [a] to [dest]
X *
X * @param[in]  a    source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_copy(vec3 a, vec3 dest) {
X  dest[0] = a[0];
X  dest[1] = a[1];
X  dest[2] = a[2];
X}
X
X/*!
X * @brief make vector zero
X *
X * @param[in, out]  v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_zero(vec3 v) {
X  v[0] = v[1] = v[2] = 0.0f;
X}
X
X/*!
X * @brief make vector one
X *
X * @param[in, out]  v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_one(vec3 v) {
X  v[0] = v[1] = v[2] = 1.0f;
X}
X
X/*!
X * @brief vec3 dot product
X *
X * @param[in] a vector1
X * @param[in] b vector2
X *
X * @return dot product
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_dot(vec3 a, vec3 b) {
X  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
X}
X
X/*!
X * @brief norm * norm (magnitude) of vec
X *
X * we can use this func instead of calling norm * norm, because it would call
X * sqrtf fuction twice but with this func we can avoid func call, maybe this is
X * not good name for this func
X *
X * @param[in] v vector
X *
X * @return norm * norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_norm2(vec3 v) {
X  return glm_vec3_dot(v, v);
X}
X
X/*!
X * @brief euclidean norm (magnitude), also called L2 norm
X *        this will give magnitude of vector in euclidean space
X *
X * @param[in] v vector
X *
X * @return norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_norm(vec3 v) {
X  return sqrtf(glm_vec3_norm2(v));
X}
X
X/*!
X * @brief L1 norm of vec3
X * Also known as Manhattan Distance or Taxicab norm.
X * L1 Norm is the sum of the magnitudes of the vectors in a space.
X * It is calculated as the sum of the absolute values of the vector components.
X * In this norm, all the components of the vector are weighted equally.
X *
X * This computes:
X * R = |v[0]| + |v[1]| + |v[2]|
X *
X * @param[in] v vector
X *
X * @return L1 norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_norm_one(vec3 v) {
X  vec3 t;
X  glm_vec3_abs(v, t);
X  return glm_vec3_hadd(t);
X}
X
X/*!
X * @brief infinity norm of vec3
X * Also known as Maximum norm.
X * Infinity Norm is the largest magnitude among each element of a vector.
X * It is calculated as the maximum of the absolute values of the vector components.
X *
X * This computes:
X * inf norm = max(|v[0]|, |v[1]|, |v[2]|)
X *
X * @param[in] v vector
X *
X * @return infinity norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_norm_inf(vec3 v) {
X  vec3 t;
X  glm_vec3_abs(v, t);
X  return glm_vec3_max(t);
X}
X
X/*!
X * @brief add a vector to b vector store result in dest
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_add(vec3 a, vec3 b, vec3 dest) {
X  dest[0] = a[0] + b[0];
X  dest[1] = a[1] + b[1];
X  dest[2] = a[2] + b[2];
X}
X
X/*!
X * @brief add scalar to v vector store result in dest (d = v + s)
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_adds(vec3 v, float s, vec3 dest) {
X  dest[0] = v[0] + s;
X  dest[1] = v[1] + s;
X  dest[2] = v[2] + s;
X}
X
X/*!
X * @brief subtract b vector from a vector store result in dest
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_sub(vec3 a, vec3 b, vec3 dest) {
X  dest[0] = a[0] - b[0];
X  dest[1] = a[1] - b[1];
X  dest[2] = a[2] - b[2];
X}
X
X/*!
X * @brief subtract scalar from v vector store result in dest (d = v - s)
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_subs(vec3 v, float s, vec3 dest) {
X  dest[0] = v[0] - s;
X  dest[1] = v[1] - s;
X  dest[2] = v[2] - s;
X}
X
X/*!
X * @brief multiply two vector (component-wise multiplication)
X *
X * @param a    vector1
X * @param b    vector2
X * @param dest v3 = (a[0] * b[0], a[1] * b[1], a[2] * b[2])
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_mul(vec3 a, vec3 b, vec3 dest) {
X  dest[0] = a[0] * b[0];
X  dest[1] = a[1] * b[1];
X  dest[2] = a[2] * b[2];
X}
X
X/*!
X * @brief multiply/scale vec3 vector with scalar: result = v * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_scale(vec3 v, float s, vec3 dest) {
X  dest[0] = v[0] * s;
X  dest[1] = v[1] * s;
X  dest[2] = v[2] * s;
X}
X
X/*!
X * @brief make vec3 vector scale as specified: result = unit(v) * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_scale_as(vec3 v, float s, vec3 dest) {
X  float norm;
X  norm = glm_vec3_norm(v);
X
X  if (norm == 0.0f) {
X    glm_vec3_zero(dest);
X    return;
X  }
X
X  glm_vec3_scale(v, s / norm, dest);
X}
X
X/*!
X * @brief div vector with another component-wise division: d = a / b
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest result = (a[0]/b[0], a[1]/b[1], a[2]/b[2])
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_div(vec3 a, vec3 b, vec3 dest) {
X  dest[0] = a[0] / b[0];
X  dest[1] = a[1] / b[1];
X  dest[2] = a[2] / b[2];
X}
X
X/*!
X * @brief div vector with scalar: d = v / s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest result = (a[0]/s, a[1]/s, a[2]/s)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_divs(vec3 v, float s, vec3 dest) {
X  dest[0] = v[0] / s;
X  dest[1] = v[1] / s;
X  dest[2] = v[2] / s;
X}
X
X/*!
X * @brief add two vectors and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += (a + b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_addadd(vec3 a, vec3 b, vec3 dest) {
X  dest[0] += a[0] + b[0];
X  dest[1] += a[1] + b[1];
X  dest[2] += a[2] + b[2];
X}
X
X/*!
X * @brief sub two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += (a + b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_subadd(vec3 a, vec3 b, vec3 dest) {
X  dest[0] += a[0] - b[0];
X  dest[1] += a[1] - b[1];
X  dest[2] += a[2] - b[2];
X}
X
X/*!
X * @brief mul two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += (a * b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_muladd(vec3 a, vec3 b, vec3 dest) {
X  dest[0] += a[0] * b[0];
X  dest[1] += a[1] * b[1];
X  dest[2] += a[2] * b[2];
X}
X
X/*!
X * @brief mul vector with scalar and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @param[out] dest dest += (a * b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_muladds(vec3 a, float s, vec3 dest) {
X  dest[0] += a[0] * s;
X  dest[1] += a[1] * s;
X  dest[2] += a[2] * s;
X}
X
X/*!
X * @brief add max of two vector to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += max(a, b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_maxadd(vec3 a, vec3 b, vec3 dest) {
X  dest[0] += glm_max(a[0], b[0]);
X  dest[1] += glm_max(a[1], b[1]);
X  dest[2] += glm_max(a[2], b[2]);
X}
X
X/*!
X * @brief add min of two vector to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += min(a, b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_minadd(vec3 a, vec3 b, vec3 dest) {
X  dest[0] += glm_min(a[0], b[0]);
X  dest[1] += glm_min(a[1], b[1]);
X  dest[2] += glm_min(a[2], b[2]);
X}
X
X/*!
X * @brief negate vector components and store result in dest
X *
X * @param[in]   v     vector
X * @param[out]  dest  result vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_negate_to(vec3 v, vec3 dest) {
X  dest[0] = -v[0];
X  dest[1] = -v[1];
X  dest[2] = -v[2];
X}
X
X/*!
X * @brief negate vector components
X *
X * @param[in, out]  v  vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_negate(vec3 v) {
X  glm_vec3_negate_to(v, v);
X}
X
X/*!
X * @brief normalize vec3 and store result in same vec
X *
X * @param[in, out] v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_normalize(vec3 v) {
X  float norm;
X
X  norm = glm_vec3_norm(v);
X
X  if (norm == 0.0f) {
X    v[0] = v[1] = v[2] = 0.0f;
X    return;
X  }
X
X  glm_vec3_scale(v, 1.0f / norm, v);
X}
X
X/*!
X * @brief normalize vec3 to dest
X *
X * @param[in]  v    source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_normalize_to(vec3 v, vec3 dest) {
X  float norm;
X
X  norm = glm_vec3_norm(v);
X
X  if (norm == 0.0f) {
X    glm_vec3_zero(dest);
X    return;
X  }
X
X  glm_vec3_scale(v, 1.0f / norm, dest);
X}
X
X/*!
X * @brief cross product of two vector (RH)
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_cross(vec3 a, vec3 b, vec3 dest) {
X  /* (u2.v3 - u3.v2, u3.v1 - u1.v3, u1.v2 - u2.v1) */
X  dest[0] = a[1] * b[2] - a[2] * b[1];
X  dest[1] = a[2] * b[0] - a[0] * b[2];
X  dest[2] = a[0] * b[1] - a[1] * b[0];
X}
X
X/*!
X * @brief cross product of two vector (RH) and normalize the result
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_crossn(vec3 a, vec3 b, vec3 dest) {
X  glm_vec3_cross(a, b, dest);
X  glm_vec3_normalize(dest);
X}
X
X/*!
X * @brief angle betwen two vector
X *
X * @param[in] a  vector1
X * @param[in] b  vector2
X *
X * @return angle as radians
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_angle(vec3 a, vec3 b) {
X  float norm, dot;
X
X  /* maybe compiler generate approximation instruction (rcp) */
X  norm = 1.0f / (glm_vec3_norm(a) * glm_vec3_norm(b));
X  dot  = glm_vec3_dot(a, b) * norm;
X
X  if (dot > 1.0f)
X    return 0.0f;
X  else if (dot < -1.0f)
X    return CGLM_PI;
X
X  return acosf(dot);
X}
X
X/*!
X * @brief rotate vec3 around axis by angle using Rodrigues' rotation formula
X *
X * @param[in, out] v     vector
X * @param[in]      axis  axis vector (must be unit vector)
X * @param[in]      angle angle by radians
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_rotate(vec3 v, float angle, vec3 axis) {
X  vec3   v1, v2, k;
X  float  c, s;
X
X  c = cosf(angle);
X  s = sinf(angle);
X
X  glm_vec3_normalize_to(axis, k);
X
X  /* Right Hand, Rodrigues' rotation formula:
X        v = v*cos(t) + (kxv)sin(t) + k*(k.v)(1 - cos(t))
X   */
X  glm_vec3_scale(v, c, v1);
X
X  glm_vec3_cross(k, v, v2);
X  glm_vec3_scale(v2, s, v2);
X
X  glm_vec3_add(v1, v2, v1);
X
X  glm_vec3_scale(k, glm_vec3_dot(k, v) * (1.0f - c), v2);
X  glm_vec3_add(v1, v2, v);
X}
X
X/*!
X * @brief apply rotation matrix to vector
X *
X *  matrix format should be (no perspective):
X *   a  b  c  x
X *   e  f  g  y
X *   i  j  k  z
X *   0  0  0  w
X *
X * @param[in]  m    affine matrix or rot matrix
X * @param[in]  v    vector
X * @param[out] dest rotated vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_rotate_m4(mat4 m, vec3 v, vec3 dest) {
X  vec4 x, y, z, res;
X
X  glm_vec4_normalize_to(m[0], x);
X  glm_vec4_normalize_to(m[1], y);
X  glm_vec4_normalize_to(m[2], z);
X
X  glm_vec4_scale(x,   v[0], res);
X  glm_vec4_muladds(y, v[1], res);
X  glm_vec4_muladds(z, v[2], res);
X
X  glm_vec3(res, dest);
X}
X
X/*!
X * @brief apply rotation matrix to vector
X *
X * @param[in]  m    affine matrix or rot matrix
X * @param[in]  v    vector
X * @param[out] dest rotated vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_rotate_m3(mat3 m, vec3 v, vec3 dest) {
X  vec4 res, x, y, z;
X
X  glm_vec4(m[0], 0.0f, x);
X  glm_vec4(m[1], 0.0f, y);
X  glm_vec4(m[2], 0.0f, z);
X
X  glm_vec4_normalize(x);
X  glm_vec4_normalize(y);
X  glm_vec4_normalize(z);
X
X  glm_vec4_scale(x,   v[0], res);
X  glm_vec4_muladds(y, v[1], res);
X  glm_vec4_muladds(z, v[2], res);
X
X  glm_vec3(res, dest);
X}
X
X/*!
X * @brief project a vector onto b vector
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest projected vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_proj(vec3 a, vec3 b, vec3 dest) {
X  glm_vec3_scale(b,
X                 glm_vec3_dot(a, b) / glm_vec3_norm2(b),
X                 dest);
X}
X
X/**
X * @brief find center point of two vector
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest center point
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_center(vec3 a, vec3 b, vec3 dest) {
X  glm_vec3_add(a, b, dest);
X  glm_vec3_scale(dest, 0.5f, dest);
X}
X
X/**
X * @brief squared distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return returns squared distance (distance * distance)
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_distance2(vec3 a, vec3 b) {
X  return glm_pow2(a[0] - b[0])
X       + glm_pow2(a[1] - b[1])
X       + glm_pow2(a[2] - b[2]);
X}
X
X/**
X * @brief distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return returns distance
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_distance(vec3 a, vec3 b) {
X  return sqrtf(glm_vec3_distance2(a, b));
X}
X
X/*!
X * @brief max values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_maxv(vec3 a, vec3 b, vec3 dest) {
X  dest[0] = glm_max(a[0], b[0]);
X  dest[1] = glm_max(a[1], b[1]);
X  dest[2] = glm_max(a[2], b[2]);
X}
X
X/*!
X * @brief min values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_minv(vec3 a, vec3 b, vec3 dest) {
X  dest[0] = glm_min(a[0], b[0]);
X  dest[1] = glm_min(a[1], b[1]);
X  dest[2] = glm_min(a[2], b[2]);
X}
X
X/*!
X * @brief possible orthogonal/perpendicular vector
X *
X * @param[in]  v    vector
X * @param[out] dest orthogonal/perpendicular vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_ortho(vec3 v, vec3 dest) {
X  dest[0] = v[1] - v[2];
X  dest[1] = v[2] - v[0];
X  dest[2] = v[0] - v[1];
X}
X
X/*!
X * @brief clamp vector's individual members between min and max values
X *
X * @param[in, out]  v      vector
X * @param[in]       minVal minimum value
X * @param[in]       maxVal maximum value
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_clamp(vec3 v, float minVal, float maxVal) {
X  v[0] = glm_clamp(v[0], minVal, maxVal);
X  v[1] = glm_clamp(v[1], minVal, maxVal);
X  v[2] = glm_clamp(v[2], minVal, maxVal);
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount)
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_lerp(vec3 from, vec3 to, float t, vec3 dest) {
X  vec3 s, v;
X
X  /* from + s * (to - from) */
X  glm_vec3_broadcast(t, s);
X  glm_vec3_sub(to, from, v);
X  glm_vec3_mul(s, v, v);
X  glm_vec3_add(from, v, dest);
X}
X
X/*!
X * @brief linear interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount) clamped between 0 and 1
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_lerpc(vec3 from, vec3 to, float t, vec3 dest) {
X  glm_vec3_lerp(from, to, glm_clamp_zo(t), dest);
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount)
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_mix(vec3 from, vec3 to, float t, vec3 dest) {
X  glm_vec3_lerp(from, to, t, dest);
X}
X
X/*!
X * @brief linear interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount) clamped between 0 and 1
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_mixc(vec3 from, vec3 to, float t, vec3 dest) {
X  glm_vec3_lerpc(from, to, t, dest);
X}
X
X/*!
X * @brief threshold function (unidimensional)
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_step_uni(float edge, vec3 x, vec3 dest) {
X  dest[0] = glm_step(edge, x[0]);
X  dest[1] = glm_step(edge, x[1]);
X  dest[2] = glm_step(edge, x[2]);
X}
X
X/*!
X * @brief threshold function
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_step(vec3 edge, vec3 x, vec3 dest) {
X  dest[0] = glm_step(edge[0], x[0]);
X  dest[1] = glm_step(edge[1], x[1]);
X  dest[2] = glm_step(edge[2], x[2]);
X}
X
X/*!
X * @brief threshold function with a smooth transition (unidimensional)
X *
X * @param[in]   edge0   low threshold
X * @param[in]   edge1   high threshold
X * @param[in]   x       value to test against threshold
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_smoothstep_uni(float edge0, float edge1, vec3 x, vec3 dest) {
X  dest[0] = glm_smoothstep(edge0, edge1, x[0]);
X  dest[1] = glm_smoothstep(edge0, edge1, x[1]);
X  dest[2] = glm_smoothstep(edge0, edge1, x[2]);
X}
X
X/*!
X * @brief threshold function with a smooth transition
X *
X * @param[in]   edge0   low threshold
X * @param[in]   edge1   high threshold
X * @param[in]   x       value to test against threshold
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_smoothstep(vec3 edge0, vec3 edge1, vec3 x, vec3 dest) {
X  dest[0] = glm_smoothstep(edge0[0], edge1[0], x[0]);
X  dest[1] = glm_smoothstep(edge0[1], edge1[1], x[1]);
X  dest[2] = glm_smoothstep(edge0[2], edge1[2], x[2]);
X}
X
X/*!
X * @brief smooth Hermite interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount)
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_smoothinterp(vec3 from, vec3 to, float t, vec3 dest) {
X  vec3 s, v;
X    
X  /* from + s * (to - from) */
X  glm_vec3_broadcast(glm_smooth(t), s);
X  glm_vec3_sub(to, from, v);
X  glm_vec3_mul(s, v, v);
X  glm_vec3_add(from, v, dest);
X}
X
X/*!
X * @brief smooth Hermite interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount) clamped between 0 and 1
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_smoothinterpc(vec3 from, vec3 to, float t, vec3 dest) {
X  glm_vec3_smoothinterp(from, to, glm_clamp_zo(t), dest);
X}
X
X/*!
X * @brief swizzle vector components
X *
X * you can use existin masks e.g. GLM_XXX, GLM_ZYX
X *
X * @param[in]  v    source
X * @param[in]  mask mask
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_swizzle(vec3 v, int mask, vec3 dest) {
X  vec3 t;
X
X  t[0] = v[(mask & (3 << 0))];
X  t[1] = v[(mask & (3 << 2)) >> 2];
X  t[2] = v[(mask & (3 << 4)) >> 4];
X
X  glm_vec3_copy(t, dest);
X}
X
X/*!
X * @brief vec3 cross product
X *
X * this is just convenient wrapper
X *
X * @param[in]  a source 1
X * @param[in]  b source 2
X * @param[out] d destination
X */
XCGLM_INLINE
Xvoid
Xglm_cross(vec3 a, vec3 b, vec3 d) {
X  glm_vec3_cross(a, b, d);
X}
X
X/*!
X * @brief vec3 dot product
X *
X * this is just convenient wrapper
X *
X * @param[in] a vector1
X * @param[in] b vector2
X *
X * @return dot product
X */
XCGLM_INLINE
Xfloat
Xglm_dot(vec3 a, vec3 b) {
X  return glm_vec3_dot(a, b);
X}
X
X/*!
X * @brief normalize vec3 and store result in same vec
X *
X * this is just convenient wrapper
X *
X * @param[in, out] v vector
X */
XCGLM_INLINE
Xvoid
Xglm_normalize(vec3 v) {
X  glm_vec3_normalize(v);
X}
X
X/*!
X * @brief normalize vec3 to dest
X *
X * this is just convenient wrapper
X *
X * @param[in]  v    source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_normalize_to(vec3 v, vec3 dest) {
X  glm_vec3_normalize_to(v, dest);
X}
X
X#endif /* cglm_vec3_h */
76cbf42507315cc0767578bd22730a73
echo x - cglm/vec3-ext.h
sed 's/^X//' >cglm/vec3-ext.h << 'f150e4549fb643679142d1675fcb0bf9'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*!
X * @brief SIMD like functions
X */
X
X/*
X Functions:
X   CGLM_INLINE void  glm_vec3_broadcast(float val, vec3 d);
X   CGLM_INLINE void  glm_vec3_fill(vec3 v, float val);
X   CGLM_INLINE bool  glm_vec3_eq(vec3 v, float val);
X   CGLM_INLINE bool  glm_vec3_eq_eps(vec3 v, float val);
X   CGLM_INLINE bool  glm_vec3_eq_all(vec3 v);
X   CGLM_INLINE bool  glm_vec3_eqv(vec3 a, vec3 b);
X   CGLM_INLINE bool  glm_vec3_eqv_eps(vec3 a, vec3 b);
X   CGLM_INLINE float glm_vec3_max(vec3 v);
X   CGLM_INLINE float glm_vec3_min(vec3 v);
X   CGLM_INLINE bool  glm_vec3_isnan(vec3 v);
X   CGLM_INLINE bool  glm_vec3_isinf(vec3 v);
X   CGLM_INLINE bool  glm_vec3_isvalid(vec3 v);
X   CGLM_INLINE void  glm_vec3_sign(vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_abs(vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_fract(vec3 v, vec3 dest);
X   CGLM_INLINE float glm_vec3_hadd(vec3 v);
X   CGLM_INLINE void  glm_vec3_sqrt(vec3 v, vec3 dest);
X */
X
X#ifndef cglm_vec3_ext_h
X#define cglm_vec3_ext_h
X
X#include "common.h"
X#include "util.h"
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param[in]  val value
X * @param[out] d   dest
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_broadcast(float val, vec3 d) {
X  d[0] = d[1] = d[2] = val;
X}
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param[out] v   dest
X * @param[in]  val value
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_fill(vec3 v, float val) {
X  v[0] = v[1] = v[2] = val;
X}
X
X/*!
X * @brief check if vector is equal to value (without epsilon)
X *
X * @param[in] v   vector
X * @param[in] val value
X */
XCGLM_INLINE
Xbool
Xglm_vec3_eq(vec3 v, float val) {
X  return v[0] == val && v[0] == v[1] && v[0] == v[2];
X}
X
X/*!
X * @brief check if vector is equal to value (with epsilon)
X *
X * @param[in] v   vector
X * @param[in] val value
X */
XCGLM_INLINE
Xbool
Xglm_vec3_eq_eps(vec3 v, float val) {
X  return fabsf(v[0] - val) <= FLT_EPSILON
X         && fabsf(v[1] - val) <= FLT_EPSILON
X         && fabsf(v[2] - val) <= FLT_EPSILON;
X}
X
X/*!
X * @brief check if vectors members are equal (without epsilon)
X *
X * @param[in] v   vector
X */
XCGLM_INLINE
Xbool
Xglm_vec3_eq_all(vec3 v) {
X  return v[0] == v[1] && v[0] == v[2];
X}
X
X/*!
X * @brief check if vector is equal to another (without epsilon)
X *
X * @param[in] a vector
X * @param[in] b vector
X */
XCGLM_INLINE
Xbool
Xglm_vec3_eqv(vec3 a, vec3 b) {
X  return a[0] == b[0]
X         && a[1] == b[1]
X         && a[2] == b[2];
X}
X
X/*!
X * @brief check if vector is equal to another (with epsilon)
X *
X * @param[in] a vector
X * @param[in] b vector
X */
XCGLM_INLINE
Xbool
Xglm_vec3_eqv_eps(vec3 a, vec3 b) {
X  return fabsf(a[0] - b[0]) <= FLT_EPSILON
X         && fabsf(a[1] - b[1]) <= FLT_EPSILON
X         && fabsf(a[2] - b[2]) <= FLT_EPSILON;
X}
X
X/*!
X * @brief max value of vector
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_max(vec3 v) {
X  float max;
X
X  max = v[0];
X  if (v[1] > max)
X    max = v[1];
X  if (v[2] > max)
X    max = v[2];
X
X  return max;
X}
X
X/*!
X * @brief min value of vector
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_min(vec3 v) {
X  float min;
X
X  min = v[0];
X  if (v[1] < min)
X    min = v[1];
X  if (v[2] < min)
X    min = v[2];
X
X  return min;
X}
X
X/*!
X * @brief check if all items are NaN (not a number)
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglm_vec3_isnan(vec3 v) {
X  return isnan(v[0]) || isnan(v[1]) || isnan(v[2]);
X}
X
X/*!
X * @brief check if all items are INFINITY
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglm_vec3_isinf(vec3 v) {
X  return isinf(v[0]) || isinf(v[1]) || isinf(v[2]);
X}
X
X/*!
X * @brief check if all items are valid number
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglm_vec3_isvalid(vec3 v) {
X  return !glm_vec3_isnan(v) && !glm_vec3_isinf(v);
X}
X
X/*!
X * @brief get sign of 32 bit float as +1, -1, 0
X *
X * Important: It returns 0 for zero/NaN input
X *
X * @param v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_sign(vec3 v, vec3 dest) {
X  dest[0] = glm_signf(v[0]);
X  dest[1] = glm_signf(v[1]);
X  dest[2] = glm_signf(v[2]);
X}
X
X/*!
X * @brief absolute value of each vector item
X *
X * @param[in]  v    vector
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_abs(vec3 v, vec3 dest) {
X  dest[0] = fabsf(v[0]);
X  dest[1] = fabsf(v[1]);
X  dest[2] = fabsf(v[2]);
X}
X
X/*!
X * @brief fractional part of each vector item
X *
X * @param[in]  v    vector
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_fract(vec3 v, vec3 dest) {
X  dest[0] = fminf(v[0] - floorf(v[0]), 0x1.fffffep-1f);
X  dest[1] = fminf(v[1] - floorf(v[1]), 0x1.fffffep-1f);
X  dest[2] = fminf(v[2] - floorf(v[2]), 0x1.fffffep-1f);
X}
X
X/*!
X * @brief vector reduction by summation
X * @warning could overflow
X *
X * @param[in]  v    vector
X * @return     sum of all vector's elements
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_hadd(vec3 v) {
X  return v[0] + v[1] + v[2];
X}
X
X/*!
X * @brief square root of each vector item
X *
X * @param[in]  v    vector
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_sqrt(vec3 v, vec3 dest) {
X  dest[0] = sqrtf(v[0]);
X  dest[1] = sqrtf(v[1]);
X  dest[2] = sqrtf(v[2]);
X}
X
X#endif /* cglm_vec3_ext_h */
f150e4549fb643679142d1675fcb0bf9
echo x - cglm/vec4.h
sed 's/^X//' >cglm/vec4.h << '9f2417491b5e5a040ac88f1bc6f078aa'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_VEC4_ONE_INIT
X   GLM_VEC4_BLACK_INIT
X   GLM_VEC4_ZERO_INIT
X   GLM_VEC4_ONE
X   GLM_VEC4_BLACK
X   GLM_VEC4_ZERO
X
X Functions:
X   CGLM_INLINE void  glm_vec4(vec3 v3, float last, vec4 dest);
X   CGLM_INLINE void  glm_vec4_copy3(vec4 a, vec3 dest);
X   CGLM_INLINE void  glm_vec4_copy(vec4 v, vec4 dest);
X   CGLM_INLINE void  glm_vec4_ucopy(vec4 v, vec4 dest);
X   CGLM_INLINE float glm_vec4_dot(vec4 a, vec4 b);
X   CGLM_INLINE float glm_vec4_norm2(vec4 v);
X   CGLM_INLINE float glm_vec4_norm(vec4 v);
X   CGLM_INLINE float glm_vec4_norm_one(vec4 v);
X   CGLM_INLINE float glm_vec4_norm_inf(vec4 v);
X   CGLM_INLINE void  glm_vec4_add(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_adds(vec4 v, float s, vec4 dest);
X   CGLM_INLINE void  glm_vec4_sub(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_subs(vec4 v, float s, vec4 dest);
X   CGLM_INLINE void  glm_vec4_mul(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_scale(vec4 v, float s, vec4 dest);
X   CGLM_INLINE void  glm_vec4_scale_as(vec4 v, float s, vec4 dest);
X   CGLM_INLINE void  glm_vec4_div(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_divs(vec4 v, float s, vec4 dest);
X   CGLM_INLINE void  glm_vec4_addadd(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_subadd(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_muladd(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_muladds(vec4 a, float s, vec4 dest);
X   CGLM_INLINE void  glm_vec4_maxadd(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_minadd(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_negate(vec4 v);
X   CGLM_INLINE void  glm_vec4_inv(vec4 v);
X   CGLM_INLINE void  glm_vec4_inv_to(vec4 v, vec4 dest);
X   CGLM_INLINE void  glm_vec4_normalize(vec4 v);
X   CGLM_INLINE void  glm_vec4_normalize_to(vec4 vec, vec4 dest);
X   CGLM_INLINE float glm_vec4_distance(vec4 a, vec4 b);
X   CGLM_INLINE float glm_vec4_distance2(vec4 a, vec4 b);
X   CGLM_INLINE void  glm_vec4_maxv(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_minv(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_clamp(vec4 v, float minVal, float maxVal);
X   CGLM_INLINE void  glm_vec4_lerp(vec4 from, vec4 to, float t, vec4 dest);
X   CGLM_INLINE void  glm_vec4_lerpc(vec4 from, vec4 to, float t, vec4 dest);
X   CGLM_INLINE void  glm_vec4_step_uni(float edge, vec4 x, vec4 dest);
X   CGLM_INLINE void  glm_vec4_step(vec4 edge, vec4 x, vec4 dest);
X   CGLM_INLINE void  glm_vec4_smoothstep_uni(float edge0, float edge1, vec4 x, vec4 dest);
X   CGLM_INLINE void  glm_vec4_smoothstep(vec4 edge0, vec4 edge1, vec4 x, vec4 dest);
X   CGLM_INLINE void  glm_vec4_smoothinterp(vec4 from, vec4 to, float t, vec4 dest);
X   CGLM_INLINE void  glm_vec4_smoothinterpc(vec4 from, vec4 to, float t, vec4 dest);
X   CGLM_INLINE void  glm_vec4_swizzle(vec4 v, int mask, vec4 dest);
X
X DEPRECATED:
X   glm_vec4_dup
X   glm_vec4_flipsign
X   glm_vec4_flipsign_to
X   glm_vec4_inv
X   glm_vec4_inv_to
X   glm_vec4_mulv
X */
X
X#ifndef cglm_vec4_h
X#define cglm_vec4_h
X
X#include "common.h"
X#include "vec4-ext.h"
X#include "util.h"
X
X/* DEPRECATED! functions */
X#define glm_vec4_dup3(v, dest)         glm_vec4_copy3(v, dest)
X#define glm_vec4_dup(v, dest)          glm_vec4_copy(v, dest)
X#define glm_vec4_flipsign(v)           glm_vec4_negate(v)
X#define glm_vec4_flipsign_to(v, dest)  glm_vec4_negate_to(v, dest)
X#define glm_vec4_inv(v)                glm_vec4_negate(v)
X#define glm_vec4_inv_to(v, dest)       glm_vec4_negate_to(v, dest)
X#define glm_vec4_mulv(a, b, d)         glm_vec4_mul(a, b, d)
X
X#define GLM_VEC4_ONE_INIT   {1.0f, 1.0f, 1.0f, 1.0f}
X#define GLM_VEC4_BLACK_INIT {0.0f, 0.0f, 0.0f, 1.0f}
X#define GLM_VEC4_ZERO_INIT  {0.0f, 0.0f, 0.0f, 0.0f}
X
X#define GLM_VEC4_ONE        ((vec4)GLM_VEC4_ONE_INIT)
X#define GLM_VEC4_BLACK      ((vec4)GLM_VEC4_BLACK_INIT)
X#define GLM_VEC4_ZERO       ((vec4)GLM_VEC4_ZERO_INIT)
X
X#define GLM_XXXX GLM_SHUFFLE4(0, 0, 0, 0)
X#define GLM_YYYY GLM_SHUFFLE4(1, 1, 1, 1)
X#define GLM_ZZZZ GLM_SHUFFLE4(2, 2, 2, 2)
X#define GLM_WWWW GLM_SHUFFLE4(3, 3, 3, 3)
X#define GLM_WZYX GLM_SHUFFLE4(0, 1, 2, 3)
X
X/*!
X * @brief init vec4 using vec3
X *
X * @param[in]  v3   vector3
X * @param[in]  last last item
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4(vec3 v3, float last, vec4 dest) {
X  dest[0] = v3[0];
X  dest[1] = v3[1];
X  dest[2] = v3[2];
X  dest[3] = last;
X}
X
X/*!
X * @brief copy first 3 members of [a] to [dest]
X *
X * @param[in]  a    source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_copy3(vec4 a, vec3 dest) {
X  dest[0] = a[0];
X  dest[1] = a[1];
X  dest[2] = a[2];
X}
X
X/*!
X * @brief copy all members of [a] to [dest]
X *
X * @param[in]  v    source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_copy(vec4 v, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, glmm_load(v));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vld1q_f32(v));
X#else
X  dest[0] = v[0];
X  dest[1] = v[1];
X  dest[2] = v[2];
X  dest[3] = v[3];
X#endif
X}
X
X/*!
X * @brief copy all members of [a] to [dest]
X *
X * alignment is not required
X *
X * @param[in]  v    source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_ucopy(vec4 v, vec4 dest) {
X  dest[0] = v[0];
X  dest[1] = v[1];
X  dest[2] = v[2];
X  dest[3] = v[3];
X}
X
X/*!
X * @brief make vector zero
X *
X * @param[in, out]  v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_zero(vec4 v) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(v, _mm_setzero_ps());
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(v, vdupq_n_f32(0.0f));
X#else
X  v[0] = 0.0f;
X  v[1] = 0.0f;
X  v[2] = 0.0f;
X  v[3] = 0.0f;
X#endif
X}
X
X/*!
X * @brief make vector one
X *
X * @param[in, out]  v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_one(vec4 v) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(v, _mm_set1_ps(1.0f));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(v, vdupq_n_f32(1.0f));
X#else
X  v[0] = 1.0f;
X  v[1] = 1.0f;
X  v[2] = 1.0f;
X  v[3] = 1.0f;
X#endif
X}
X
X/*!
X * @brief vec4 dot product
X *
X * @param[in] a vector1
X * @param[in] b vector2
X *
X * @return dot product
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_dot(vec4 a, vec4 b) {
X#if defined(CGLM_SIMD)
X  return glmm_dot(glmm_load(a), glmm_load(b));
X#else
X  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
X#endif
X}
X
X/*!
X * @brief norm * norm (magnitude) of vec
X *
X * we can use this func instead of calling norm * norm, because it would call
X * sqrtf fuction twice but with this func we can avoid func call, maybe this is
X * not good name for this func
X *
X * @param[in] v vec4
X *
X * @return norm * norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_norm2(vec4 v) {
X  return glm_vec4_dot(v, v);
X}
X
X/*!
X * @brief euclidean norm (magnitude), also called L2 norm
X *        this will give magnitude of vector in euclidean space
X *
X * @param[in] v vector
X *
X * @return norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_norm(vec4 v) {
X#if defined(CGLM_SIMD)
X  return glmm_norm(glmm_load(v));
X#else
X  return sqrtf(glm_vec4_dot(v, v));
X#endif
X}
X
X/*!
X * @brief L1 norm of vec4
X * Also known as Manhattan Distance or Taxicab norm.
X * L1 Norm is the sum of the magnitudes of the vectors in a space.
X * It is calculated as the sum of the absolute values of the vector components.
X * In this norm, all the components of the vector are weighted equally.
X *
X * This computes:
X * L1 norm = |v[0]| + |v[1]| + |v[2]| + |v[3]|
X *
X * @param[in] v vector
X *
X * @return L1 norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_norm_one(vec4 v) {
X#if defined(CGLM_SIMD)
X  return glmm_norm_one(glmm_load(v));
X#else
X  vec4 t;
X  glm_vec4_abs(v, t);
X  return glm_vec4_hadd(t);
X#endif
X}
X
X/*!
X * @brief infinity norm of vec4
X * Also known as Maximum norm.
X * Infinity Norm is the largest magnitude among each element of a vector.
X * It is calculated as the maximum of the absolute values of the vector components.
X *
X * This computes:
X * inf norm = max(|v[0]|, |v[1]|, |v[2]|, |v[3]|)
X *
X * @param[in] v vector
X *
X * @return infinity norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_norm_inf(vec4 v) {
X#if defined(CGLM_SIMD)
X  return glmm_norm_inf(glmm_load(v));
X#else
X  vec4 t;
X  glm_vec4_abs(v, t);
X  return glm_vec4_max(t);
X#endif
X}
X
X/*!
X * @brief add b vector to a vector store result in dest
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_add(vec4 a, vec4 b, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_add_ps(glmm_load(a), glmm_load(b)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vaddq_f32(vld1q_f32(a), vld1q_f32(b)));
X#else
X  dest[0] = a[0] + b[0];
X  dest[1] = a[1] + b[1];
X  dest[2] = a[2] + b[2];
X  dest[3] = a[3] + b[3];
X#endif
X}
X
X/*!
X * @brief add scalar to v vector store result in dest (d = v + vec(s))
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_adds(vec4 v, float s, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_add_ps(glmm_load(v), _mm_set1_ps(s)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vaddq_f32(vld1q_f32(v), vdupq_n_f32(s)));
X#else
X  dest[0] = v[0] + s;
X  dest[1] = v[1] + s;
X  dest[2] = v[2] + s;
X  dest[3] = v[3] + s;
X#endif
X}
X
X/*!
X * @brief subtract b vector from a vector store result in dest (d = a - b)
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_sub(vec4 a, vec4 b, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_sub_ps(glmm_load(a), glmm_load(b)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vsubq_f32(vld1q_f32(a), vld1q_f32(b)));
X#else
X  dest[0] = a[0] - b[0];
X  dest[1] = a[1] - b[1];
X  dest[2] = a[2] - b[2];
X  dest[3] = a[3] - b[3];
X#endif
X}
X
X/*!
X * @brief subtract scalar from v vector store result in dest (d = v - vec(s))
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_subs(vec4 v, float s, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_sub_ps(glmm_load(v), _mm_set1_ps(s)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vsubq_f32(vld1q_f32(v), vdupq_n_f32(s)));
X#else
X  dest[0] = v[0] - s;
X  dest[1] = v[1] - s;
X  dest[2] = v[2] - s;
X  dest[3] = v[3] - s;
X#endif
X}
X
X/*!
X * @brief multiply two vector (component-wise multiplication)
X *
X * @param a    vector1
X * @param b    vector2
X * @param dest dest = (a[0] * b[0], a[1] * b[1], a[2] * b[2], a[3] * b[3])
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_mul(vec4 a, vec4 b, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_mul_ps(glmm_load(a), glmm_load(b)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vmulq_f32(vld1q_f32(a), vld1q_f32(b)));
X#else
X  dest[0] = a[0] * b[0];
X  dest[1] = a[1] * b[1];
X  dest[2] = a[2] * b[2];
X  dest[3] = a[3] * b[3];
X#endif
X}
X
X/*!
X * @brief multiply/scale vec4 vector with scalar: result = v * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_scale(vec4 v, float s, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_mul_ps(glmm_load(v), _mm_set1_ps(s)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vmulq_f32(vld1q_f32(v), vdupq_n_f32(s)));
X#else
X  dest[0] = v[0] * s;
X  dest[1] = v[1] * s;
X  dest[2] = v[2] * s;
X  dest[3] = v[3] * s;
X#endif
X}
X
X/*!
X * @brief make vec4 vector scale as specified: result = unit(v) * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_scale_as(vec4 v, float s, vec4 dest) {
X  float norm;
X  norm = glm_vec4_norm(v);
X
X  if (norm == 0.0f) {
X    glm_vec4_zero(dest);
X    return;
X  }
X
X  glm_vec4_scale(v, s / norm, dest);
X}
X
X/*!
X * @brief div vector with another component-wise division: d = a / b
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest result = (a[0]/b[0], a[1]/b[1], a[2]/b[2], a[3]/b[3])
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_div(vec4 a, vec4 b, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_div_ps(glmm_load(a), glmm_load(b)));
X#else
X  dest[0] = a[0] / b[0];
X  dest[1] = a[1] / b[1];
X  dest[2] = a[2] / b[2];
X  dest[3] = a[3] / b[3];
X#endif
X}
X
X/*!
X * @brief div vec4 vector with scalar: d = v / s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_divs(vec4 v, float s, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_div_ps(glmm_load(v), _mm_set1_ps(s)));
X#else
X  glm_vec4_scale(v, 1.0f / s, dest);
X#endif
X}
X
X/*!
X * @brief add two vectors and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += (a + b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_addadd(vec4 a, vec4 b, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_add_ps(glmm_load(dest),
X                              _mm_add_ps(glmm_load(a),
X                                         glmm_load(b))));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vaddq_f32(vld1q_f32(dest),
X                            vaddq_f32(vld1q_f32(a),
X                                      vld1q_f32(b))));
X#else
X  dest[0] += a[0] + b[0];
X  dest[1] += a[1] + b[1];
X  dest[2] += a[2] + b[2];
X  dest[3] += a[3] + b[3];
X#endif
X}
X
X/*!
X * @brief sub two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += (a - b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_subadd(vec4 a, vec4 b, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_add_ps(glmm_load(dest),
X                              _mm_sub_ps(glmm_load(a),
X                                         glmm_load(b))));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vaddq_f32(vld1q_f32(dest),
X                            vsubq_f32(vld1q_f32(a),
X                                      vld1q_f32(b))));
X#else
X  dest[0] += a[0] - b[0];
X  dest[1] += a[1] - b[1];
X  dest[2] += a[2] - b[2];
X  dest[3] += a[3] - b[3];
X#endif
X}
X
X/*!
X * @brief mul two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += (a * b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_muladd(vec4 a, vec4 b, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_add_ps(glmm_load(dest),
X                              _mm_mul_ps(glmm_load(a),
X                                         glmm_load(b))));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vaddq_f32(vld1q_f32(dest),
X                            vmulq_f32(vld1q_f32(a),
X                                      vld1q_f32(b))));
X#else
X  dest[0] += a[0] * b[0];
X  dest[1] += a[1] * b[1];
X  dest[2] += a[2] * b[2];
X  dest[3] += a[3] * b[3];
X#endif
X}
X
X/*!
X * @brief mul vector with scalar and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @param[out] dest dest += (a * b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_muladds(vec4 a, float s, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_add_ps(glmm_load(dest),
X                              _mm_mul_ps(glmm_load(a),
X                                         _mm_set1_ps(s))));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vaddq_f32(vld1q_f32(dest),
X                            vsubq_f32(vld1q_f32(a),
X                                      vdupq_n_f32(s))));
X#else
X  dest[0] += a[0] * s;
X  dest[1] += a[1] * s;
X  dest[2] += a[2] * s;
X  dest[3] += a[3] * s;
X#endif
X}
X
X/*!
X * @brief add max of two vector to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += max(a, b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_maxadd(vec4 a, vec4 b, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_add_ps(glmm_load(dest),
X                              _mm_max_ps(glmm_load(a),
X                                         glmm_load(b))));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vaddq_f32(vld1q_f32(dest),
X                            vmaxq_f32(vld1q_f32(a),
X                                      vld1q_f32(b))));
X#else
X  dest[0] += glm_max(a[0], b[0]);
X  dest[1] += glm_max(a[1], b[1]);
X  dest[2] += glm_max(a[2], b[2]);
X  dest[3] += glm_max(a[3], b[3]);
X#endif
X}
X
X/*!
X * @brief add min of two vector to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += min(a, b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_minadd(vec4 a, vec4 b, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_add_ps(glmm_load(dest),
X                              _mm_min_ps(glmm_load(a),
X                                         glmm_load(b))));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vaddq_f32(vld1q_f32(dest),
X                            vminq_f32(vld1q_f32(a),
X                                      vld1q_f32(b))));
X#else
X  dest[0] += glm_min(a[0], b[0]);
X  dest[1] += glm_min(a[1], b[1]);
X  dest[2] += glm_min(a[2], b[2]);
X  dest[3] += glm_min(a[3], b[3]);
X#endif
X}
X
X/*!
X * @brief negate vector components and store result in dest
X *
X * @param[in]  v     vector
X * @param[out] dest  result vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_negate_to(vec4 v, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_xor_ps(glmm_load(v), _mm_set1_ps(-0.0f)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, veorq_s32(vld1q_f32(v), vdupq_n_f32(-0.0f)));
X#else
X  dest[0] = -v[0];
X  dest[1] = -v[1];
X  dest[2] = -v[2];
X  dest[3] = -v[3];
X#endif
X}
X
X/*!
X * @brief flip sign of all vec4 members
X *
X * @param[in, out]  v  vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_negate(vec4 v) {
X  glm_vec4_negate_to(v, v);
X}
X
X/*!
X * @brief normalize vec4 to dest
X *
X * @param[in]  v    source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_normalize_to(vec4 v, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  __m128 xdot, x0;
X  float  dot;
X
X  x0   = glmm_load(v);
X  xdot = glmm_vdot(x0, x0);
X  dot  = _mm_cvtss_f32(xdot);
X
X  if (dot == 0.0f) {
X    glmm_store(dest, _mm_setzero_ps());
X    return;
X  }
X
X  glmm_store(dest, _mm_div_ps(x0, _mm_sqrt_ps(xdot)));
X#else
X  float norm;
X
X  norm = glm_vec4_norm(v);
X
X  if (norm == 0.0f) {
X    glm_vec4_zero(dest);
X    return;
X  }
X
X  glm_vec4_scale(v, 1.0f / norm, dest);
X#endif
X}
X
X/*!
X * @brief normalize vec4 and store result in same vec
X *
X * @param[in, out] v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_normalize(vec4 v) {
X  glm_vec4_normalize_to(v, v);
X}
X
X/**
X * @brief distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return returns distance
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_distance(vec4 a, vec4 b) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  return glmm_norm(_mm_sub_ps(glmm_load(a), glmm_load(b)));
X#elif defined(CGLM_NEON_FP)
X  return glmm_norm(vsubq_f32(glmm_load(a), glmm_load(b)));
X#else
X  return sqrtf(glm_pow2(a[0] - b[0])
X             + glm_pow2(a[1] - b[1])
X             + glm_pow2(a[2] - b[2])
X             + glm_pow2(a[3] - b[3]));
X#endif
X}
X
X/**
X * @brief squared distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return returns squared distance
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_distance2(vec4 a, vec4 b) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  return glmm_norm2(_mm_sub_ps(glmm_load(a), glmm_load(b)));
X#elif defined(CGLM_NEON_FP)
X  return glmm_norm2(vsubq_f32(glmm_load(a), glmm_load(b)));
X#else
X  return glm_pow2(a[0] - b[0])
X       + glm_pow2(a[1] - b[1])
X       + glm_pow2(a[2] - b[2])
X       + glm_pow2(a[3] - b[3]);
X#endif
X}
X
X/*!
X * @brief max values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_maxv(vec4 a, vec4 b, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_max_ps(glmm_load(a), glmm_load(b)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vmaxq_f32(vld1q_f32(a), vld1q_f32(b)));
X#else
X  dest[0] = glm_max(a[0], b[0]);
X  dest[1] = glm_max(a[1], b[1]);
X  dest[2] = glm_max(a[2], b[2]);
X  dest[3] = glm_max(a[3], b[3]);
X#endif
X}
X
X/*!
X * @brief min values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_minv(vec4 a, vec4 b, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_min_ps(glmm_load(a), glmm_load(b)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vminq_f32(vld1q_f32(a), vld1q_f32(b)));
X#else
X  dest[0] = glm_min(a[0], b[0]);
X  dest[1] = glm_min(a[1], b[1]);
X  dest[2] = glm_min(a[2], b[2]);
X  dest[3] = glm_min(a[3], b[3]);
X#endif
X}
X
X/*!
X * @brief clamp vector's individual members between min and max values
X *
X * @param[in, out]  v      vector
X * @param[in]       minVal minimum value
X * @param[in]       maxVal maximum value
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_clamp(vec4 v, float minVal, float maxVal) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(v, _mm_min_ps(_mm_max_ps(glmm_load(v), _mm_set1_ps(minVal)),
X                           _mm_set1_ps(maxVal)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(v, vminq_f32(vmaxq_f32(vld1q_f32(v), vdupq_n_f32(minVal)),
X                         vdupq_n_f32(maxVal)));
X#else
X  v[0] = glm_clamp(v[0], minVal, maxVal);
X  v[1] = glm_clamp(v[1], minVal, maxVal);
X  v[2] = glm_clamp(v[2], minVal, maxVal);
X  v[3] = glm_clamp(v[3], minVal, maxVal);
X#endif
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + t * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount)
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_lerp(vec4 from, vec4 to, float t, vec4 dest) {
X  vec4 s, v;
X
X  /* from + s * (to - from) */
X  glm_vec4_broadcast(t, s);
X  glm_vec4_sub(to, from, v);
X  glm_vec4_mul(s, v, v);
X  glm_vec4_add(from, v, dest);
X}
X
X/*!
X * @brief linear interpolation between two vectors (clamped)
X *
X * formula:  from + t * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount) clamped between 0 and 1
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_lerpc(vec4 from, vec4 to, float t, vec4 dest) {
X  glm_vec4_lerp(from, to, glm_clamp_zo(t), dest);
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + t * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount)
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_mix(vec4 from, vec4 to, float t, vec4 dest) {
X  glm_vec4_lerp(from, to, t, dest);
X}
X
X/*!
X * @brief linear interpolation between two vectors (clamped)
X *
X * formula:  from + t * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount) clamped between 0 and 1
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_mixc(vec4 from, vec4 to, float t, vec4 dest) {
X  glm_vec4_lerpc(from, to, t, dest);
X}
X
X/*!
X * @brief threshold function (unidimensional)
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_step_uni(float edge, vec4 x, vec4 dest) {
X  dest[0] = glm_step(edge, x[0]);
X  dest[1] = glm_step(edge, x[1]);
X  dest[2] = glm_step(edge, x[2]);
X  dest[3] = glm_step(edge, x[3]);
X}
X
X/*!
X * @brief threshold function
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_step(vec4 edge, vec4 x, vec4 dest) {
X  dest[0] = glm_step(edge[0], x[0]);
X  dest[1] = glm_step(edge[1], x[1]);
X  dest[2] = glm_step(edge[2], x[2]);
X  dest[3] = glm_step(edge[3], x[3]);
X}
X
X/*!
X * @brief threshold function with a smooth transition (unidimensional)
X *
X * @param[in]   edge0   low threshold
X * @param[in]   edge1   high threshold
X * @param[in]   x       value to test against threshold
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_smoothstep_uni(float edge0, float edge1, vec4 x, vec4 dest) {
X  dest[0] = glm_smoothstep(edge0, edge1, x[0]);
X  dest[1] = glm_smoothstep(edge0, edge1, x[1]);
X  dest[2] = glm_smoothstep(edge0, edge1, x[2]);
X  dest[3] = glm_smoothstep(edge0, edge1, x[3]);
X}
X
X/*!
X * @brief threshold function with a smooth transition
X *
X * @param[in]   edge0   low threshold
X * @param[in]   edge1   high threshold
X * @param[in]   x       value to test against threshold
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_smoothstep(vec4 edge0, vec4 edge1, vec4 x, vec4 dest) {
X  dest[0] = glm_smoothstep(edge0[0], edge1[0], x[0]);
X  dest[1] = glm_smoothstep(edge0[1], edge1[1], x[1]);
X  dest[2] = glm_smoothstep(edge0[2], edge1[2], x[2]);
X  dest[3] = glm_smoothstep(edge0[3], edge1[3], x[3]);
X}
X
X/*!
X * @brief smooth Hermite interpolation between two vectors
X *
X * formula:  t^2 * (3 - 2*t)
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   t       interpolant (amount)
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_smoothinterp(vec4 from, vec4 to, float t, vec4 dest) {
X  vec4 s, v;
X    
X  /* from + smoothstep * (to - from) */
X  glm_vec4_broadcast(glm_smooth(t), s);
X  glm_vec4_sub(to, from, v);
X  glm_vec4_mul(s, v, v);
X  glm_vec4_add(from, v, dest);
X}
X
X/*!
X * @brief smooth Hermite interpolation between two vectors (clamped)
X *
X * formula:  t^2 * (3 - 2*t)
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   t       interpolant (amount) clamped between 0 and 1
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_smoothinterpc(vec4 from, vec4 to, float t, vec4 dest) {
X  glm_vec4_smoothinterp(from, to, glm_clamp_zo(t), dest);
X}
X
X/*!
X * @brief helper to fill vec4 as [S^3, S^2, S, 1]
X *
X * @param[in]   s    parameter
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_cubic(float s, vec4 dest) {
X  float ss;
X
X  ss = s * s;
X
X  dest[0] = ss * s;
X  dest[1] = ss;
X  dest[2] = s;
X  dest[3] = 1.0f;
X}
X
X/*!
X * @brief swizzle vector components
X *
X * you can use existin masks e.g. GLM_XXXX, GLM_WZYX
X *
X * @param[in]  v    source
X * @param[in]  mask mask
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_swizzle(vec4 v, int mask, vec4 dest) {
X  vec4 t;
X
X  t[0] = v[(mask & (3 << 0))];
X  t[1] = v[(mask & (3 << 2)) >> 2];
X  t[2] = v[(mask & (3 << 4)) >> 4];
X  t[3] = v[(mask & (3 << 6)) >> 6];
X
X  glm_vec4_copy(t, dest);
X}
X
X#endif /* cglm_vec4_h */
9f2417491b5e5a040ac88f1bc6f078aa
echo x - cglm/vec4-ext.h
sed 's/^X//' >cglm/vec4-ext.h << '85518fed09ce9f135b6e077bd4b391e3'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*!
X * @brief SIMD like functions
X */
X
X/*
X Functions:
X   CGLM_INLINE void  glm_vec4_broadcast(float val, vec4 d);
X   CGLM_INLINE void  glm_vec4_fill(vec4 v, float val);
X   CGLM_INLINE bool  glm_vec4_eq(vec4 v, float val);
X   CGLM_INLINE bool  glm_vec4_eq_eps(vec4 v, float val);
X   CGLM_INLINE bool  glm_vec4_eq_all(vec4 v);
X   CGLM_INLINE bool  glm_vec4_eqv(vec4 a, vec4 b);
X   CGLM_INLINE bool  glm_vec4_eqv_eps(vec4 a, vec4 b);
X   CGLM_INLINE float glm_vec4_max(vec4 v);
X   CGLM_INLINE float glm_vec4_min(vec4 v);
X   CGLM_INLINE bool  glm_vec4_isnan(vec4 v);
X   CGLM_INLINE bool  glm_vec4_isinf(vec4 v);
X   CGLM_INLINE bool  glm_vec4_isvalid(vec4 v);
X   CGLM_INLINE void  glm_vec4_sign(vec4 v, vec4 dest);
X   CGLM_INLINE void  glm_vec4_abs(vec4 v, vec4 dest);
X   CGLM_INLINE void  glm_vec4_fract(vec4 v, vec4 dest);
X   CGLM_INLINE float glm_vec4_hadd(vec4 v);
X   CGLM_INLINE void  glm_vec4_sqrt(vec4 v, vec4 dest);
X */
X
X#ifndef cglm_vec4_ext_h
X#define cglm_vec4_ext_h
X
X#include "common.h"
X#include "vec3-ext.h"
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param val value
X * @param d   dest
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_broadcast(float val, vec4 d) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(d, _mm_set1_ps(val));
X#else
X  d[0] = d[1] = d[2] = d[3] = val;
X#endif
X}
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param v   dest
X * @param val value
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_fill(vec4 v, float val) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(v, _mm_set1_ps(val));
X#else
X  v[0] = v[1] = v[2] = v[3] = val;
X#endif
X}
X
X/*!
X * @brief check if vector is equal to value (without epsilon)
X *
X * @param v   vector
X * @param val value
X */
XCGLM_INLINE
Xbool
Xglm_vec4_eq(vec4 v, float val) {
X  return v[0] == val
X         && v[0] == v[1]
X         && v[0] == v[2]
X         && v[0] == v[3];
X}
X
X/*!
X * @brief check if vector is equal to value (with epsilon)
X *
X * @param v   vector
X * @param val value
X */
XCGLM_INLINE
Xbool
Xglm_vec4_eq_eps(vec4 v, float val) {
X  return fabsf(v[0] - val) <= FLT_EPSILON
X         && fabsf(v[1] - val) <= FLT_EPSILON
X         && fabsf(v[2] - val) <= FLT_EPSILON
X         && fabsf(v[3] - val) <= FLT_EPSILON;
X}
X
X/*!
X * @brief check if vectors members are equal (without epsilon)
X *
X * @param v   vector
X */
XCGLM_INLINE
Xbool
Xglm_vec4_eq_all(vec4 v) {
X  return v[0] == v[1]
X         && v[0] == v[2]
X         && v[0] == v[3];
X}
X
X/*!
X * @brief check if vector is equal to another (without epsilon)
X *
X * @param a vector
X * @param b vector
X */
XCGLM_INLINE
Xbool
Xglm_vec4_eqv(vec4 a, vec4 b) {
X  return a[0] == b[0]
X         && a[1] == b[1]
X         && a[2] == b[2]
X         && a[3] == b[3];
X}
X
X/*!
X * @brief check if vector is equal to another (with epsilon)
X *
X * @param a vector
X * @param b vector
X */
XCGLM_INLINE
Xbool
Xglm_vec4_eqv_eps(vec4 a, vec4 b) {
X  return fabsf(a[0] - b[0]) <= FLT_EPSILON
X         && fabsf(a[1] - b[1]) <= FLT_EPSILON
X         && fabsf(a[2] - b[2]) <= FLT_EPSILON
X         && fabsf(a[3] - b[3]) <= FLT_EPSILON;
X}
X
X/*!
X * @brief max value of vector
X *
X * @param v vector
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_max(vec4 v) {
X  float max;
X
X  max = glm_vec3_max(v);
X  if (v[3] > max)
X    max = v[3];
X
X  return max;
X}
X
X/*!
X * @brief min value of vector
X *
X * @param v vector
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_min(vec4 v) {
X  float min;
X
X  min = glm_vec3_min(v);
X  if (v[3] < min)
X    min = v[3];
X
X  return min;
X}
X
X/*!
X * @brief check if one of items is NaN (not a number)
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglm_vec4_isnan(vec4 v) {
X  return isnan(v[0]) || isnan(v[1]) || isnan(v[2]) || isnan(v[3]);
X}
X
X/*!
X * @brief check if one of items is INFINITY
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglm_vec4_isinf(vec4 v) {
X  return isinf(v[0]) || isinf(v[1]) || isinf(v[2]) || isinf(v[3]);
X}
X
X/*!
X * @brief check if all items are valid number
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglm_vec4_isvalid(vec4 v) {
X  return !glm_vec4_isnan(v) && !glm_vec4_isinf(v);
X}
X
X/*!
X * @brief get sign of 32 bit float as +1, -1, 0
X *
X * Important: It returns 0 for zero/NaN input
X *
X * @param v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_sign(vec4 v, vec4 dest) {
X#if defined( __SSE2__ ) || defined( __SSE2__ )
X  __m128 x0, x1, x2, x3, x4;
X
X  x0 = glmm_load(v);
X  x1 = _mm_set_ps(0.0f, 0.0f, 1.0f, -1.0f);
X  x2 = glmm_shuff1x(x1, 2);
X
X  x3 = _mm_and_ps(_mm_cmpgt_ps(x0, x2), glmm_shuff1x(x1, 1));
X  x4 = _mm_and_ps(_mm_cmplt_ps(x0, x2), glmm_shuff1x(x1, 0));
X
X  glmm_store(dest, _mm_or_ps(x3, x4));
X#else
X  dest[0] = glm_signf(v[0]);
X  dest[1] = glm_signf(v[1]);
X  dest[2] = glm_signf(v[2]);
X  dest[3] = glm_signf(v[3]);
X#endif
X}
X
X/*!
X * @brief absolute value of each vector item
X *
X * @param[in]  v    vector
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_abs(vec4 v, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, glmm_abs(glmm_load(v)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vabsq_f32(vld1q_f32(a)));
X#else
X  dest[0] = fabsf(v[0]);
X  dest[1] = fabsf(v[1]);
X  dest[2] = fabsf(v[2]);
X  dest[3] = fabsf(v[3]);
X#endif
X}
X
X/*!
X * @brief fractional part of each vector item
X *
X * @param[in]  v    vector
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_fract(vec4 v, vec4 dest) {
X  dest[0] = fminf(v[0] - floorf(v[0]), 0x1.fffffep-1f);
X  dest[1] = fminf(v[1] - floorf(v[1]), 0x1.fffffep-1f);
X  dest[2] = fminf(v[2] - floorf(v[2]), 0x1.fffffep-1f);
X  dest[3] = fminf(v[3] - floorf(v[3]), 0x1.fffffep-1f);
X}
X
X/*!
X * @brief vector reduction by summation
X * @warning could overflow
X *
X * @param[in]   v    vector
X * @return      sum of all vector's elements
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_hadd(vec4 v) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  return glmm_hadd(glmm_load(v));
X#else
X  return v[0] + v[1] + v[2] + v[3];
X#endif
X}
X
X/*!
X * @brief square root of each vector item
X *
X * @param[in]  v    vector
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_sqrt(vec4 v, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_sqrt_ps(glmm_load(v)));
X#else
X  dest[0] = sqrtf(v[0]);
X  dest[1] = sqrtf(v[1]);
X  dest[2] = sqrtf(v[2]);
X  dest[3] = sqrtf(v[3]);
X#endif
X}
X
X#endif /* cglm_vec4_ext_h */
85518fed09ce9f135b6e077bd4b391e3
echo x - cglm/euler.h
sed 's/^X//' >cglm/euler.h << 'df82d34723a3d343d8a8189bed7458d4'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X NOTE:
X  angles must be passed as [X-Angle, Y-Angle, Z-angle] order
X  For instance you don't pass angles as [Z-Angle, X-Angle, Y-angle] to
X  glm_euler_zxy funciton, All RELATED functions accept angles same order
X  which is [X, Y, Z].
X */
X
X/*
X Types:
X   enum glm_euler_seq
X
X Functions:
X   CGLM_INLINE glm_euler_seq glm_euler_order(int newOrder[3]);
X   CGLM_INLINE void glm_euler_angles(mat4 m, vec3 dest);
X   CGLM_INLINE void glm_euler(vec3 angles, mat4 dest);
X   CGLM_INLINE void glm_euler_xyz(vec3 angles, mat4 dest);
X   CGLM_INLINE void glm_euler_zyx(vec3 angles, mat4 dest);
X   CGLM_INLINE void glm_euler_zxy(vec3 angles, mat4 dest);
X   CGLM_INLINE void glm_euler_xzy(vec3 angles, mat4 dest);
X   CGLM_INLINE void glm_euler_yzx(vec3 angles, mat4 dest);
X   CGLM_INLINE void glm_euler_yxz(vec3 angles, mat4 dest);
X   CGLM_INLINE void glm_euler_by_order(vec3         angles,
X                                       glm_euler_seq ord,
X                                       mat4         dest);
X */
X
X#ifndef cglm_euler_h
X#define cglm_euler_h
X
X#include "common.h"
X
X/*!
X * if you have axis order like vec3 orderVec = [0, 1, 2] or [0, 2, 1]...
X * vector then you can convert it to this enum by doing this:
X * @code
X * glm_euler_seq order;
X * order = orderVec[0] | orderVec[1] << 2 | orderVec[2] << 4;
X * @endcode
X * you may need to explicit cast if required
X */
Xtypedef enum glm_euler_seq {
X  GLM_EULER_XYZ = 0 << 0 | 1 << 2 | 2 << 4,
X  GLM_EULER_XZY = 0 << 0 | 2 << 2 | 1 << 4,
X  GLM_EULER_YZX = 1 << 0 | 2 << 2 | 0 << 4,
X  GLM_EULER_YXZ = 1 << 0 | 0 << 2 | 2 << 4,
X  GLM_EULER_ZXY = 2 << 0 | 0 << 2 | 1 << 4,
X  GLM_EULER_ZYX = 2 << 0 | 1 << 2 | 0 << 4
X} glm_euler_seq;
X
Xtypedef glm_euler_seq glm_euler_sq;
X
XCGLM_INLINE
Xglm_euler_seq
Xglm_euler_order(int ord[3]) {
X  return (glm_euler_seq)(ord[0] << 0 | ord[1] << 2 | ord[2] << 4);
X}
X
X/*!
X * @brief extract euler angles (in radians) using xyz order
X *
X * @param[in]  m    affine transform
X * @param[out] dest angles vector [x, y, z]
X */
XCGLM_INLINE
Xvoid
Xglm_euler_angles(mat4 m, vec3 dest) {
X  float m00, m01, m10, m11, m20, m21, m22;
X  float thetaX, thetaY, thetaZ;
X
X  m00 = m[0][0];  m10 = m[1][0];  m20 = m[2][0];
X  m01 = m[0][1];  m11 = m[1][1];  m21 = m[2][1];
X                                  m22 = m[2][2];
X
X  if (m20 < 1.0f) {
X    if (m20 > -1.0f) {
X      thetaY = asinf(m20);
X      thetaX = atan2f(-m21, m22);
X      thetaZ = atan2f(-m10, m00);
X    } else { /* m20 == -1 */
X      /* Not a unique solution */
X      thetaY = -GLM_PI_2f;
X      thetaX = -atan2f(m01, m11);
X      thetaZ =  0.0f;
X    }
X  } else { /* m20 == +1 */
X    thetaY = GLM_PI_2f;
X    thetaX = atan2f(m01, m11);
X    thetaZ = 0.0f;
X  }
X
X  dest[0] = thetaX;
X  dest[1] = thetaY;
X  dest[2] = thetaZ;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[out] dest   rotation matrix
X */
XCGLM_INLINE
Xvoid
Xglm_euler_xyz(vec3 angles, mat4 dest) {
X  float cx, cy, cz,
X        sx, sy, sz, czsx, cxcz, sysz;
X
X  sx   = sinf(angles[0]); cx = cosf(angles[0]);
X  sy   = sinf(angles[1]); cy = cosf(angles[1]);
X  sz   = sinf(angles[2]); cz = cosf(angles[2]);
X
X  czsx = cz * sx;
X  cxcz = cx * cz;
X  sysz = sy * sz;
X
X  dest[0][0] =  cy * cz;
X  dest[0][1] =  czsx * sy + cx * sz;
X  dest[0][2] = -cxcz * sy + sx * sz;
X  dest[1][0] = -cy * sz;
X  dest[1][1] =  cxcz - sx * sysz;
X  dest[1][2] =  czsx + cx * sysz;
X  dest[2][0] =  sy;
X  dest[2][1] = -cy * sx;
X  dest[2][2] =  cx * cy;
X  dest[0][3] =  0.0f;
X  dest[1][3] =  0.0f;
X  dest[2][3] =  0.0f;
X  dest[3][0] =  0.0f;
X  dest[3][1] =  0.0f;
X  dest[3][2] =  0.0f;
X  dest[3][3] =  1.0f;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[out] dest   rotation matrix
X */
XCGLM_INLINE
Xvoid
Xglm_euler(vec3 angles, mat4 dest) {
X  glm_euler_xyz(angles, dest);
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[out] dest   rotation matrix
X */
XCGLM_INLINE
Xvoid
Xglm_euler_xzy(vec3 angles, mat4 dest) {
X  float cx, cy, cz,
X  sx, sy, sz, sxsy, cysx, cxsy, cxcy;
X
X  sx   = sinf(angles[0]); cx = cosf(angles[0]);
X  sy   = sinf(angles[1]); cy = cosf(angles[1]);
X  sz   = sinf(angles[2]); cz = cosf(angles[2]);
X
X  sxsy = sx * sy;
X  cysx = cy * sx;
X  cxsy = cx * sy;
X  cxcy = cx * cy;
X
X  dest[0][0] =  cy * cz;
X  dest[0][1] =  sxsy + cxcy * sz;
X  dest[0][2] = -cxsy + cysx * sz;
X  dest[1][0] = -sz;
X  dest[1][1] =  cx * cz;
X  dest[1][2] =  cz * sx;
X  dest[2][0] =  cz * sy;
X  dest[2][1] = -cysx + cxsy * sz;
X  dest[2][2] =  cxcy + sxsy * sz;
X  dest[0][3] =  0.0f;
X  dest[1][3] =  0.0f;
X  dest[2][3] =  0.0f;
X  dest[3][0] =  0.0f;
X  dest[3][1] =  0.0f;
X  dest[3][2] =  0.0f;
X  dest[3][3] =  1.0f;
X}
X
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[out] dest   rotation matrix
X */
XCGLM_INLINE
Xvoid
Xglm_euler_yxz(vec3 angles, mat4 dest) {
X  float cx, cy, cz,
X        sx, sy, sz, cycz, sysz, czsy, cysz;
X
X  sx   = sinf(angles[0]); cx = cosf(angles[0]);
X  sy   = sinf(angles[1]); cy = cosf(angles[1]);
X  sz   = sinf(angles[2]); cz = cosf(angles[2]);
X
X  cycz = cy * cz;
X  sysz = sy * sz;
X  czsy = cz * sy;
X  cysz = cy * sz;
X
X  dest[0][0] =  cycz + sx * sysz;
X  dest[0][1] =  cx * sz;
X  dest[0][2] = -czsy + cysz * sx;
X  dest[1][0] = -cysz + czsy * sx;
X  dest[1][1] =  cx * cz;
X  dest[1][2] =  cycz * sx + sysz;
X  dest[2][0] =  cx * sy;
X  dest[2][1] = -sx;
X  dest[2][2] =  cx * cy;
X  dest[0][3] =  0.0f;
X  dest[1][3] =  0.0f;
X  dest[2][3] =  0.0f;
X  dest[3][0] =  0.0f;
X  dest[3][1] =  0.0f;
X  dest[3][2] =  0.0f;
X  dest[3][3] =  1.0f;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[out] dest   rotation matrix
X */
XCGLM_INLINE
Xvoid
Xglm_euler_yzx(vec3 angles, mat4 dest) {
X  float cx, cy, cz,
X        sx, sy, sz, sxsy, cxcy, cysx, cxsy;
X
X  sx   = sinf(angles[0]); cx = cosf(angles[0]);
X  sy   = sinf(angles[1]); cy = cosf(angles[1]);
X  sz   = sinf(angles[2]); cz = cosf(angles[2]);
X
X  sxsy = sx * sy;
X  cxcy = cx * cy;
X  cysx = cy * sx;
X  cxsy = cx * sy;
X
X  dest[0][0] =  cy * cz;
X  dest[0][1] =  sz;
X  dest[0][2] = -cz * sy;
X  dest[1][0] =  sxsy - cxcy * sz;
X  dest[1][1] =  cx * cz;
X  dest[1][2] =  cysx + cxsy * sz;
X  dest[2][0] =  cxsy + cysx * sz;
X  dest[2][1] = -cz * sx;
X  dest[2][2] =  cxcy - sxsy * sz;
X  dest[0][3] =  0.0f;
X  dest[1][3] =  0.0f;
X  dest[2][3] =  0.0f;
X  dest[3][0] =  0.0f;
X  dest[3][1] =  0.0f;
X  dest[3][2] =  0.0f;
X  dest[3][3] =  1.0f;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[out] dest   rotation matrix
X */
XCGLM_INLINE
Xvoid
Xglm_euler_zxy(vec3 angles, mat4 dest) {
X  float cx, cy, cz,
X        sx, sy, sz, cycz, sxsy, cysz;
X
X  sx   = sinf(angles[0]); cx = cosf(angles[0]);
X  sy   = sinf(angles[1]); cy = cosf(angles[1]);
X  sz   = sinf(angles[2]); cz = cosf(angles[2]);
X
X  cycz = cy * cz;
X  sxsy = sx * sy;
X  cysz = cy * sz;
X
X  dest[0][0] =  cycz - sxsy * sz;
X  dest[0][1] =  cz * sxsy + cysz;
X  dest[0][2] = -cx * sy;
X  dest[1][0] = -cx * sz;
X  dest[1][1] =  cx * cz;
X  dest[1][2] =  sx;
X  dest[2][0] =  cz * sy + cysz * sx;
X  dest[2][1] = -cycz * sx + sy * sz;
X  dest[2][2] =  cx * cy;
X  dest[0][3] =  0.0f;
X  dest[1][3] =  0.0f;
X  dest[2][3] =  0.0f;
X  dest[3][0] =  0.0f;
X  dest[3][1] =  0.0f;
X  dest[3][2] =  0.0f;
X  dest[3][3] =  1.0f;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[out] dest   rotation matrix
X */
XCGLM_INLINE
Xvoid
Xglm_euler_zyx(vec3 angles, mat4 dest) {
X  float cx, cy, cz,
X        sx, sy, sz, czsx, cxcz, sysz;
X
X  sx   = sinf(angles[0]); cx = cosf(angles[0]);
X  sy   = sinf(angles[1]); cy = cosf(angles[1]);
X  sz   = sinf(angles[2]); cz = cosf(angles[2]);
X
X  czsx = cz * sx;
X  cxcz = cx * cz;
X  sysz = sy * sz;
X
X  dest[0][0] =  cy * cz;
X  dest[0][1] =  cy * sz;
X  dest[0][2] = -sy;
X  dest[1][0] =  czsx * sy - cx * sz;
X  dest[1][1] =  cxcz + sx * sysz;
X  dest[1][2] =  cy * sx;
X  dest[2][0] =  cxcz * sy + sx * sz;
X  dest[2][1] = -czsx + cx * sysz;
X  dest[2][2] =  cx * cy;
X  dest[0][3] =  0.0f;
X  dest[1][3] =  0.0f;
X  dest[2][3] =  0.0f;
X  dest[3][0] =  0.0f;
X  dest[3][1] =  0.0f;
X  dest[3][2] =  0.0f;
X  dest[3][3] =  1.0f;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[in]  ord    euler order
X * @param[out] dest   rotation matrix
X */
XCGLM_INLINE
Xvoid
Xglm_euler_by_order(vec3 angles, glm_euler_seq ord, mat4 dest) {
X  float cx, cy, cz,
X        sx, sy, sz;
X
X  float cycz, cysz, cysx, cxcy,
X        czsy, cxcz, czsx, cxsz,
X        sysz;
X
X  sx = sinf(angles[0]); cx = cosf(angles[0]);
X  sy = sinf(angles[1]); cy = cosf(angles[1]);
X  sz = sinf(angles[2]); cz = cosf(angles[2]);
X
X  cycz = cy * cz; cysz = cy * sz;
X  cysx = cy * sx; cxcy = cx * cy;
X  czsy = cz * sy; cxcz = cx * cz;
X  czsx = cz * sx; cxsz = cx * sz;
X  sysz = sy * sz;
X
X  switch (ord) {
X    case GLM_EULER_XZY:
X      dest[0][0] =  cycz;
X      dest[0][1] =  sx * sy + cx * cysz;
X      dest[0][2] = -cx * sy + cysx * sz;
X      dest[1][0] = -sz;
X      dest[1][1] =  cxcz;
X      dest[1][2] =  czsx;
X      dest[2][0] =  czsy;
X      dest[2][1] = -cysx + cx * sysz;
X      dest[2][2] =  cxcy + sx * sysz;
X      break;
X    case GLM_EULER_XYZ:
X      dest[0][0] =  cycz;
X      dest[0][1] =  czsx * sy + cxsz;
X      dest[0][2] = -cx * czsy + sx * sz;
X      dest[1][0] = -cysz;
X      dest[1][1] =  cxcz - sx * sysz;
X      dest[1][2] =  czsx + cx * sysz;
X      dest[2][0] =  sy;
X      dest[2][1] = -cysx;
X      dest[2][2] =  cxcy;
X      break;
X    case GLM_EULER_YXZ:
X      dest[0][0] =  cycz + sx * sysz;
X      dest[0][1] =  cxsz;
X      dest[0][2] = -czsy + cysx * sz;
X      dest[1][0] =  czsx * sy - cysz;
X      dest[1][1] =  cxcz;
X      dest[1][2] =  cycz * sx + sysz;
X      dest[2][0] =  cx * sy;
X      dest[2][1] = -sx;
X      dest[2][2] =  cxcy;
X      break;
X    case GLM_EULER_YZX:
X      dest[0][0] =  cycz;
X      dest[0][1] =  sz;
X      dest[0][2] = -czsy;
X      dest[1][0] =  sx * sy - cx * cysz;
X      dest[1][1] =  cxcz;
X      dest[1][2] =  cysx + cx * sysz;
X      dest[2][0] =  cx * sy + cysx * sz;
X      dest[2][1] = -czsx;
X      dest[2][2] =  cxcy - sx * sysz;
X      break;
X    case GLM_EULER_ZXY:
X      dest[0][0] =  cycz - sx * sysz;
X      dest[0][1] =  czsx * sy + cysz;
X      dest[0][2] = -cx * sy;
X      dest[1][0] = -cxsz;
X      dest[1][1] =  cxcz;
X      dest[1][2] =  sx;
X      dest[2][0] =  czsy + cysx * sz;
X      dest[2][1] = -cycz * sx + sysz;
X      dest[2][2] =  cxcy;
X      break;
X    case GLM_EULER_ZYX:
X      dest[0][0] =  cycz;
X      dest[0][1] =  cysz;
X      dest[0][2] = -sy;
X      dest[1][0] =  czsx * sy - cxsz;
X      dest[1][1] =  cxcz + sx * sysz;
X      dest[1][2] =  cysx;
X      dest[2][0] =  cx * czsy + sx * sz;
X      dest[2][1] = -czsx + cx * sysz;
X      dest[2][2] =  cxcy;
X      break;
X  }
X
X  dest[0][3] = 0.0f;
X  dest[1][3] = 0.0f;
X  dest[2][3] = 0.0f;
X  dest[3][0] = 0.0f;
X  dest[3][1] = 0.0f;
X  dest[3][2] = 0.0f;
X  dest[3][3] = 1.0f;
X}
X
X#endif /* cglm_euler_h */
df82d34723a3d343d8a8189bed7458d4
echo x - cglm/util.h
sed 's/^X//' >cglm/util.h << 'd9a360d2017c6e6ea4b74e6a1ad64a86'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE int   glm_sign(int val);
X   CGLM_INLINE float glm_signf(float val);
X   CGLM_INLINE float glm_rad(float deg);
X   CGLM_INLINE float glm_deg(float rad);
X   CGLM_INLINE void  glm_make_rad(float *deg);
X   CGLM_INLINE void  glm_make_deg(float *rad);
X   CGLM_INLINE float glm_pow2(float x);
X   CGLM_INLINE float glm_min(float a, float b);
X   CGLM_INLINE float glm_max(float a, float b);
X   CGLM_INLINE float glm_clamp(float val, float minVal, float maxVal);
X   CGLM_INLINE float glm_clamp_zo(float val, float minVal, float maxVal);
X   CGLM_INLINE float glm_lerp(float from, float to, float t);
X   CGLM_INLINE float glm_lerpc(float from, float to, float t);
X   CGLM_INLINE float glm_step(float edge, float x);
X   CGLM_INLINE float glm_smooth(float t);
X   CGLM_INLINE float glm_smoothstep(float edge0, float edge1, float x);
X   CGLM_INLINE float glm_smoothinterp(float from, float to, float t);
X   CGLM_INLINE float glm_smoothinterpc(float from, float to, float t);
X   CGLM_INLINE bool  glm_eq(float a, float b);
X   CGLM_INLINE float glm_percent(float from, float to, float current);
X   CGLM_INLINE float glm_percentc(float from, float to, float current);
X */
X
X#ifndef cglm_util_h
X#define cglm_util_h
X
X#include "common.h"
X
X#define GLM_MIN(X, Y) (((X) < (Y)) ? (X) : (Y))
X#define GLM_MAX(X, Y) (((X) > (Y)) ? (X) : (Y))
X
X/*!
X * @brief get sign of 32 bit integer as +1, -1, 0
X *
X * Important: It returns 0 for zero input
X *
X * @param val integer value
X */
XCGLM_INLINE
Xint
Xglm_sign(int val) {
X  return ((val >> 31) - (-val >> 31));
X}
X
X/*!
X * @brief get sign of 32 bit float as +1, -1, 0
X *
X * Important: It returns 0 for zero/NaN input
X *
X * @param val float value
X */
XCGLM_INLINE
Xfloat
Xglm_signf(float val) {
X  return (float)((val > 0.0f) - (val < 0.0f));
X}
X
X/*!
X * @brief convert degree to radians
X *
X * @param[in] deg angle in degrees
X */
XCGLM_INLINE
Xfloat
Xglm_rad(float deg) {
X  return deg * GLM_PIf / 180.0f;
X}
X
X/*!
X * @brief convert radians to degree
X *
X * @param[in] rad angle in radians
X */
XCGLM_INLINE
Xfloat
Xglm_deg(float rad) {
X  return rad * 180.0f / GLM_PIf;
X}
X
X/*!
X * @brief convert exsisting degree to radians. this will override degrees value
X *
X * @param[in, out] deg pointer to angle in degrees
X */
XCGLM_INLINE
Xvoid
Xglm_make_rad(float *deg) {
X  *deg = *deg * GLM_PIf / 180.0f;
X}
X
X/*!
X * @brief convert exsisting radians to degree. this will override radians value
X *
X * @param[in, out] rad pointer to angle in radians
X */
XCGLM_INLINE
Xvoid
Xglm_make_deg(float *rad) {
X  *rad = *rad * 180.0f / GLM_PIf;
X}
X
X/*!
X * @brief multiplies given parameter with itself = x * x or powf(x, 2)
X *
X * @param[in] x x
X */
XCGLM_INLINE
Xfloat
Xglm_pow2(float x) {
X  return x * x;
X}
X
X/*!
X * @brief find minimum of given two values
X *
X * @param[in] a number 1
X * @param[in] b number 2
X */
XCGLM_INLINE
Xfloat
Xglm_min(float a, float b) {
X  if (a < b)
X    return a;
X  return b;
X}
X
X/*!
X * @brief find maximum of given two values
X *
X * @param[in] a number 1
X * @param[in] b number 2
X */
XCGLM_INLINE
Xfloat
Xglm_max(float a, float b) {
X  if (a > b)
X    return a;
X  return b;
X}
X
X/*!
X * @brief clamp a number between min and max
X *
X * @param[in] val    value to clamp
X * @param[in] minVal minimum value
X * @param[in] maxVal maximum value
X */
XCGLM_INLINE
Xfloat
Xglm_clamp(float val, float minVal, float maxVal) {
X  return glm_min(glm_max(val, minVal), maxVal);
X}
X
X/*!
X * @brief clamp a number to zero and one
X *
X * @param[in] val value to clamp
X */
XCGLM_INLINE
Xfloat
Xglm_clamp_zo(float val) {
X  return glm_clamp(val, 0.0f, 1.0f);
X}
X
X/*!
X * @brief linear interpolation between two numbers
X *
X * formula:  from + t * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount)
X */
XCGLM_INLINE
Xfloat
Xglm_lerp(float from, float to, float t) {
X  return from + t * (to - from);
X}
X
X/*!
X * @brief clamped linear interpolation between two numbers
X *
X * formula:  from + t * (to - from)
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   t       interpolant (amount) clamped between 0 and 1
X */
XCGLM_INLINE
Xfloat
Xglm_lerpc(float from, float to, float t) {
X  return glm_lerp(from, to, glm_clamp_zo(t));
X}
X
X/*!
X * @brief threshold function
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @return      returns 0.0 if x < edge, else 1.0
X */
XCGLM_INLINE
Xfloat
Xglm_step(float edge, float x) {
X  /* branching - no type conversion */
X  return (x < edge) ? 0.0f : 1.0f;
X  /*
X   * An alternative implementation without branching
X   * but with type conversion could be:
X   * return !(x < edge);
X   */
X}
X
X/*!
X * @brief smooth Hermite interpolation
X *
X * formula:  t^2 * (3-2t)
X *
X * @param[in]   t    interpolant (amount)
X */
XCGLM_INLINE
Xfloat
Xglm_smooth(float t) {
X  return t * t * (3.0f - 2.0f * t);
X}
X
X/*!
X * @brief threshold function with a smooth transition (according to OpenCL specs)
X *
X * formula:  t^2 * (3-2t)
X *
X * @param[in]   edge0 low threshold
X * @param[in]   edge1 high threshold
X * @param[in]   x     interpolant (amount)
X */
XCGLM_INLINE
Xfloat
Xglm_smoothstep(float edge0, float edge1, float x) {
X  float t;
X  t = glm_clamp_zo((x - edge0) / (edge1 - edge0));
X  return glm_smooth(t);
X}
X
X/*!
X * @brief smoothstep interpolation between two numbers
X *
X * formula:  from + smoothstep(t) * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount)
X */
XCGLM_INLINE
Xfloat
Xglm_smoothinterp(float from, float to, float t) {
X  return from + glm_smooth(t) * (to - from);
X}
X
X/*!
X * @brief clamped smoothstep interpolation between two numbers
X *
X * formula:  from + smoothstep(t) * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount) clamped between 0 and 1
X */
XCGLM_INLINE
Xfloat
Xglm_smoothinterpc(float from, float to, float t) {
X  return glm_smoothinterp(from, to, glm_clamp_zo(t));
X}
X
X/*!
X * @brief check if two float equal with using EPSILON
X *
X * @param[in]   a   a
X * @param[in]   b   b
X */
XCGLM_INLINE
Xbool
Xglm_eq(float a, float b) {
X  return fabsf(a - b) <= FLT_EPSILON;
X}
X
X/*!
X * @brief percentage of current value between start and end value
X *
X * maybe fraction could be alternative name.
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   current current value
X */
XCGLM_INLINE
Xfloat
Xglm_percent(float from, float to, float current) {
X  float t;
X
X  if ((t = to - from) == 0.0f)
X    return 1.0f;
X
X  return (current - from) / t;
X}
X
X/*!
X * @brief clamped percentage of current value between start and end value
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   current current value
X */
XCGLM_INLINE
Xfloat
Xglm_percentc(float from, float to, float current) {
X  return glm_clamp(glm_percent(from, to, current), 0.0f, 1.0f);
X}
X
X#endif /* cglm_util_h */
d9a360d2017c6e6ea4b74e6a1ad64a86
echo x - cglm/quat.h
sed 's/^X//' >cglm/quat.h << '04c24ba264492706af55aaf3fb20addf'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_QUAT_IDENTITY_INIT
X   GLM_QUAT_IDENTITY
X
X Functions:
X   CGLM_INLINE void glm_quat_identity(versor q);
X   CGLM_INLINE void glm_quat_init(versor q, float x, float y, float z, float w);
X   CGLM_INLINE void glm_quat(versor q, float angle, float x, float y, float z);
X   CGLM_INLINE void glm_quatv(versor q, float angle, vec3 axis);
X   CGLM_INLINE void glm_quat_copy(versor q, versor dest);
X   CGLM_INLINE float glm_quat_norm(versor q);
X   CGLM_INLINE void glm_quat_normalize(versor q);
X   CGLM_INLINE void glm_quat_normalize_to(versor q, versor dest);
X   CGLM_INLINE float glm_quat_dot(versor p, versor q);
X   CGLM_INLINE void glm_quat_conjugate(versor q, versor dest);
X   CGLM_INLINE void glm_quat_inv(versor q, versor dest);
X   CGLM_INLINE void glm_quat_add(versor p, versor q, versor dest);
X   CGLM_INLINE void glm_quat_sub(versor p, versor q, versor dest);
X   CGLM_INLINE float glm_quat_real(versor q);
X   CGLM_INLINE void glm_quat_imag(versor q, vec3 dest);
X   CGLM_INLINE void glm_quat_imagn(versor q, vec3 dest);
X   CGLM_INLINE float glm_quat_imaglen(versor q);
X   CGLM_INLINE float glm_quat_angle(versor q);
X   CGLM_INLINE void glm_quat_axis(versor q, vec3 dest);
X   CGLM_INLINE void glm_quat_mul(versor p, versor q, versor dest);
X   CGLM_INLINE void glm_quat_mat4(versor q, mat4 dest);
X   CGLM_INLINE void glm_quat_mat4t(versor q, mat4 dest);
X   CGLM_INLINE void glm_quat_mat3(versor q, mat3 dest);
X   CGLM_INLINE void glm_quat_mat3t(versor q, mat3 dest);
X   CGLM_INLINE void glm_quat_lerp(versor from, versor to, float t, versor dest);
X   CGLM_INLINE void glm_quat_lerpc(versor from, versor to, float t, versor dest);
X   CGLM_INLINE void glm_quat_slerp(versor q, versor r, float t, versor dest);
X   CGLM_INLINE void glm_quat_look(vec3 eye, versor ori, mat4 dest);
X   CGLM_INLINE void glm_quat_for(vec3 dir, vec3 fwd, vec3 up, versor dest);
X   CGLM_INLINE void glm_quat_forp(vec3 from,
X                                  vec3 to,
X                                  vec3 fwd,
X                                  vec3 up,
X                                  versor dest);
X   CGLM_INLINE void glm_quat_rotatev(versor q, vec3 v, vec3 dest);
X   CGLM_INLINE void glm_quat_rotate(mat4 m, versor q, mat4 dest);
X */
X
X#ifndef cglm_quat_h
X#define cglm_quat_h
X
X#include "common.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X#include "mat3.h"
X#include "affine-mat.h"
X
X#ifdef CGLM_SSE_FP
X#  include "simd/sse2/quat.h"
X#endif
X
XCGLM_INLINE
Xvoid
Xglm_mat4_identity(mat4 mat);
X
XCGLM_INLINE
Xvoid
Xglm_mat4_mulv(mat4 m, vec4 v, vec4 dest);
X
XCGLM_INLINE
Xvoid
Xglm_mul_rot(mat4 m1, mat4 m2, mat4 dest);
X
XCGLM_INLINE
Xvoid
Xglm_translate(mat4 m, vec3 v);
X
X/*
X * IMPORTANT:
X * ----------------------------------------------------------------------------
X * cglm stores quat as [x, y, z, w] since v0.3.6
X *
X * it was [w, x, y, z] before v0.3.6 it has been changed to [x, y, z, w]
X * with v0.3.6 version.
X * ----------------------------------------------------------------------------
X */
X
X#define GLM_QUAT_IDENTITY_INIT  {0.0f, 0.0f, 0.0f, 1.0f}
X#define GLM_QUAT_IDENTITY       ((versor)GLM_QUAT_IDENTITY_INIT)
X
X/*!
X * @brief makes given quat to identity
X *
X * @param[in, out]  q  quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_identity(versor q) {
X  CGLM_ALIGN(16) versor v = GLM_QUAT_IDENTITY_INIT;
X  glm_vec4_copy(v, q);
X}
X
X/*!
X * @brief make given quaternion array's each element identity quaternion
X *
X * @param[in, out]  q     quat array (must be aligned (16)
X *                        if alignment is not disabled)
X *
X * @param[in]       count count of quaternions
X */
XCGLM_INLINE
Xvoid
Xglm_quat_identity_array(versor * __restrict q, size_t count) {
X  CGLM_ALIGN(16) versor v = GLM_QUAT_IDENTITY_INIT;
X  size_t i;
X
X  for (i = 0; i < count; i++) {
X    glm_vec4_copy(v, q[i]);
X  }
X}
X
X/*!
X * @brief inits quaterion with raw values
X *
X * @param[out]  q     quaternion
X * @param[in]   x     x
X * @param[in]   y     y
X * @param[in]   z     z
X * @param[in]   w     w (real part)
X */
XCGLM_INLINE
Xvoid
Xglm_quat_init(versor q, float x, float y, float z, float w) {
X  q[0] = x;
X  q[1] = y;
X  q[2] = z;
X  q[3] = w;
X}
X
X/*!
X * @brief creates NEW quaternion with axis vector
X *
X * @param[out]  q     quaternion
X * @param[in]   angle angle (radians)
X * @param[in]   axis  axis
X */
XCGLM_INLINE
Xvoid
Xglm_quatv(versor q, float angle, vec3 axis) {
X  CGLM_ALIGN(8) vec3 k;
X  float a, c, s;
X
X  a = angle * 0.5f;
X  c = cosf(a);
X  s = sinf(a);
X
X  glm_normalize_to(axis, k);
X
X  q[0] = s * k[0];
X  q[1] = s * k[1];
X  q[2] = s * k[2];
X  q[3] = c;
X}
X
X/*!
X * @brief creates NEW quaternion with individual axis components
X *
X * @param[out]  q     quaternion
X * @param[in]   angle angle (radians)
X * @param[in]   x     axis.x
X * @param[in]   y     axis.y
X * @param[in]   z     axis.z
X */
XCGLM_INLINE
Xvoid
Xglm_quat(versor q, float angle, float x, float y, float z) {
X  CGLM_ALIGN(8) vec3 axis = {x, y, z};
X  glm_quatv(q, angle, axis);
X}
X
X/*!
X * @brief copy quaternion to another one
X *
X * @param[in]  q     quaternion
X * @param[out] dest  destination
X */
XCGLM_INLINE
Xvoid
Xglm_quat_copy(versor q, versor dest) {
X  glm_vec4_copy(q, dest);
X}
X
X/*!
X * @brief returns norm (magnitude) of quaternion
X *
X * @param[out]  q  quaternion
X */
XCGLM_INLINE
Xfloat
Xglm_quat_norm(versor q) {
X  return glm_vec4_norm(q);
X}
X
X/*!
X * @brief normalize quaternion and store result in dest
X *
X * @param[in]   q     quaternion to normalze
X * @param[out]  dest  destination quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_normalize_to(versor q, versor dest) {
X#if defined( __SSE2__ ) || defined( __SSE2__ )
X  __m128 xdot, x0;
X  float  dot;
X
X  x0   = glmm_load(q);
X  xdot = glmm_vdot(x0, x0);
X  dot  = _mm_cvtss_f32(xdot);
X
X  if (dot <= 0.0f) {
X    glm_quat_identity(dest);
X    return;
X  }
X
X  glmm_store(dest, _mm_div_ps(x0, _mm_sqrt_ps(xdot)));
X#else
X  float dot;
X
X  dot = glm_vec4_norm2(q);
X
X  if (dot <= 0.0f) {
X    glm_quat_identity(dest);
X    return;
X  }
X
X  glm_vec4_scale(q, 1.0f / sqrtf(dot), dest);
X#endif
X}
X
X/*!
X * @brief normalize quaternion
X *
X * @param[in, out]  q  quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_normalize(versor q) {
X  glm_quat_normalize_to(q, q);
X}
X
X/*!
X * @brief dot product of two quaternion
X *
X * @param[in]  p  quaternion 1
X * @param[in]  q  quaternion 2
X */
XCGLM_INLINE
Xfloat
Xglm_quat_dot(versor p, versor q) {
X  return glm_vec4_dot(p, q);
X}
X
X/*!
X * @brief conjugate of quaternion
X *
X * @param[in]   q     quaternion
X * @param[out]  dest  conjugate
X */
XCGLM_INLINE
Xvoid
Xglm_quat_conjugate(versor q, versor dest) {
X  glm_vec4_negate_to(q, dest);
X  dest[3] = -dest[3];
X}
X
X/*!
X * @brief inverse of non-zero quaternion
X *
X * @param[in]   q    quaternion
X * @param[out]  dest inverse quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_inv(versor q, versor dest) {
X  CGLM_ALIGN(16) versor conj;
X  glm_quat_conjugate(q, conj);
X  glm_vec4_scale(conj, 1.0f / glm_vec4_norm2(q), dest);
X}
X
X/*!
X * @brief add (componentwise) two quaternions and store result in dest
X *
X * @param[in]   p    quaternion 1
X * @param[in]   q    quaternion 2
X * @param[out]  dest result quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_add(versor p, versor q, versor dest) {
X  glm_vec4_add(p, q, dest);
X}
X
X/*!
X * @brief subtract (componentwise) two quaternions and store result in dest
X *
X * @param[in]   p    quaternion 1
X * @param[in]   q    quaternion 2
X * @param[out]  dest result quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_sub(versor p, versor q, versor dest) {
X  glm_vec4_sub(p, q, dest);
X}
X
X/*!
X * @brief returns real part of quaternion
X *
X * @param[in]   q    quaternion
X */
XCGLM_INLINE
Xfloat
Xglm_quat_real(versor q) {
X  return q[3];
X}
X
X/*!
X * @brief returns imaginary part of quaternion
X *
X * @param[in]   q    quaternion
X * @param[out]  dest imag
X */
XCGLM_INLINE
Xvoid
Xglm_quat_imag(versor q, vec3 dest) {
X  dest[0] = q[0];
X  dest[1] = q[1];
X  dest[2] = q[2];
X}
X
X/*!
X * @brief returns normalized imaginary part of quaternion
X *
X * @param[in]   q    quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_imagn(versor q, vec3 dest) {
X  glm_normalize_to(q, dest);
X}
X
X/*!
X * @brief returns length of imaginary part of quaternion
X *
X * @param[in]   q    quaternion
X */
XCGLM_INLINE
Xfloat
Xglm_quat_imaglen(versor q) {
X  return glm_vec3_norm(q);
X}
X
X/*!
X * @brief returns angle of quaternion
X *
X * @param[in]   q    quaternion
X */
XCGLM_INLINE
Xfloat
Xglm_quat_angle(versor q) {
X  /*
X   sin(theta / 2) = length(x*x + y*y + z*z)
X   cos(theta / 2) = w
X   theta          = 2 * atan(sin(theta / 2) / cos(theta / 2))
X   */
X  return 2.0f * atan2f(glm_quat_imaglen(q), glm_quat_real(q));
X}
X
X/*!
X * @brief axis of quaternion
X *
X * @param[in]   q    quaternion
X * @param[out]  dest axis of quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_axis(versor q, vec3 dest) {
X  glm_quat_imagn(q, dest);
X}
X
X/*!
X * @brief multiplies two quaternion and stores result in dest
X *        this is also called Hamilton Product
X *
X * According to WikiPedia:
X * The product of two rotation quaternions [clarification needed] will be
X * equivalent to the rotation q followed by the rotation p
X *
X * @param[in]   p     quaternion 1
X * @param[in]   q     quaternion 2
X * @param[out]  dest  result quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_mul(versor p, versor q, versor dest) {
X  /*
X    + (a1 b2 + b1 a2 + c1 d2 − d1 c2)i
X    + (a1 c2 − b1 d2 + c1 a2 + d1 b2)j
X    + (a1 d2 + b1 c2 − c1 b2 + d1 a2)k
X       a1 a2 − b1 b2 − c1 c2 − d1 d2
X   */
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glm_quat_mul_sse2(p, q, dest);
X#else
X  dest[0] = p[3] * q[0] + p[0] * q[3] + p[1] * q[2] - p[2] * q[1];
X  dest[1] = p[3] * q[1] - p[0] * q[2] + p[1] * q[3] + p[2] * q[0];
X  dest[2] = p[3] * q[2] + p[0] * q[1] - p[1] * q[0] + p[2] * q[3];
X  dest[3] = p[3] * q[3] - p[0] * q[0] - p[1] * q[1] - p[2] * q[2];
X#endif
X}
X
X/*!
X * @brief convert quaternion to mat4
X *
X * @param[in]   q     quaternion
X * @param[out]  dest  result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_quat_mat4(versor q, mat4 dest) {
X  float w, x, y, z,
X        xx, yy, zz,
X        xy, yz, xz,
X        wx, wy, wz, norm, s;
X
X  norm = glm_quat_norm(q);
X  s    = norm > 0.0f ? 2.0f / norm : 0.0f;
X
X  x = q[0];
X  y = q[1];
X  z = q[2];
X  w = q[3];
X
X  xx = s * x * x;   xy = s * x * y;   wx = s * w * x;
X  yy = s * y * y;   yz = s * y * z;   wy = s * w * y;
X  zz = s * z * z;   xz = s * x * z;   wz = s * w * z;
X
X  dest[0][0] = 1.0f - yy - zz;
X  dest[1][1] = 1.0f - xx - zz;
X  dest[2][2] = 1.0f - xx - yy;
X
X  dest[0][1] = xy + wz;
X  dest[1][2] = yz + wx;
X  dest[2][0] = xz + wy;
X
X  dest[1][0] = xy - wz;
X  dest[2][1] = yz - wx;
X  dest[0][2] = xz - wy;
X
X  dest[0][3] = 0.0f;
X  dest[1][3] = 0.0f;
X  dest[2][3] = 0.0f;
X  dest[3][0] = 0.0f;
X  dest[3][1] = 0.0f;
X  dest[3][2] = 0.0f;
X  dest[3][3] = 1.0f;
X}
X
X/*!
X * @brief convert quaternion to mat4 (transposed)
X *
X * @param[in]   q     quaternion
X * @param[out]  dest  result matrix as transposed
X */
XCGLM_INLINE
Xvoid
Xglm_quat_mat4t(versor q, mat4 dest) {
X  float w, x, y, z,
X        xx, yy, zz,
X        xy, yz, xz,
X        wx, wy, wz, norm, s;
X
X  norm = glm_quat_norm(q);
X  s    = norm > 0.0f ? 2.0f / norm : 0.0f;
X
X  x = q[0];
X  y = q[1];
X  z = q[2];
X  w = q[3];
X
X  xx = s * x * x;   xy = s * x * y;   wx = s * w * x;
X  yy = s * y * y;   yz = s * y * z;   wy = s * w * y;
X  zz = s * z * z;   xz = s * x * z;   wz = s * w * z;
X
X  dest[0][0] = 1.0f - yy - zz;
X  dest[1][1] = 1.0f - xx - zz;
X  dest[2][2] = 1.0f - xx - yy;
X
X  dest[1][0] = xy + wz;
X  dest[2][1] = yz + wx;
X  dest[0][2] = xz + wy;
X
X  dest[0][1] = xy - wz;
X  dest[1][2] = yz - wx;
X  dest[2][0] = xz - wy;
X
X  dest[0][3] = 0.0f;
X  dest[1][3] = 0.0f;
X  dest[2][3] = 0.0f;
X  dest[3][0] = 0.0f;
X  dest[3][1] = 0.0f;
X  dest[3][2] = 0.0f;
X  dest[3][3] = 1.0f;
X}
X
X/*!
X * @brief convert quaternion to mat3
X *
X * @param[in]   q     quaternion
X * @param[out]  dest  result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_quat_mat3(versor q, mat3 dest) {
X  float w, x, y, z,
X        xx, yy, zz,
X        xy, yz, xz,
X        wx, wy, wz, norm, s;
X
X  norm = glm_quat_norm(q);
X  s    = norm > 0.0f ? 2.0f / norm : 0.0f;
X
X  x = q[0];
X  y = q[1];
X  z = q[2];
X  w = q[3];
X
X  xx = s * x * x;   xy = s * x * y;   wx = s * w * x;
X  yy = s * y * y;   yz = s * y * z;   wy = s * w * y;
X  zz = s * z * z;   xz = s * x * z;   wz = s * w * z;
X
X  dest[0][0] = 1.0f - yy - zz;
X  dest[1][1] = 1.0f - xx - zz;
X  dest[2][2] = 1.0f - xx - yy;
X
X  dest[0][1] = xy + wz;
X  dest[1][2] = yz + wx;
X  dest[2][0] = xz + wy;
X
X  dest[1][0] = xy - wz;
X  dest[2][1] = yz - wx;
X  dest[0][2] = xz - wy;
X}
X
X/*!
X * @brief convert quaternion to mat3 (transposed)
X *
X * @param[in]   q     quaternion
X * @param[out]  dest  result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_quat_mat3t(versor q, mat3 dest) {
X  float w, x, y, z,
X        xx, yy, zz,
X        xy, yz, xz,
X        wx, wy, wz, norm, s;
X
X  norm = glm_quat_norm(q);
X  s    = norm > 0.0f ? 2.0f / norm : 0.0f;
X
X  x = q[0];
X  y = q[1];
X  z = q[2];
X  w = q[3];
X
X  xx = s * x * x;   xy = s * x * y;   wx = s * w * x;
X  yy = s * y * y;   yz = s * y * z;   wy = s * w * y;
X  zz = s * z * z;   xz = s * x * z;   wz = s * w * z;
X
X  dest[0][0] = 1.0f - yy - zz;
X  dest[1][1] = 1.0f - xx - zz;
X  dest[2][2] = 1.0f - xx - yy;
X
X  dest[1][0] = xy + wz;
X  dest[2][1] = yz + wx;
X  dest[0][2] = xz + wy;
X
X  dest[0][1] = xy - wz;
X  dest[1][2] = yz - wx;
X  dest[2][0] = xz - wy;
X}
X
X/*!
X * @brief interpolates between two quaternions
X *        using linear interpolation (LERP)
X *
X * @param[in]   from  from
X * @param[in]   to    to
X * @param[in]   t     interpolant (amount)
X * @param[out]  dest  result quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_lerp(versor from, versor to, float t, versor dest) {
X  glm_vec4_lerp(from, to, t, dest);
X}
X
X/*!
X * @brief interpolates between two quaternions
X *        using linear interpolation (LERP)
X *
X * @param[in]   from  from
X * @param[in]   to    to
X * @param[in]   t     interpolant (amount) clamped between 0 and 1
X * @param[out]  dest  result quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_lerpc(versor from, versor to, float t, versor dest) {
X  glm_vec4_lerpc(from, to, t, dest);
X}
X
X/*!
X * @brief interpolates between two quaternions
X *        using spherical linear interpolation (SLERP)
X *
X * @param[in]   from  from
X * @param[in]   to    to
X * @param[in]   t     amout
X * @param[out]  dest  result quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_slerp(versor from, versor to, float t, versor dest) {
X  CGLM_ALIGN(16) vec4 q1, q2;
X  float cosTheta, sinTheta, angle;
X
X  cosTheta = glm_quat_dot(from, to);
X  glm_quat_copy(from, q1);
X
X  if (fabsf(cosTheta) >= 1.0f) {
X    glm_quat_copy(q1, dest);
X    return;
X  }
X
X  if (cosTheta < 0.0f) {
X    glm_vec4_negate(q1);
X    cosTheta = -cosTheta;
X  }
X
X  sinTheta = sqrtf(1.0f - cosTheta * cosTheta);
X
X  /* LERP to avoid zero division */
X  if (fabsf(sinTheta) < 0.001f) {
X    glm_quat_lerp(from, to, t, dest);
X    return;
X  }
X
X  /* SLERP */
X  angle = acosf(cosTheta);
X  glm_vec4_scale(q1, sinf((1.0f - t) * angle), q1);
X  glm_vec4_scale(to, sinf(t * angle), q2);
X
X  glm_vec4_add(q1, q2, q1);
X  glm_vec4_scale(q1, 1.0f / sinTheta, dest);
X}
X
X/*!
X * @brief creates view matrix using quaternion as camera orientation
X *
X * @param[in]   eye   eye
X * @param[in]   ori   orientation in world space as quaternion
X * @param[out]  dest  view matrix
X */
XCGLM_INLINE
Xvoid
Xglm_quat_look(vec3 eye, versor ori, mat4 dest) {
X  /* orientation */
X  glm_quat_mat4t(ori, dest);
X
X  /* translate */
X  glm_mat4_mulv3(dest, eye, 1.0f, dest[3]);
X  glm_vec3_negate(dest[3]);
X}
X
X/*!
X * @brief creates look rotation quaternion
X *
X * @param[in]   dir   direction to look
X * @param[in]   fwd   forward vector
X * @param[in]   up    up vector
X * @param[out]  dest  destination quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_for(vec3 dir, vec3 fwd, vec3 up, versor dest) {
X  CGLM_ALIGN(8) vec3 axis;
X  float dot, angle;
X
X  dot = glm_vec3_dot(dir, fwd);
X  if (fabsf(dot + 1.0f)  < 0.000001f) {
X    glm_quat_init(dest, up[0], up[1], up[2], GLM_PIf);
X    return;
X  }
X
X  if (fabsf(dot - 1.0f) < 0.000001f) {
X    glm_quat_identity(dest);
X    return;
X  }
X
X  angle = acosf(dot);
X  glm_cross(fwd, dir, axis);
X  glm_normalize(axis);
X
X  glm_quatv(dest, angle, axis);
X}
X
X/*!
X * @brief creates look rotation quaternion using source and
X *        destination positions p suffix stands for position
X *
X * @param[in]   from  source point
X * @param[in]   to    destination point
X * @param[in]   fwd   forward vector
X * @param[in]   up    up vector
X * @param[out]  dest  destination quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_forp(vec3 from, vec3 to, vec3 fwd, vec3 up, versor dest) {
X  CGLM_ALIGN(8) vec3 dir;
X  glm_vec3_sub(to, from, dir);
X  glm_quat_for(dir, fwd, up, dest);
X}
X
X/*!
X * @brief rotate vector using using quaternion
X *
X * @param[in]   q     quaternion
X * @param[in]   v     vector to rotate
X * @param[out]  dest  rotated vector
X */
XCGLM_INLINE
Xvoid
Xglm_quat_rotatev(versor q, vec3 v, vec3 dest) {
X  CGLM_ALIGN(16) versor p;
X  CGLM_ALIGN(8)  vec3   u, v1, v2;
X  float s;
X
X  glm_quat_normalize_to(q, p);
X  glm_quat_imag(p, u);
X  s = glm_quat_real(p);
X
X  glm_vec3_scale(u, 2.0f * glm_vec3_dot(u, v), v1);
X  glm_vec3_scale(v, s * s - glm_vec3_dot(u, u), v2);
X  glm_vec3_add(v1, v2, v1);
X
X  glm_vec3_cross(u, v, v2);
X  glm_vec3_scale(v2, 2.0f * s, v2);
X
X  glm_vec3_add(v1, v2, dest);
X}
X
X/*!
X * @brief rotate existing transform matrix using quaternion
X *
X * @param[in]   m     existing transform matrix
X * @param[in]   q     quaternion
X * @param[out]  dest  rotated matrix/transform
X */
XCGLM_INLINE
Xvoid
Xglm_quat_rotate(mat4 m, versor q, mat4 dest) {
X  CGLM_ALIGN_MAT mat4 rot;
X  glm_quat_mat4(q, rot);
X  glm_mul_rot(m, rot, dest);
X}
X
X/*!
X * @brief rotate existing transform matrix using quaternion at pivot point
X *
X * @param[in, out]   m     existing transform matrix
X * @param[in]        q     quaternion
X * @param[out]       pivot pivot
X */
XCGLM_INLINE
Xvoid
Xglm_quat_rotate_at(mat4 m, versor q, vec3 pivot) {
X  CGLM_ALIGN(8) vec3 pivotInv;
X
X  glm_vec3_negate_to(pivot, pivotInv);
X
X  glm_translate(m, pivot);
X  glm_quat_rotate(m, q, m);
X  glm_translate(m, pivotInv);
X}
X
X/*!
X * @brief rotate NEW transform matrix using quaternion at pivot point
X *
X * this creates rotation matrix, it assumes you don't have a matrix
X *
X * this should work faster than glm_quat_rotate_at because it reduces
X * one glm_translate.
X *
X * @param[out]  m     existing transform matrix
X * @param[in]   q     quaternion
X * @param[in]   pivot pivot
X */
XCGLM_INLINE
Xvoid
Xglm_quat_rotate_atm(mat4 m, versor q, vec3 pivot) {
X  CGLM_ALIGN(8) vec3 pivotInv;
X
X  glm_vec3_negate_to(pivot, pivotInv);
X
X  glm_translate_make(m, pivot);
X  glm_quat_rotate(m, q, m);
X  glm_translate(m, pivotInv);
X}
X
X#endif /* cglm_quat_h */
04c24ba264492706af55aaf3fb20addf
echo x - cglm/affine-mat.h
sed 's/^X//' >cglm/affine-mat.h << 'cf62f4daa8942dd96e24f485e099bd81'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_mul(mat4 m1, mat4 m2, mat4 dest);
X   CGLM_INLINE void glm_inv_tr(mat4 mat);
X */
X
X#ifndef cglm_affine_mat_h
X#define cglm_affine_mat_h
X
X#include "common.h"
X#include "mat4.h"
X#include "mat3.h"
X
X#ifdef CGLM_SSE_FP
X#  include "simd/sse2/affine.h"
X#endif
X
X#ifdef CGLM_AVX_FP
X#  include "simd/avx/affine.h"
X#endif
X
X/*!
X * @brief this is similar to glm_mat4_mul but specialized to affine transform
X *
X * Matrix format should be:
X *   R  R  R  X
X *   R  R  R  Y
X *   R  R  R  Z
X *   0  0  0  W
X *
X * this reduces some multiplications. It should be faster than mat4_mul.
X * if you are not sure about matrix format then DON'T use this! use mat4_mul
X *
X * @param[in]   m1    affine matrix 1
X * @param[in]   m2    affine matrix 2
X * @param[out]  dest  result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mul(mat4 m1, mat4 m2, mat4 dest) {
X#ifdef __AVX__
X  glm_mul_avx(m1, m2, dest);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mul_sse2(m1, m2, dest);
X#else
X  float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2], a03 = m1[0][3],
X        a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2], a13 = m1[1][3],
X        a20 = m1[2][0], a21 = m1[2][1], a22 = m1[2][2], a23 = m1[2][3],
X        a30 = m1[3][0], a31 = m1[3][1], a32 = m1[3][2], a33 = m1[3][3],
X
X        b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2],
X        b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2],
X        b20 = m2[2][0], b21 = m2[2][1], b22 = m2[2][2],
X        b30 = m2[3][0], b31 = m2[3][1], b32 = m2[3][2], b33 = m2[3][3];
X
X  dest[0][0] = a00 * b00 + a10 * b01 + a20 * b02;
X  dest[0][1] = a01 * b00 + a11 * b01 + a21 * b02;
X  dest[0][2] = a02 * b00 + a12 * b01 + a22 * b02;
X  dest[0][3] = a03 * b00 + a13 * b01 + a23 * b02;
X
X  dest[1][0] = a00 * b10 + a10 * b11 + a20 * b12;
X  dest[1][1] = a01 * b10 + a11 * b11 + a21 * b12;
X  dest[1][2] = a02 * b10 + a12 * b11 + a22 * b12;
X  dest[1][3] = a03 * b10 + a13 * b11 + a23 * b12;
X
X  dest[2][0] = a00 * b20 + a10 * b21 + a20 * b22;
X  dest[2][1] = a01 * b20 + a11 * b21 + a21 * b22;
X  dest[2][2] = a02 * b20 + a12 * b21 + a22 * b22;
X  dest[2][3] = a03 * b20 + a13 * b21 + a23 * b22;
X
X  dest[3][0] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
X  dest[3][1] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
X  dest[3][2] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
X  dest[3][3] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
X#endif
X}
X
X/*!
X * @brief this is similar to glm_mat4_mul but specialized to affine transform
X *
X * Right Matrix format should be:
X *   R  R  R  0
X *   R  R  R  0
X *   R  R  R  0
X *   0  0  0  1
X *
X * this reduces some multiplications. It should be faster than mat4_mul.
X * if you are not sure about matrix format then DON'T use this! use mat4_mul
X *
X * @param[in]   m1    affine matrix 1
X * @param[in]   m2    affine matrix 2
X * @param[out]  dest  result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mul_rot(mat4 m1, mat4 m2, mat4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mul_rot_sse2(m1, m2, dest);
X#else
X  float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2], a03 = m1[0][3],
X        a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2], a13 = m1[1][3],
X        a20 = m1[2][0], a21 = m1[2][1], a22 = m1[2][2], a23 = m1[2][3],
X        a30 = m1[3][0], a31 = m1[3][1], a32 = m1[3][2], a33 = m1[3][3],
X
X        b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2],
X        b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2],
X        b20 = m2[2][0], b21 = m2[2][1], b22 = m2[2][2];
X
X  dest[0][0] = a00 * b00 + a10 * b01 + a20 * b02;
X  dest[0][1] = a01 * b00 + a11 * b01 + a21 * b02;
X  dest[0][2] = a02 * b00 + a12 * b01 + a22 * b02;
X  dest[0][3] = a03 * b00 + a13 * b01 + a23 * b02;
X
X  dest[1][0] = a00 * b10 + a10 * b11 + a20 * b12;
X  dest[1][1] = a01 * b10 + a11 * b11 + a21 * b12;
X  dest[1][2] = a02 * b10 + a12 * b11 + a22 * b12;
X  dest[1][3] = a03 * b10 + a13 * b11 + a23 * b12;
X
X  dest[2][0] = a00 * b20 + a10 * b21 + a20 * b22;
X  dest[2][1] = a01 * b20 + a11 * b21 + a21 * b22;
X  dest[2][2] = a02 * b20 + a12 * b21 + a22 * b22;
X  dest[2][3] = a03 * b20 + a13 * b21 + a23 * b22;
X
X  dest[3][0] = a30;
X  dest[3][1] = a31;
X  dest[3][2] = a32;
X  dest[3][3] = a33;
X#endif
X}
X
X/*!
X * @brief inverse orthonormal rotation + translation matrix (ridig-body)
X *
X * @code
X * X = | R  T |   X' = | R' -R'T |
X *     | 0  1 |        | 0     1 |
X * @endcode
X *
X * @param[in,out]  mat  matrix
X */
XCGLM_INLINE
Xvoid
Xglm_inv_tr(mat4 mat) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glm_inv_tr_sse2(mat);
X#else
X  CGLM_ALIGN_MAT mat3 r;
X  CGLM_ALIGN(8)  vec3 t;
X
X  /* rotate */
X  glm_mat4_pick3t(mat, r);
X  glm_mat4_ins3(r, mat);
X
X  /* translate */
X  glm_mat3_mulv(r, mat[3], t);
X  glm_vec3_negate(t);
X  glm_vec3_copy(t, mat[3]);
X#endif
X}
X
X#endif /* cglm_affine_mat_h */
cf62f4daa8942dd96e24f485e099bd81
echo x - cglm/plane.h
sed 's/^X//' >cglm/plane.h << 'ef16300b3def293d45202ced392bd452'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_plane_h
X#define cglm_plane_h
X
X#include "common.h"
X#include "vec4.h"
X
X/*
X Plane equation:  Ax + By + Cz + D = 0;
X
X It stored in vec4 as [A, B, C, D]. (A, B, C) is normal and D is distance
X*/
X
X/*
X Functions:
X   CGLM_INLINE void  glm_plane_normalize(vec4 plane);
X */
X
X/*!
X * @brief normalizes a plane
X *
X * @param[in, out] plane plane to normalize
X */
XCGLM_INLINE
Xvoid
Xglm_plane_normalize(vec4 plane) {
X  glm_vec4_scale(plane, 1.0f / glm_vec3_norm(plane), plane);
X}
X
X#endif /* cglm_plane_h */
ef16300b3def293d45202ced392bd452
echo x - cglm/frustum.h
sed 's/^X//' >cglm/frustum.h << '01c658057a2f261c6e0a32a04d5a5f8b'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_frustum_h
X#define cglm_frustum_h
X
X#include "common.h"
X#include "plane.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X
X#define GLM_LBN 0 /* left  bottom near */
X#define GLM_LTN 1 /* left  top    near */
X#define GLM_RTN 2 /* right top    near */
X#define GLM_RBN 3 /* right bottom near */
X
X#define GLM_LBF 4 /* left  bottom far  */
X#define GLM_LTF 5 /* left  top    far  */
X#define GLM_RTF 6 /* right top    far  */
X#define GLM_RBF 7 /* right bottom far  */
X
X#define GLM_LEFT   0
X#define GLM_RIGHT  1
X#define GLM_BOTTOM 2
X#define GLM_TOP    3
X#define GLM_NEAR   4
X#define GLM_FAR    5
X
X/* you can override clip space coords
X   but you have to provide all with same name
X   e.g.: define GLM_CSCOORD_LBN {0.0f, 0.0f, 1.0f, 1.0f} */
X#ifndef GLM_CUSTOM_CLIPSPACE
X
X/* near */
X#define GLM_CSCOORD_LBN {-1.0f, -1.0f, -1.0f, 1.0f}
X#define GLM_CSCOORD_LTN {-1.0f,  1.0f, -1.0f, 1.0f}
X#define GLM_CSCOORD_RTN { 1.0f,  1.0f, -1.0f, 1.0f}
X#define GLM_CSCOORD_RBN { 1.0f, -1.0f, -1.0f, 1.0f}
X
X/* far */
X#define GLM_CSCOORD_LBF {-1.0f, -1.0f,  1.0f, 1.0f}
X#define GLM_CSCOORD_LTF {-1.0f,  1.0f,  1.0f, 1.0f}
X#define GLM_CSCOORD_RTF { 1.0f,  1.0f,  1.0f, 1.0f}
X#define GLM_CSCOORD_RBF { 1.0f, -1.0f,  1.0f, 1.0f}
X
X#endif
X
X/*!
X * @brief extracts view frustum planes
X *
X * planes' space:
X *  1- if m = proj:     View Space
X *  2- if m = viewProj: World Space
X *  3- if m = MVP:      Object Space
X *
X * You probably want to extract planes in world space so use viewProj as m
X * Computing viewProj:
X *   glm_mat4_mul(proj, view, viewProj);
X *
X * Exracted planes order: [left, right, bottom, top, near, far]
X *
X * @param[in]  m    matrix (see brief)
X * @param[out] dest extracted view frustum planes (see brief)
X */
XCGLM_INLINE
Xvoid
Xglm_frustum_planes(mat4 m, vec4 dest[6]) {
X  mat4 t;
X
X  glm_mat4_transpose_to(m, t);
X
X  glm_vec4_add(t[3], t[0], dest[0]); /* left   */
X  glm_vec4_sub(t[3], t[0], dest[1]); /* right  */
X  glm_vec4_add(t[3], t[1], dest[2]); /* bottom */
X  glm_vec4_sub(t[3], t[1], dest[3]); /* top    */
X  glm_vec4_add(t[3], t[2], dest[4]); /* near   */
X  glm_vec4_sub(t[3], t[2], dest[5]); /* far    */
X
X  glm_plane_normalize(dest[0]);
X  glm_plane_normalize(dest[1]);
X  glm_plane_normalize(dest[2]);
X  glm_plane_normalize(dest[3]);
X  glm_plane_normalize(dest[4]);
X  glm_plane_normalize(dest[5]);
X}
X
X/*!
X * @brief extracts view frustum corners using clip-space coordinates
X *
X * corners' space:
X *  1- if m = invViewProj: World Space
X *  2- if m = invMVP:      Object Space
X *
X * You probably want to extract corners in world space so use invViewProj
X * Computing invViewProj:
X *   glm_mat4_mul(proj, view, viewProj);
X *   ...
X *   glm_mat4_inv(viewProj, invViewProj);
X *
X * if you have a near coord at i index, you can get it's far coord by i + 4
X *
X * Find center coordinates:
X *   for (j = 0; j < 4; j++) {
X *     glm_vec3_center(corners[i], corners[i + 4], centerCorners[i]);
X *   }
X *
X * @param[in]  invMat matrix (see brief)
X * @param[out] dest   exracted view frustum corners (see brief)
X */
XCGLM_INLINE
Xvoid
Xglm_frustum_corners(mat4 invMat, vec4 dest[8]) {
X  vec4 c[8];
X
X  /* indexOf(nearCoord) = indexOf(farCoord) + 4 */
X  vec4 csCoords[8] = {
X    GLM_CSCOORD_LBN,
X    GLM_CSCOORD_LTN,
X    GLM_CSCOORD_RTN,
X    GLM_CSCOORD_RBN,
X
X    GLM_CSCOORD_LBF,
X    GLM_CSCOORD_LTF,
X    GLM_CSCOORD_RTF,
X    GLM_CSCOORD_RBF
X  };
X
X  glm_mat4_mulv(invMat, csCoords[0], c[0]);
X  glm_mat4_mulv(invMat, csCoords[1], c[1]);
X  glm_mat4_mulv(invMat, csCoords[2], c[2]);
X  glm_mat4_mulv(invMat, csCoords[3], c[3]);
X  glm_mat4_mulv(invMat, csCoords[4], c[4]);
X  glm_mat4_mulv(invMat, csCoords[5], c[5]);
X  glm_mat4_mulv(invMat, csCoords[6], c[6]);
X  glm_mat4_mulv(invMat, csCoords[7], c[7]);
X
X  glm_vec4_scale(c[0], 1.0f / c[0][3], dest[0]);
X  glm_vec4_scale(c[1], 1.0f / c[1][3], dest[1]);
X  glm_vec4_scale(c[2], 1.0f / c[2][3], dest[2]);
X  glm_vec4_scale(c[3], 1.0f / c[3][3], dest[3]);
X  glm_vec4_scale(c[4], 1.0f / c[4][3], dest[4]);
X  glm_vec4_scale(c[5], 1.0f / c[5][3], dest[5]);
X  glm_vec4_scale(c[6], 1.0f / c[6][3], dest[6]);
X  glm_vec4_scale(c[7], 1.0f / c[7][3], dest[7]);
X}
X
X/*!
X * @brief finds center of view frustum
X *
X * @param[in]  corners view frustum corners
X * @param[out] dest    view frustum center
X */
XCGLM_INLINE
Xvoid
Xglm_frustum_center(vec4 corners[8], vec4 dest) {
X  vec4 center;
X
X  glm_vec4_copy(corners[0], center);
X
X  glm_vec4_add(corners[1], center, center);
X  glm_vec4_add(corners[2], center, center);
X  glm_vec4_add(corners[3], center, center);
X  glm_vec4_add(corners[4], center, center);
X  glm_vec4_add(corners[5], center, center);
X  glm_vec4_add(corners[6], center, center);
X  glm_vec4_add(corners[7], center, center);
X
X  glm_vec4_scale(center, 0.125f, dest);
X}
X
X/*!
X * @brief finds bounding box of frustum relative to given matrix e.g. view mat
X *
X * @param[in]  corners view frustum corners
X * @param[in]  m       matrix to convert existing conners
X * @param[out] box     bounding box as array [min, max]
X */
XCGLM_INLINE
Xvoid
Xglm_frustum_box(vec4 corners[8], mat4 m, vec3 box[2]) {
X  vec4 v;
X  vec3 min, max;
X  int  i;
X
X  glm_vec3_broadcast(FLT_MAX, min);
X  glm_vec3_broadcast(-FLT_MAX, max);
X
X  for (i = 0; i < 8; i++) {
X    glm_mat4_mulv(m, corners[i], v);
X
X    min[0] = glm_min(min[0], v[0]);
X    min[1] = glm_min(min[1], v[1]);
X    min[2] = glm_min(min[2], v[2]);
X
X    max[0] = glm_max(max[0], v[0]);
X    max[1] = glm_max(max[1], v[1]);
X    max[2] = glm_max(max[2], v[2]);
X  }
X
X  glm_vec3_copy(min, box[0]);
X  glm_vec3_copy(max, box[1]);
X}
X
X/*!
X * @brief finds planes corners which is between near and far planes (parallel)
X *
X * this will be helpful if you want to split a frustum e.g. CSM/PSSM. This will
X * find planes' corners but you will need to one more plane.
X * Actually you have it, it is near, far or created previously with this func ;)
X *
X * @param[in]  corners view  frustum corners
X * @param[in]  splitDist     split distance
X * @param[in]  farDist       far distance (zFar)
X * @param[out] planeCorners  plane corners [LB, LT, RT, RB]
X */
XCGLM_INLINE
Xvoid
Xglm_frustum_corners_at(vec4  corners[8],
X                       float splitDist,
X                       float farDist,
X                       vec4  planeCorners[4]) {
X  vec4  corner;
X  float dist, sc;
X
X  /* because distance and scale is same for all */
X  dist = glm_vec3_distance(corners[GLM_RTF], corners[GLM_RTN]);
X  sc   = dist * (splitDist / farDist);
X
X  /* left bottom */
X  glm_vec4_sub(corners[GLM_LBF], corners[GLM_LBN], corner);
X  glm_vec4_scale_as(corner, sc, corner);
X  glm_vec4_add(corners[GLM_LBN], corner, planeCorners[0]);
X
X  /* left top */
X  glm_vec4_sub(corners[GLM_LTF], corners[GLM_LTN], corner);
X  glm_vec4_scale_as(corner, sc, corner);
X  glm_vec4_add(corners[GLM_LTN], corner, planeCorners[1]);
X
X  /* right top */
X  glm_vec4_sub(corners[GLM_RTF], corners[GLM_RTN], corner);
X  glm_vec4_scale_as(corner, sc, corner);
X  glm_vec4_add(corners[GLM_RTN], corner, planeCorners[2]);
X
X  /* right bottom */
X  glm_vec4_sub(corners[GLM_RBF], corners[GLM_RBN], corner);
X  glm_vec4_scale_as(corner, sc, corner);
X  glm_vec4_add(corners[GLM_RBN], corner, planeCorners[3]);
X}
X
X#endif /* cglm_frustum_h */
01c658057a2f261c6e0a32a04d5a5f8b
echo x - cglm/box.h
sed 's/^X//' >cglm/box.h << '20d63fee5723077625ce950a94b6d469'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_box_h
X#define cglm_box_h
X
X#include "common.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "util.h"
X
X/*!
X * @brief apply transform to Axis-Aligned Bounding Box
X *
X * @param[in]  box  bounding box
X * @param[in]  m    transform matrix
X * @param[out] dest transformed bounding box
X */
XCGLM_INLINE
Xvoid
Xglm_aabb_transform(vec3 box[2], mat4 m, vec3 dest[2]) {
X  vec3 v[2], xa, xb, ya, yb, za, zb;
X
X  glm_vec3_scale(m[0], box[0][0], xa);
X  glm_vec3_scale(m[0], box[1][0], xb);
X
X  glm_vec3_scale(m[1], box[0][1], ya);
X  glm_vec3_scale(m[1], box[1][1], yb);
X
X  glm_vec3_scale(m[2], box[0][2], za);
X  glm_vec3_scale(m[2], box[1][2], zb);
X
X  /* translation + min(xa, xb) + min(ya, yb) + min(za, zb) */
X  glm_vec3(m[3], v[0]);
X  glm_vec3_minadd(xa, xb, v[0]);
X  glm_vec3_minadd(ya, yb, v[0]);
X  glm_vec3_minadd(za, zb, v[0]);
X
X  /* translation + max(xa, xb) + max(ya, yb) + max(za, zb) */
X  glm_vec3(m[3], v[1]);
X  glm_vec3_maxadd(xa, xb, v[1]);
X  glm_vec3_maxadd(ya, yb, v[1]);
X  glm_vec3_maxadd(za, zb, v[1]);
X
X  glm_vec3_copy(v[0], dest[0]);
X  glm_vec3_copy(v[1], dest[1]);
X}
X
X/*!
X * @brief merges two AABB bounding box and creates new one
X *
X * two box must be in same space, if one of box is in different space then
X * you should consider to convert it's space by glm_box_space
X *
X * @param[in]  box1 bounding box 1
X * @param[in]  box2 bounding box 2
X * @param[out] dest merged bounding box
X */
XCGLM_INLINE
Xvoid
Xglm_aabb_merge(vec3 box1[2], vec3 box2[2], vec3 dest[2]) {
X  dest[0][0] = glm_min(box1[0][0], box2[0][0]);
X  dest[0][1] = glm_min(box1[0][1], box2[0][1]);
X  dest[0][2] = glm_min(box1[0][2], box2[0][2]);
X
X  dest[1][0] = glm_max(box1[1][0], box2[1][0]);
X  dest[1][1] = glm_max(box1[1][1], box2[1][1]);
X  dest[1][2] = glm_max(box1[1][2], box2[1][2]);
X}
X
X/*!
X * @brief crops a bounding box with another one.
X *
X * this could be useful for gettng a bbox which fits with view frustum and
X * object bounding boxes. In this case you crop view frustum box with objects
X * box
X *
X * @param[in]  box     bounding box 1
X * @param[in]  cropBox crop box
X * @param[out] dest    cropped bounding box
X */
XCGLM_INLINE
Xvoid
Xglm_aabb_crop(vec3 box[2], vec3 cropBox[2], vec3 dest[2]) {
X  dest[0][0] = glm_max(box[0][0], cropBox[0][0]);
X  dest[0][1] = glm_max(box[0][1], cropBox[0][1]);
X  dest[0][2] = glm_max(box[0][2], cropBox[0][2]);
X
X  dest[1][0] = glm_min(box[1][0], cropBox[1][0]);
X  dest[1][1] = glm_min(box[1][1], cropBox[1][1]);
X  dest[1][2] = glm_min(box[1][2], cropBox[1][2]);
X}
X
X/*!
X * @brief crops a bounding box with another one.
X *
X * this could be useful for gettng a bbox which fits with view frustum and
X * object bounding boxes. In this case you crop view frustum box with objects
X * box
X *
X * @param[in]  box      bounding box
X * @param[in]  cropBox  crop box
X * @param[in]  clampBox miniumum box
X * @param[out] dest     cropped bounding box
X */
XCGLM_INLINE
Xvoid
Xglm_aabb_crop_until(vec3 box[2],
X                    vec3 cropBox[2],
X                    vec3 clampBox[2],
X                    vec3 dest[2]) {
X  glm_aabb_crop(box, cropBox, dest);
X  glm_aabb_merge(clampBox, dest, dest);
X}
X
X/*!
X * @brief check if AABB intersects with frustum planes
X *
X * this could be useful for frustum culling using AABB.
X *
X * OPTIMIZATION HINT:
X *  if planes order is similar to LEFT, RIGHT, BOTTOM, TOP, NEAR, FAR
X *  then this method should run even faster because it would only use two
X *  planes if object is not inside the two planes
X *  fortunately cglm extracts planes as this order! just pass what you got!
X *
X * @param[in]  box     bounding box
X * @param[in]  planes  frustum planes
X */
XCGLM_INLINE
Xbool
Xglm_aabb_frustum(vec3 box[2], vec4 planes[6]) {
X  float *p, dp;
X  int    i;
X
X  for (i = 0; i < 6; i++) {
X    p  = planes[i];
X    dp = p[0] * box[p[0] > 0.0f][0]
X       + p[1] * box[p[1] > 0.0f][1]
X       + p[2] * box[p[2] > 0.0f][2];
X
X    if (dp < -p[3])
X      return false;
X  }
X
X  return true;
X}
X
X/*!
X * @brief invalidate AABB min and max values
X *
X * @param[in, out]  box bounding box
X */
XCGLM_INLINE
Xvoid
Xglm_aabb_invalidate(vec3 box[2]) {
X  glm_vec3_broadcast(FLT_MAX,  box[0]);
X  glm_vec3_broadcast(-FLT_MAX, box[1]);
X}
X
X/*!
X * @brief check if AABB is valid or not
X *
X * @param[in]  box bounding box
X */
XCGLM_INLINE
Xbool
Xglm_aabb_isvalid(vec3 box[2]) {
X  return glm_vec3_max(box[0]) != FLT_MAX
X         && glm_vec3_min(box[1]) != -FLT_MAX;
X}
X
X/*!
X * @brief distance between of min and max
X *
X * @param[in]  box bounding box
X */
XCGLM_INLINE
Xfloat
Xglm_aabb_size(vec3 box[2]) {
X  return glm_vec3_distance(box[0], box[1]);
X}
X
X/*!
X * @brief radius of sphere which surrounds AABB
X *
X * @param[in]  box bounding box
X */
XCGLM_INLINE
Xfloat
Xglm_aabb_radius(vec3 box[2]) {
X  return glm_aabb_size(box) * 0.5f;
X}
X
X/*!
X * @brief computes center point of AABB
X *
X * @param[in]   box  bounding box
X * @param[out]  dest center of bounding box
X */
XCGLM_INLINE
Xvoid
Xglm_aabb_center(vec3 box[2], vec3 dest) {
X  glm_vec3_center(box[0], box[1], dest);
X}
X
X/*!
X * @brief check if two AABB intersects
X *
X * @param[in]   box    bounding box
X * @param[in]   other  other bounding box
X */
XCGLM_INLINE
Xbool
Xglm_aabb_aabb(vec3 box[2], vec3 other[2]) {
X  return (box[0][0] <= other[1][0] && box[1][0] >= other[0][0])
X      && (box[0][1] <= other[1][1] && box[1][1] >= other[0][1])
X      && (box[0][2] <= other[1][2] && box[1][2] >= other[0][2]);
X}
X
X/*!
X * @brief check if AABB intersects with sphere
X *
X * https://github.com/erich666/GraphicsGems/blob/master/gems/BoxSphere.c
X * Solid Box - Solid Sphere test.
X *
X * @param[in]   box    solid bounding box
X * @param[in]   s      solid sphere
X */
XCGLM_INLINE
Xbool
Xglm_aabb_sphere(vec3 box[2], vec4 s) {
X  float dmin;
X  int   a, b, c;
X
X  a = s[0] >= box[0][0];
X  b = s[1] >= box[0][1];
X  c = s[2] >= box[0][2];
X
X  dmin  = glm_pow2(s[0] - box[a][0])
X        + glm_pow2(s[1] - box[b][1])
X        + glm_pow2(s[2] - box[c][2]);
X
X  return dmin <= glm_pow2(s[3]);
X}
X
X/*!
X * @brief check if point is inside of AABB
X *
X * @param[in]   box    bounding box
X * @param[in]   point  point
X */
XCGLM_INLINE
Xbool
Xglm_aabb_point(vec3 box[2], vec3 point) {
X  return (point[0] >= box[0][0] && point[0] <= box[1][0])
X      && (point[1] >= box[0][1] && point[1] <= box[1][1])
X      && (point[2] >= box[0][2] && point[2] <= box[1][2]);
X}
X
X/*!
X * @brief check if AABB contains other AABB
X *
X * @param[in]   box    bounding box
X * @param[in]   other  other bounding box
X */
XCGLM_INLINE
Xbool
Xglm_aabb_contains(vec3 box[2], vec3 other[2]) {
X  return (box[0][0] <= other[0][0] && box[1][0] >= other[1][0])
X      && (box[0][1] <= other[0][1] && box[1][1] >= other[1][1])
X      && (box[0][2] <= other[0][2] && box[1][2] >= other[1][2]);
X}
X
X#endif /* cglm_box_h */
20d63fee5723077625ce950a94b6d469
echo x - cglm/color.h
sed 's/^X//' >cglm/color.h << '75775576c252bf6b3ef7896fe3394e85'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_color_h
X#define cglm_color_h
X
X#include "common.h"
X#include "vec3.h"
X
X/*!
X * @brief averages the color channels into one value
X *
X * @param[in]  rgb RGB color
X */
XCGLM_INLINE
Xfloat
Xglm_luminance(vec3 rgb) {
X  vec3 l = {0.212671f, 0.715160f, 0.072169f};
X  return glm_dot(rgb, l);
X}
X
X#endif /* cglm_color_h */
75775576c252bf6b3ef7896fe3394e85
echo x - cglm/project.h
sed 's/^X//' >cglm/project.h << 'd53373bd0b9407e49d349fae772049f0'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_project_h
X#define cglm_project_h
X
X#include "common.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X
X/*!
X * @brief maps the specified viewport coordinates into specified space [1]
X *        the matrix should contain projection matrix.
X *
X * if you don't have ( and don't want to have ) an inverse matrix then use
X * glm_unproject version. You may use existing inverse of matrix in somewhere
X * else, this is why glm_unprojecti exists to save save inversion cost
X *
X * [1] space:
X *  1- if m = invProj:     View Space
X *  2- if m = invViewProj: World Space
X *  3- if m = invMVP:      Object Space
X *
X * You probably want to map the coordinates into object space
X * so use invMVP as m
X *
X * Computing viewProj:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *   glm_mat4_inv(viewProj, invMVP);
X *
X * @param[in]  pos      point/position in viewport coordinates
X * @param[in]  invMat   matrix (see brief)
X * @param[in]  vp       viewport as [x, y, width, height]
X * @param[out] dest     unprojected coordinates
X */
XCGLM_INLINE
Xvoid
Xglm_unprojecti(vec3 pos, mat4 invMat, vec4 vp, vec3 dest) {
X  vec4 v;
X
X  v[0] = 2.0f * (pos[0] - vp[0]) / vp[2] - 1.0f;
X  v[1] = 2.0f * (pos[1] - vp[1]) / vp[3] - 1.0f;
X  v[2] = 2.0f *  pos[2]                  - 1.0f;
X  v[3] = 1.0f;
X
X  glm_mat4_mulv(invMat, v, v);
X  glm_vec4_scale(v, 1.0f / v[3], v);
X  glm_vec3(v, dest);
X}
X
X/*!
X * @brief maps the specified viewport coordinates into specified space [1]
X *        the matrix should contain projection matrix.
X *
X * this is same as glm_unprojecti except this function get inverse matrix for
X * you.
X *
X * [1] space:
X *  1- if m = proj:     View Space
X *  2- if m = viewProj: World Space
X *  3- if m = MVP:      Object Space
X *
X * You probably want to map the coordinates into object space
X * so use MVP as m
X *
X * Computing viewProj and MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  pos      point/position in viewport coordinates
X * @param[in]  m        matrix (see brief)
X * @param[in]  vp       viewport as [x, y, width, height]
X * @param[out] dest     unprojected coordinates
X */
XCGLM_INLINE
Xvoid
Xglm_unproject(vec3 pos, mat4 m, vec4 vp, vec3 dest) {
X  mat4 inv;
X  glm_mat4_inv(m, inv);
X  glm_unprojecti(pos, inv, vp, dest);
X}
X
X/*!
X * @brief map object coordinates to window coordinates
X *
X * Computing MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  pos      object coordinates
X * @param[in]  m        MVP matrix
X * @param[in]  vp       viewport as [x, y, width, height]
X * @param[out] dest     projected coordinates
X */
XCGLM_INLINE
Xvoid
Xglm_project(vec3 pos, mat4 m, vec4 vp, vec3 dest) {
X  CGLM_ALIGN(16) vec4 pos4, vone = GLM_VEC4_ONE_INIT;
X
X  glm_vec4(pos, 1.0f, pos4);
X
X  glm_mat4_mulv(m, pos4, pos4);
X  glm_vec4_scale(pos4, 1.0f / pos4[3], pos4); /* pos = pos / pos.w */
X  glm_vec4_add(pos4, vone, pos4);
X  glm_vec4_scale(pos4, 0.5f, pos4);
X
X  dest[0] = pos4[0] * vp[2] + vp[0];
X  dest[1] = pos4[1] * vp[3] + vp[1];
X  dest[2] = pos4[2];
X}
X
X#endif /* cglm_project_h */
d53373bd0b9407e49d349fae772049f0
echo x - cglm/sphere.h
sed 's/^X//' >cglm/sphere.h << '5b4f60bf1225b79f60850db0e2432643'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_sphere_h
X#define cglm_sphere_h
X
X#include "common.h"
X#include "mat4.h"
X
X/*
X  Sphere Representation in cglm: [center.x, center.y, center.z, radii]
X
X  You could use this representation or you can convert it to vec4 before call
X  any function
X */
X
X/*!
X * @brief helper for getting sphere radius
X *
X * @param[in]   s  sphere
X *
X * @return returns radii
X */
XCGLM_INLINE
Xfloat
Xglm_sphere_radii(vec4 s) {
X  return s[3];
X}
X
X/*!
X * @brief apply transform to sphere, it is just wrapper for glm_mat4_mulv3
X *
X * @param[in]  s    sphere
X * @param[in]  m    transform matrix
X * @param[out] dest transformed sphere
X */
XCGLM_INLINE
Xvoid
Xglm_sphere_transform(vec4 s, mat4 m, vec4 dest) {
X  glm_mat4_mulv3(m, s, 1.0f, dest);
X  dest[3] = s[3];
X}
X
X/*!
X * @brief merges two spheres and creates a new one
X *
X * two sphere must be in same space, for instance if one in world space then
X * the other must be in world space too, not in local space.
X *
X * @param[in]  s1   sphere 1
X * @param[in]  s2   sphere 2
X * @param[out] dest merged/extended sphere
X */
XCGLM_INLINE
Xvoid
Xglm_sphere_merge(vec4 s1, vec4 s2, vec4 dest) {
X  float dist, radii;
X
X  dist  = glm_vec3_distance(s1, s2);
X  radii = dist + s1[3] + s2[3];
X
X  radii = glm_max(radii, s1[3]);
X  radii = glm_max(radii, s2[3]);
X
X  glm_vec3_center(s1, s2, dest);
X  dest[3] = radii;
X}
X
X/*!
X * @brief check if two sphere intersects
X *
X * @param[in]   s1  sphere
X * @param[in]   s2  other sphere
X */
XCGLM_INLINE
Xbool
Xglm_sphere_sphere(vec4 s1, vec4 s2) {
X  return glm_vec3_distance2(s1, s2) <= glm_pow2(s1[3] + s2[3]);
X}
X
X/*!
X * @brief check if sphere intersects with point
X *
X * @param[in]   s      sphere
X * @param[in]   point  point
X */
XCGLM_INLINE
Xbool
Xglm_sphere_point(vec4 s, vec3 point) {
X  float rr;
X  rr = s[3] * s[3];
X  return glm_vec3_distance2(point, s) <= rr;
X}
X
X#endif /* cglm_sphere_h */
5b4f60bf1225b79f60850db0e2432643
echo x - cglm/ease.h
sed 's/^X//' >cglm/ease.h << 'f1bdf77d83be982a4e70fb1f888a17d4'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_ease_h
X#define cglm_ease_h
X
X#include "common.h"
X
XCGLM_INLINE
Xfloat
Xglm_ease_linear(float t) {
X  return t;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_sine_in(float t) {
X  return sinf((t - 1.0f) * GLM_PI_2f) + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_sine_out(float t) {
X  return sinf(t * GLM_PI_2f);
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_sine_inout(float t) {
X  return 0.5f * (1.0f - cosf(t * GLM_PIf));
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quad_in(float t) {
X  return t * t;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quad_out(float t) {
X  return -(t * (t - 2.0f));
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quad_inout(float t) {
X  float tt;
X
X  tt = t * t;
X  if (t < 0.5f)
X    return 2.0f * tt;
X
X  return (-2.0f * tt) + (4.0f * t) - 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_cubic_in(float t) {
X  return t * t * t;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_cubic_out(float t) {
X  float f;
X  f = t - 1.0f;
X  return f * f * f + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_cubic_inout(float t) {
X  float f;
X
X  if (t < 0.5f)
X    return 4.0f * t * t * t;
X
X  f = 2.0f * t - 2.0f;
X
X  return 0.5f * f * f * f + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quart_in(float t) {
X  float f;
X  f = t * t;
X  return f * f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quart_out(float t) {
X  float f;
X
X  f = t - 1.0f;
X
X  return f * f * f * (1.0f - t) + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quart_inout(float t) {
X  float f, g;
X
X  if (t < 0.5f) {
X    f = t * t;
X    return 8.0f * f * f;
X  }
X
X  f = t - 1.0f;
X  g = f * f;
X
X  return -8.0f * g * g + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quint_in(float t) {
X  float f;
X  f = t * t;
X  return f * f * t;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quint_out(float t) {
X  float f, g;
X
X  f = t - 1.0f;
X  g = f * f;
X
X  return g * g * f + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quint_inout(float t) {
X  float f, g;
X
X  if (t < 0.5f) {
X    f = t * t;
X    return 16.0f * f * f * t;
X  }
X
X  f = 2.0f * t - 2.0f;
X  g = f * f;
X
X  return 0.5f * g * g * f + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_exp_in(float t) {
X  if (t == 0.0f)
X    return t;
X
X  return powf(2.0f,  10.0f * (t - 1.0f));
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_exp_out(float t) {
X  if (t == 1.0f)
X    return t;
X
X  return 1.0f - powf(2.0f, -10.0f * t);
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_exp_inout(float t) {
X  if (t == 0.0f || t == 1.0f)
X    return t;
X
X  if (t < 0.5f)
X    return 0.5f * powf(2.0f, (20.0f * t) - 10.0f);
X
X  return -0.5f * powf(2.0f, (-20.0f * t) + 10.0f) + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_circ_in(float t) {
X  return 1.0f - sqrtf(1.0f - (t * t));
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_circ_out(float t) {
X  return sqrtf((2.0f - t) * t);
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_circ_inout(float t) {
X  if (t < 0.5f)
X    return 0.5f * (1.0f - sqrtf(1.0f - 4.0f * (t * t)));
X
X  return 0.5f * (sqrtf(-((2.0f * t) - 3.0f) * ((2.0f * t) - 1.0f)) + 1.0f);
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_back_in(float t) {
X  float o, z;
X
X  o = 1.70158f;
X  z = ((o + 1.0f) * t) - o;
X
X  return t * t * z;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_back_out(float t) {
X  float o, z, n;
X
X  o = 1.70158f;
X  n = t - 1.0f;
X  z = (o + 1.0f) * n + o;
X
X  return n * n * z + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_back_inout(float t) {
X  float o, z, n, m, s, x;
X
X  o = 1.70158f;
X  s = o * 1.525f;
X  x = 0.5;
X  n = t / 0.5f;
X
X  if (n < 1.0f) {
X    z = (s + 1) * n - s;
X    m = n * n * z;
X    return x * m;
X  }
X
X  n -= 2.0f;
X  z  = (s + 1.0f) * n + s;
X  m  = (n * n * z) + 2;
X
X  return x * m;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_elast_in(float t) {
X  return sinf(13.0f * GLM_PI_2f * t) * powf(2.0f, 10.0f * (t - 1.0f));
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_elast_out(float t) {
X  return sinf(-13.0f * GLM_PI_2f * (t + 1.0f)) * powf(2.0f, -10.0f * t) + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_elast_inout(float t) {
X  float a;
X
X  a = 2.0f * t;
X
X  if (t < 0.5f)
X    return 0.5f * sinf(13.0f * GLM_PI_2f * a)
X                * powf(2.0f, 10.0f * (a - 1.0f));
X
X  return 0.5f * (sinf(-13.0f * GLM_PI_2f * a)
X                 * powf(2.0f, -10.0f * (a - 1.0f)) + 2.0f);
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_bounce_out(float t) {
X  float tt;
X
X  tt = t * t;
X
X  if (t < (4.0f / 11.0f))
X    return (121.0f * tt) / 16.0f;
X
X  if (t < 8.0f / 11.0f)
X    return ((363.0f / 40.0f) * tt) - ((99.0f / 10.0f) * t) + (17.0f / 5.0f);
X
X  if (t < (9.0f / 10.0f))
X    return (4356.0f / 361.0f) * tt
X            - (35442.0f / 1805.0f) * t
X            + (16061.0f / 1805.0f);
X
X  return ((54.0f / 5.0f) * tt) - ((513.0f / 25.0f) * t) + (268.0f / 25.0f);
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_bounce_in(float t) {
X  return 1.0f - glm_ease_bounce_out(1.0f - t);
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_bounce_inout(float t) {
X  if (t < 0.5f)
X    return 0.5f * (1.0f - glm_ease_bounce_out(t * 2.0f));
X
X  return 0.5f * glm_ease_bounce_out(t * 2.0f - 1.0f) + 0.5f;
X}
X
X#endif /* cglm_ease_h */
f1bdf77d83be982a4e70fb1f888a17d4
echo x - cglm/curve.h
sed 's/^X//' >cglm/curve.h << 'f676abf880a4119f5e2fddaded9d7dfc'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_curve_h
X#define cglm_curve_h
X
X#include "common.h"
X#include "vec4.h"
X#include "mat4.h"
X
X/*!
X * @brief helper function to calculate S*M*C multiplication for curves
X *
X * This function does not encourage you to use SMC,
X * instead it is a helper if you use SMC.
X *
X * if you want to specify S as vector then use more generic glm_mat4_rmc() func.
X *
X * Example usage:
X *  B(s) = glm_smc(s, GLM_BEZIER_MAT, (vec4){p0, c0, c1, p1})
X *
X * @param[in]  s  parameter between 0 and 1 (this will be [s3, s2, s, 1])
X * @param[in]  m  basis matrix
X * @param[in]  c  position/control vector
X *
X * @return B(s)
X */
XCGLM_INLINE
Xfloat
Xglm_smc(float s, mat4 m, vec4 c) {
X  vec4 vs;
X  glm_vec4_cubic(s, vs);
X  return glm_mat4_rmc(vs, m, c);
X}
X
X#endif /* cglm_curve_h */
f676abf880a4119f5e2fddaded9d7dfc
echo x - cglm/bezier.h
sed 's/^X//' >cglm/bezier.h << '25bfb9b54b305be1de485e1f3d083cd6'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_bezier_h
X#define cglm_bezier_h
X
X#include "common.h"
X
X#define GLM_BEZIER_MAT_INIT  {{-1.0f,  3.0f, -3.0f,  1.0f},                   \
X                              { 3.0f, -6.0f,  3.0f,  0.0f},                   \
X                              {-3.0f,  3.0f,  0.0f,  0.0f},                   \
X                              { 1.0f,  0.0f,  0.0f,  0.0f}}
X#define GLM_HERMITE_MAT_INIT {{ 2.0f, -3.0f,  0.0f,  1.0f},                   \
X                              {-2.0f,  3.0f,  0.0f,  0.0f},                   \
X                              { 1.0f, -2.0f,  1.0f,  0.0f},                   \
X                              { 1.0f, -1.0f,  0.0f,  0.0f}}
X/* for C only */
X#define GLM_BEZIER_MAT  ((mat4)GLM_BEZIER_MAT_INIT)
X#define GLM_HERMITE_MAT ((mat4)GLM_HERMITE_MAT_INIT)
X
X#define CGLM_DECASTEL_EPS   1e-9f
X#define CGLM_DECASTEL_MAX   1000.0f
X#define CGLM_DECASTEL_SMALL 1e-20f
X
X/*!
X * @brief cubic bezier interpolation
X *
X * Formula:
X *  B(s) = P0*(1-s)^3 + 3*C0*s*(1-s)^2 + 3*C1*s^2*(1-s) + P1*s^3
X *
X * similar result using matrix:
X *  B(s) = glm_smc(t, GLM_BEZIER_MAT, (vec4){p0, c0, c1, p1})
X *
X * glm_eq(glm_smc(...), glm_bezier(...)) should return TRUE
X *
X * @param[in]  s    parameter between 0 and 1
X * @param[in]  p0   begin point
X * @param[in]  c0   control point 1
X * @param[in]  c1   control point 2
X * @param[in]  p1   end point
X *
X * @return B(s)
X */
XCGLM_INLINE
Xfloat
Xglm_bezier(float s, float p0, float c0, float c1, float p1) {
X  float x, xx, ss, xs3, a;
X
X  x   = 1.0f - s;
X  xx  = x * x;
X  ss  = s * s;
X  xs3 = (s - ss) * 3.0f;
X  a   = p0 * xx + c0 * xs3;
X
X  return a + s * (c1 * xs3 + p1 * ss - a);
X}
X
X/*!
X * @brief cubic hermite interpolation
X *
X * Formula:
X *  H(s) = P0*(2*s^3 - 3*s^2 + 1) + T0*(s^3 - 2*s^2 + s)
X *            + P1*(-2*s^3 + 3*s^2) + T1*(s^3 - s^2)
X *
X * similar result using matrix:
X *  H(s) = glm_smc(t, GLM_HERMITE_MAT, (vec4){p0, p1, c0, c1})
X *
X * glm_eq(glm_smc(...), glm_hermite(...)) should return TRUE
X *
X * @param[in]  s    parameter between 0 and 1
X * @param[in]  p0   begin point
X * @param[in]  t0   tangent 1
X * @param[in]  t1   tangent 2
X * @param[in]  p1   end point
X *
X * @return H(s)
X */
XCGLM_INLINE
Xfloat
Xglm_hermite(float s, float p0, float t0, float t1, float p1) {
X  float ss, d, a, b, c, e, f;
X
X  ss = s  * s;
X  a  = ss + ss;
X  c  = a  + ss;
X  b  = a  * s;
X  d  = s  * ss;
X  f  = d  - ss;
X  e  = b  - c;
X
X  return p0 * (e + 1.0f) + t0 * (f - ss + s) + t1 * f - p1 * e;
X}
X
X/*!
X * @brief iterative way to solve cubic equation
X *
X * @param[in]  prm  parameter between 0 and 1
X * @param[in]  p0   begin point
X * @param[in]  c0   control point 1
X * @param[in]  c1   control point 2
X * @param[in]  p1   end point
X *
X * @return parameter to use in cubic equation
X */
XCGLM_INLINE
Xfloat
Xglm_decasteljau(float prm, float p0, float c0, float c1, float p1) {
X  float u, v, a, b, c, d, e, f;
X  int   i;
X
X  if (prm - p0 < CGLM_DECASTEL_SMALL)
X    return 0.0f;
X
X  if (p1 - prm < CGLM_DECASTEL_SMALL)
X    return 1.0f;
X
X  u  = 0.0f;
X  v  = 1.0f;
X
X  for (i = 0; i < CGLM_DECASTEL_MAX; i++) {
X    /* de Casteljau Subdivision */
X    a  = (p0 + c0) * 0.5f;
X    b  = (c0 + c1) * 0.5f;
X    c  = (c1 + p1) * 0.5f;
X    d  = (a  + b)  * 0.5f;
X    e  = (b  + c)  * 0.5f;
X    f  = (d  + e)  * 0.5f; /* this one is on the curve! */
X
X    /* The curve point is close enough to our wanted t */
X    if (fabsf(f - prm) < CGLM_DECASTEL_EPS)
X      return glm_clamp_zo((u  + v) * 0.5f);
X
X    /* dichotomy */
X    if (f < prm) {
X      p0 = f;
X      c0 = e;
X      c1 = c;
X      u  = (u  + v) * 0.5f;
X    } else {
X      c0 = a;
X      c1 = d;
X      p1 = f;
X      v  = (u  + v) * 0.5f;
X    }
X  }
X
X  return glm_clamp_zo((u  + v) * 0.5f);
X}
X
X#endif /* cglm_bezier_h */
25bfb9b54b305be1de485e1f3d083cd6
echo x - cglm/applesimd.h
sed 's/^X//' >cglm/applesimd.h << 'd98bdb2b357fab453623f93915a548fe'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_applesimd_h
X#define cglm_applesimd_h
X#if defined(__APPLE__)                                                        \
X    && defined(SIMD_COMPILER_HAS_REQUIRED_FEATURES)                           \
X    && defined(SIMD_BASE)                                                     \
X    && defined(SIMD_TYPES)                                                    \
X    && defined(SIMD_VECTOR_TYPES)
X
X#include "common.h"
X
X/*!
X* @brief converts mat4 to Apple's simd type simd_float4x4
X* @return simd_float4x4
X*/
XCGLM_INLINE
Xsimd_float4x4
Xglm_mat4_applesimd(mat4 m) {
X  simd_float4x4 t;
X  
X  t.columns[0][0] = m[0][0];
X  t.columns[0][1] = m[0][1];
X  t.columns[0][2] = m[0][2];
X  t.columns[0][3] = m[0][3];
X
X  t.columns[1][0] = m[1][0];
X  t.columns[1][1] = m[1][1];
X  t.columns[1][2] = m[1][2];
X  t.columns[1][3] = m[1][3];
X
X  t.columns[2][0] = m[2][0];
X  t.columns[2][1] = m[2][1];
X  t.columns[2][2] = m[2][2];
X  t.columns[2][3] = m[2][3];
X
X  t.columns[3][0] = m[3][0];
X  t.columns[3][1] = m[3][1];
X  t.columns[3][2] = m[3][2];
X  t.columns[3][3] = m[3][3];
X
X  return t;
X}
X
X/*!
X* @brief converts mat3 to Apple's simd type simd_float3x3
X* @return simd_float3x3
X*/
XCGLM_INLINE
Xsimd_float3x3
Xglm_mat3_applesimd(mat3 m) {
X  simd_float3x3 t;
X  
X  t.columns[0][0] = m[0][0];
X  t.columns[0][1] = m[0][1];
X  t.columns[0][2] = m[0][2];
X
X  t.columns[1][0] = m[1][0];
X  t.columns[1][1] = m[1][1];
X  t.columns[1][2] = m[1][2];
X
X  t.columns[2][0] = m[2][0];
X  t.columns[2][1] = m[2][1];
X  t.columns[2][2] = m[2][2];
X
X  return t;
X}
X
X/*!
X* @brief converts vec4 to Apple's simd type simd_float4
X* @return simd_float4
X*/
XCGLM_INLINE
Xsimd_float4
Xglm_vec4_applesimd(vec4 v) {
X  return (simd_float4){v[0], v[1], v[2], v[3]};
X}
X
X/*!
X* @brief converts vec3 to Apple's simd type simd_float3
X* @return v
X*/
XCGLM_INLINE
Xsimd_float3
Xglm_vec3_applesimd(vec3 v) {
X  return (simd_float3){v[0], v[1], v[2]};
X}
X
X#endif
X#endif /* cglm_applesimd_h */
d98bdb2b357fab453623f93915a548fe
echo c - cglm/call
mkdir -p cglm/call > /dev/null 2>&1
echo x - cglm/call/mat4.h
sed 's/^X//' >cglm/call/mat4.h << '9891ee2f42ed2712f286cd8ddb32b304'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_mat_h
X#define cglmc_mat_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
X/* DEPRECATED! use _copy, _ucopy versions */
X#define glmc_mat4_udup(mat, dest) glmc_mat4_ucopy(mat, dest)
X#define glmc_mat4_dup(mat, dest)  glmc_mat4_copy(mat, dest)
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_ucopy(mat4 mat, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_copy(mat4 mat, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_identity(mat4 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_identity_array(mat4 * __restrict mat, size_t count);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_zero(mat4 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_pick3(mat4 mat, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_pick3t(mat4 mat, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_ins3(mat3 mat, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_mul(mat4 m1, mat4 m2, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_mulN(mat4 * __restrict matrices[], uint32_t len, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_mulv(mat4 m, vec4 v, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_mulv3(mat4 m, vec3 v, float last, vec3 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat4_trace(mat4 m);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat4_trace3(mat4 m);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_quat(mat4 m, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_transpose_to(mat4 m, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_transpose(mat4 m);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_scale_p(mat4 m, float s);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_scale(mat4 m, float s);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat4_det(mat4 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_inv(mat4 mat, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_inv_precise(mat4 mat, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_inv_fast(mat4 mat, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_swap_col(mat4 mat, int col1, int col2);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_swap_row(mat4 mat, int row1, int row2);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat4_rmc(vec4 r, mat4 m, vec4 c);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_mat_h */
9891ee2f42ed2712f286cd8ddb32b304
echo x - cglm/call/mat3.h
sed 's/^X//' >cglm/call/mat3.h << 'bef8d4ac2c3b0d0be7520619180c9e61'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_mat3_h
X#define cglmc_mat3_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
X/* DEPRECATED! use _copy, _ucopy versions */
X#define glmc_mat3_dup(mat, dest)  glmc_mat3_copy(mat, dest)
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_copy(mat3 mat, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_identity(mat3 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_zero(mat3 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_identity_array(mat3 * __restrict mat, size_t count);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_mul(mat3 m1, mat3 m2, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_transpose_to(mat3 m, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_transpose(mat3 m);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_mulv(mat3 m, vec3 v, vec3 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat3_trace(mat3 m);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_quat(mat3 m, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_scale(mat3 m, float s);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat3_det(mat3 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_inv(mat3 mat, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_swap_col(mat3 mat, int col1, int col2);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_swap_row(mat3 mat, int row1, int row2);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat3_rmc(vec3 r, mat3 m, vec3 c);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_mat3_h */
bef8d4ac2c3b0d0be7520619180c9e61
echo x - cglm/call/vec3.h
sed 's/^X//' >cglm/call/vec3.h << '01a5053946175fd441c0055c8f08c8e7'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_vec3_h
X#define cglmc_vec3_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
X/* DEPRECATED! use _copy, _ucopy versions */
X#define glmc_vec_dup(v, dest)          glmc_vec3_copy(v, dest)
X#define glmc_vec3_flipsign(v)          glmc_vec3_negate(v)
X#define glmc_vec3_flipsign_to(v, dest) glmc_vec3_negate_to(v, dest)
X#define glmc_vec3_inv(v)               glmc_vec3_negate(v)
X#define glmc_vec3_inv_to(v, dest)      glmc_vec3_negate_to(v, dest)
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3(vec4 v4, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_copy(vec3 a, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_zero(vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_one(vec3 v);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_dot(vec3 a, vec3 b);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_cross(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_crossn(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_norm(vec3 v);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_norm2(vec3 v);
X    
XCGLM_EXPORT
Xfloat
Xglmc_vec3_norm_one(vec3 v);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_norm_inf(vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_normalize_to(vec3 v, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_normalize(vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_add(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_adds(vec3 v, float s, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_sub(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_subs(vec3 v, float s, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_mul(vec3 a, vec3 b, vec3 d);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_scale(vec3 v, float s, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_scale_as(vec3 v, float s, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_div(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_divs(vec3 a, float s, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_addadd(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_subadd(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_muladd(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_muladds(vec3 a, float s, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_maxadd(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_minadd(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_negate(vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_negate_to(vec3 v, vec3 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_angle(vec3 a, vec3 b);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_rotate(vec3 v, float angle, vec3 axis);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_rotate_m4(mat4 m, vec3 v, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_rotate_m3(mat3 m, vec3 v, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_proj(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_center(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_distance2(vec3 a, vec3 b);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_distance(vec3 a, vec3 b);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_maxv(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_minv(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_clamp(vec3 v, float minVal, float maxVal);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_ortho(vec3 v, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_lerp(vec3 from, vec3 to, float t, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_lerpc(vec3 from, vec3 to, float t, vec3 dest);
X    
XCGLM_INLINE
Xvoid
Xglmc_vec3_mix(vec3 from, vec3 to, float t, vec3 dest) {
X  glmc_vec3_lerp(from, to, t, dest);
X}
X
XCGLM_INLINE
Xvoid
Xglmc_vec3_mixc(vec3 from, vec3 to, float t, vec3 dest) {
X  glmc_vec3_lerpc(from, to, t, dest);
X}
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_step_uni(float edge, vec3 x, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_step(vec3 edge, vec3 x, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_smoothstep_uni(float edge0, float edge1, vec3 x, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_smoothstep(vec3 edge0, vec3 edge1, vec3 x, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_smoothinterp(vec3 from, vec3 to, float t, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_smoothinterpc(vec3 from, vec3 to, float t, vec3 dest);
X
X/* ext */
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_mulv(vec3 a, vec3 b, vec3 d);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_broadcast(float val, vec3 d);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_fill(vec3 v, float val);
X
XCGLM_EXPORT
Xbool
Xglmc_vec3_eq(vec3 v, float val);
X
XCGLM_EXPORT
Xbool
Xglmc_vec3_eq_eps(vec3 v, float val);
X
XCGLM_EXPORT
Xbool
Xglmc_vec3_eq_all(vec3 v);
X
XCGLM_EXPORT
Xbool
Xglmc_vec3_eqv(vec3 a, vec3 b);
X
XCGLM_EXPORT
Xbool
Xglmc_vec3_eqv_eps(vec3 a, vec3 b);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_max(vec3 v);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_min(vec3 v);
X
XCGLM_EXPORT
Xbool
Xglmc_vec3_isnan(vec3 v);
X
XCGLM_EXPORT
Xbool
Xglmc_vec3_isinf(vec3 v);
X
XCGLM_EXPORT
Xbool
Xglmc_vec3_isvalid(vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_sign(vec3 v, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_abs(vec3 v, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_fract(vec3 v, vec3 dest);
X    
XCGLM_EXPORT
Xfloat
Xglmc_vec3_hadd(vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_sqrt(vec3 v, vec3 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_vec3_h */
01a5053946175fd441c0055c8f08c8e7
echo x - cglm/call/vec4.h
sed 's/^X//' >cglm/call/vec4.h << 'cfaf9fd6154726ea70347e93b486f962'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_vec4_h
X#define cglmc_vec4_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
X/* DEPRECATED! use _copy, _ucopy versions */
X#define glmc_vec4_dup3(v, dest)         glmc_vec4_copy3(v, dest)
X#define glmc_vec4_dup(v, dest)          glmc_vec4_copy(v, dest)
X#define glmc_vec4_flipsign(v)           glmc_vec4_negate(v)
X#define glmc_vec4_flipsign_to(v, dest)  glmc_vec4_negate_to(v, dest)
X#define glmc_vec4_inv(v)                glmc_vec4_negate(v)
X#define glmc_vec4_inv_to(v, dest)       glmc_vec4_negate_to(v, dest)
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4(vec3 v3, float last, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_zero(vec4 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_one(vec4 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_copy3(vec4 v, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_copy(vec4 v, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_ucopy(vec4 v, vec4 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec4_dot(vec4 a, vec4 b);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec4_norm(vec4 v);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec4_norm2(vec4 v);
X    
XCGLM_EXPORT
Xfloat
Xglmc_vec4_norm_one(vec4 v);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec4_norm_inf(vec4 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_normalize_to(vec4 v, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_normalize(vec4 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_add(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_adds(vec4 v, float s, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_sub(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_subs(vec4 v, float s, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_mul(vec4 a, vec4 b, vec4 d);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_scale(vec4 v, float s, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_scale_as(vec3 v, float s, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_div(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_divs(vec4 v, float s, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_addadd(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_subadd(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_muladd(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_muladds(vec4 a, float s, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_maxadd(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_minadd(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_negate(vec4 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_negate_to(vec4 v, vec4 dest);
X    
XCGLM_EXPORT
Xfloat
Xglmc_vec4_distance(vec4 a, vec4 b);
X    
XCGLM_EXPORT
Xfloat
Xglmc_vec4_distance2(vec4 a, vec4 b);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_maxv(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_minv(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_clamp(vec4 v, float minVal, float maxVal);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_lerp(vec4 from, vec4 to, float t, vec4 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_lerpc(vec4 from, vec4 to, float t, vec4 dest);
X    
XCGLM_INLINE
Xvoid
Xglmc_vec4_mix(vec4 from, vec4 to, float t, vec4 dest) {
X  glmc_vec4_lerp(from, to, t, dest);
X}
X
XCGLM_INLINE
Xvoid
Xglmc_vec4_mixc(vec4 from, vec4 to, float t, vec4 dest) {
X  glmc_vec4_lerpc(from, to, t, dest);
X}
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_step_uni(float edge, vec4 x, vec4 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_step(vec4 edge, vec4 x, vec4 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_smoothstep_uni(float edge0, float edge1, vec4 x, vec4 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_smoothstep(vec4 edge0, vec4 edge1, vec4 x, vec4 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_smoothinterp(vec4 from, vec4 to, float t, vec4 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_smoothinterpc(vec4 from, vec4 to, float t, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_cubic(float s, vec4 dest);
X
X/* ext */
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_mulv(vec4 a, vec4 b, vec4 d);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_broadcast(float val, vec4 d);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_fill(vec4 v, float val);
X
XCGLM_EXPORT
Xbool
Xglmc_vec4_eq(vec4 v, float val);
X
XCGLM_EXPORT
Xbool
Xglmc_vec4_eq_eps(vec4 v, float val);
X
XCGLM_EXPORT
Xbool
Xglmc_vec4_eq_all(vec4 v);
X
XCGLM_EXPORT
Xbool
Xglmc_vec4_eqv(vec4 a, vec4 b);
X
XCGLM_EXPORT
Xbool
Xglmc_vec4_eqv_eps(vec4 a, vec4 b);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec4_max(vec4 v);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec4_min(vec4 v);
X
XCGLM_EXPORT
Xbool
Xglmc_vec4_isnan(vec4 v);
X
XCGLM_EXPORT
Xbool
Xglmc_vec4_isinf(vec4 v);
X
XCGLM_EXPORT
Xbool
Xglmc_vec4_isvalid(vec4 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_sign(vec4 v, vec4 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_abs(vec4 v, vec4 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_fract(vec4 v, vec4 dest);
X    
XCGLM_EXPORT
Xfloat
Xglmc_vec4_hadd(vec4 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_sqrt(vec4 v, vec4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_vec4_h */
X
cfaf9fd6154726ea70347e93b486f962
echo x - cglm/call/affine.h
sed 's/^X//' >cglm/call/affine.h << 'f80e95f571dce8350cac70eff8a67116'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_affine_h
X#define cglmc_affine_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_translate_make(mat4 m, vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_translate_to(mat4 m, vec3 v, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_translate(mat4 m, vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_translate_x(mat4 m, float to);
X
XCGLM_EXPORT
Xvoid
Xglmc_translate_y(mat4 m, float to);
X
XCGLM_EXPORT
Xvoid
Xglmc_translate_z(mat4 m, float to);
X
XCGLM_EXPORT
Xvoid
Xglmc_scale_make(mat4 m, vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_scale_to(mat4 m, vec3 v, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_scale(mat4 m, vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_scale_uni(mat4 m, float s);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate_x(mat4 m, float rad, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate_y(mat4 m, float rad, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate_z(mat4 m, float rad, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate_make(mat4 m, float angle, vec3 axis);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate(mat4 m, float angle, vec3 axis);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate_at(mat4 m, vec3 pivot, float angle, vec3 axis);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate_atm(mat4 m, vec3 pivot, float angle, vec3 axis);
X
XCGLM_EXPORT
Xvoid
Xglmc_decompose_scalev(mat4 m, vec3 s);
X
XCGLM_EXPORT
Xbool
Xglmc_uniscaled(mat4 m);
X
XCGLM_EXPORT
Xvoid
Xglmc_decompose_rs(mat4 m, mat4 r, vec3 s);
X
XCGLM_EXPORT
Xvoid
Xglmc_decompose(mat4 m, vec4 t, mat4 r, vec3 s);
X
X/* affine-mat */
X
XCGLM_EXPORT
Xvoid
Xglmc_mul(mat4 m1, mat4 m2, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mul_rot(mat4 m1, mat4 m2, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_inv_tr(mat4 mat);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_affine_h */
f80e95f571dce8350cac70eff8a67116
echo x - cglm/call/io.h
sed 's/^X//' >cglm/call/io.h << 'd221e3bcee931504c48e3be6ef46a8cc'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_io_h
X#define cglmc_io_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_print(mat4   matrix,
X                FILE * __restrict ostream);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_print(mat3 matrix,
X                FILE * __restrict ostream);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_print(vec4 vec,
X                FILE * __restrict ostream);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_print(vec3 vec,
X                FILE * __restrict ostream);
X
XCGLM_EXPORT
Xvoid
Xglmc_versor_print(versor vec,
X                  FILE * __restrict ostream);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_io_h */
d221e3bcee931504c48e3be6ef46a8cc
echo x - cglm/call/cam.h
sed 's/^X//' >cglm/call/cam.h << '336f38d27c90d38bbdfe7e3afdea7c3e'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_cam_h
X#define cglmc_cam_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_frustum(float left,
X             float right,
X             float bottom,
X             float top,
X             float nearVal,
X             float farVal,
X             mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho(float left,
X           float right,
X           float bottom,
X           float top,
X           float nearVal,
X           float farVal,
X           mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb(vec3 box[2], mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb_p(vec3 box[2], float padding, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb_pz(vec3 box[2], float padding, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_default(float aspect, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_default_s(float aspect, float size, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_perspective(float fovy,
X                 float aspect,
X                 float nearVal,
X                 float farVal,
X                 mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_move_far(mat4 proj, float deltaFar);
X
XCGLM_EXPORT
Xvoid
Xglmc_perspective_default(float aspect, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_perspective_resize(float aspect, mat4 proj);
X
XCGLM_EXPORT
Xvoid
Xglmc_lookat(vec3 eye, vec3 center, vec3 up, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_look(vec3 eye, vec3 dir, vec3 up, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_look_anyup(vec3 eye, vec3 dir, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp(mat4 proj,
X                  float * __restrict nearVal,
X                  float * __restrict farVal,
X                  float * __restrict top,
X                  float * __restrict bottom,
X                  float * __restrict left,
X                  float * __restrict right);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decompv(mat4 proj, float dest[6]);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_x(mat4 proj,
X                    float * __restrict left,
X                    float * __restrict right);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_y(mat4 proj,
X                    float * __restrict top,
X                    float * __restrict bottom);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_z(mat4 proj,
X                    float * __restrict nearVal,
X                    float * __restrict farVal);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_far(mat4 proj, float * __restrict farVal);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_near(mat4 proj, float * __restrict nearVal);
X
XCGLM_EXPORT
Xfloat
Xglmc_persp_fovy(mat4 proj);
X
XCGLM_EXPORT
Xfloat
Xglmc_persp_aspect(mat4 proj);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_sizes(mat4 proj, float fovy, vec4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_cam_h */
336f38d27c90d38bbdfe7e3afdea7c3e
echo x - cglm/call/quat.h
sed 's/^X//' >cglm/call/quat.h << '480d19b5aa34c1fe3734d6263bbd4989'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_quat_h
X#define cglmc_quat_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_identity(versor q);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_identity_array(versor * __restrict q, size_t count);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_init(versor q, float x, float y, float z, float w);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat(versor q, float angle, float x, float y, float z);
X
XCGLM_EXPORT
Xvoid
Xglmc_quatv(versor q, float angle, vec3 axis);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_copy(versor q, versor dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_quat_norm(versor q);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_normalize_to(versor q, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_normalize(versor q);
X
XCGLM_EXPORT
Xfloat
Xglmc_quat_dot(versor p, versor q);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_conjugate(versor q, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_inv(versor q, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_add(versor p, versor q, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_sub(versor p, versor q, versor dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_quat_real(versor q);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_imag(versor q, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_imagn(versor q, vec3 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_quat_imaglen(versor q);
X
XCGLM_EXPORT
Xfloat
Xglmc_quat_angle(versor q);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_axis(versor q, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_mul(versor p, versor q, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_mat4(versor q, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_mat4t(versor q, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_mat3(versor q, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_mat3t(versor q, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_lerp(versor from, versor to, float t, versor dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_quat_lerpc(versor from, versor to, float t, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_slerp(versor q, versor r, float t, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_look(vec3 eye, versor ori, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_for(vec3 dir, vec3 fwd, vec3 up, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_forp(vec3 from, vec3 to, vec3 fwd, vec3 up, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_rotatev(versor from, vec3 to, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_rotate(mat4 m, versor q, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_rotate_at(mat4 model, versor q, vec3 pivot);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_rotate_atm(mat4 m, versor q, vec3 pivot);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_quat_h */
480d19b5aa34c1fe3734d6263bbd4989
echo x - cglm/call/euler.h
sed 's/^X//' >cglm/call/euler.h << '2376cb5100d07b3b2e025fc374b970e8'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_euler_h
X#define cglmc_euler_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_euler_angles(mat4 m, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_euler(vec3 angles, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_euler_xyz(vec3 angles,  mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_euler_zyx(vec3 angles,  mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_euler_zxy(vec3 angles, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_euler_xzy(vec3 angles, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_euler_yzx(vec3 angles, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_euler_yxz(vec3 angles, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_euler_by_order(vec3 angles, glm_euler_seq axis, mat4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_euler_h */
2376cb5100d07b3b2e025fc374b970e8
echo x - cglm/call/plane.h
sed 's/^X//' >cglm/call/plane.h << '2e82d286dfb332b800a4c02ae997e089'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_plane_h
X#define cglmc_plane_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_plane_normalize(vec4 plane);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_plane_h */
2e82d286dfb332b800a4c02ae997e089
echo x - cglm/call/frustum.h
sed 's/^X//' >cglm/call/frustum.h << '6b24446124a17a42c33a56ab4b086519'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_frustum_h
X#define cglmc_frustum_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_frustum_planes(mat4 m, vec4 dest[6]);
X
XCGLM_EXPORT
Xvoid
Xglmc_frustum_corners(mat4 invMat, vec4 dest[8]);
X
XCGLM_EXPORT
Xvoid
Xglmc_frustum_center(vec4 corners[8], vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_frustum_box(vec4 corners[8], mat4 m, vec3 box[2]);
X
XCGLM_EXPORT
Xvoid
Xglmc_frustum_corners_at(vec4  corners[8],
X                        float splitDist,
X                        float farDist,
X                        vec4  planeCorners[4]);
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_frustum_h */
6b24446124a17a42c33a56ab4b086519
echo x - cglm/call/box.h
sed 's/^X//' >cglm/call/box.h << '6c5946d926d405365843ff644268538d'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_box_h
X#define cglmc_box_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_aabb_transform(vec3 box[2], mat4 m, vec3 dest[2]);
X
XCGLM_EXPORT
Xvoid
Xglmc_aabb_merge(vec3 box1[2], vec3 box2[2], vec3 dest[2]);
X
XCGLM_EXPORT
Xvoid
Xglmc_aabb_crop(vec3 box[2], vec3 cropBox[2], vec3 dest[2]);
X
XCGLM_EXPORT
Xvoid
Xglmc_aabb_crop_until(vec3 box[2],
X                     vec3 cropBox[2],
X                     vec3 clampBox[2],
X                     vec3 dest[2]);
X
XCGLM_EXPORT
Xbool
Xglmc_aabb_frustum(vec3 box[2], vec4 planes[6]);
X
XCGLM_EXPORT
Xvoid
Xglmc_aabb_invalidate(vec3 box[2]);
X
XCGLM_EXPORT
Xbool
Xglmc_aabb_isvalid(vec3 box[2]);
X
XCGLM_EXPORT
Xfloat
Xglmc_aabb_size(vec3 box[2]);
X
XCGLM_EXPORT
Xfloat
Xglmc_aabb_radius(vec3 box[2]);
X
XCGLM_EXPORT
Xvoid
Xglmc_aabb_center(vec3 box[2], vec3 dest);
X
XCGLM_EXPORT
Xbool
Xglmc_aabb_aabb(vec3 box[2], vec3 other[2]);
X
XCGLM_EXPORT
Xbool
Xglmc_aabb_point(vec3 box[2], vec3 point);
X
XCGLM_EXPORT
Xbool
Xglmc_aabb_contains(vec3 box[2], vec3 other[2]);
X
XCGLM_EXPORT
Xbool
Xglmc_aabb_sphere(vec3 box[2], vec4 s);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_box_h */
X
6c5946d926d405365843ff644268538d
echo x - cglm/call/project.h
sed 's/^X//' >cglm/call/project.h << 'dce23cbd205852cf97ef743c178f3a4a'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_project_h
X#define cglmc_project_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_unprojecti(vec3 pos, mat4 invMat, vec4 vp, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_unproject(vec3 pos, mat4 m, vec4 vp, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_project(vec3 pos, mat4 m, vec4 vp, vec3 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_project_h */
X
X
dce23cbd205852cf97ef743c178f3a4a
echo x - cglm/call/sphere.h
sed 's/^X//' >cglm/call/sphere.h << '573e7f9ff899061cccd24dd4d868c026'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_sphere_h
X#define cglmc_sphere_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xfloat
Xglmc_sphere_radii(vec4 s);
X
XCGLM_EXPORT
Xvoid
Xglmc_sphere_transform(vec4 s, mat4 m, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_sphere_merge(vec4 s1, vec4 s2, vec4 dest);
X
XCGLM_EXPORT
Xbool
Xglmc_sphere_sphere(vec4 s1, vec4 s2);
X
XCGLM_EXPORT
Xbool
Xglmc_sphere_point(vec4 s, vec3 point);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_sphere_h */
573e7f9ff899061cccd24dd4d868c026
echo x - cglm/call/ease.h
sed 's/^X//' >cglm/call/ease.h << '710779c270d39b542b041307792d573f'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_ease_h
X#define cglmc_ease_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_linear(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_sine_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_sine_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_sine_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quad_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quad_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quad_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_cubic_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_cubic_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_cubic_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quart_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quart_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quart_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quint_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quint_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quint_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_exp_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_exp_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_exp_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_circ_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_circ_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_circ_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_back_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_back_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_back_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_elast_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_elast_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_elast_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_bounce_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_bounce_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_bounce_inout(float t);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_ease_h */
710779c270d39b542b041307792d573f
echo x - cglm/call/curve.h
sed 's/^X//' >cglm/call/curve.h << '6590266d691d78ff0608b19443556c75'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_curve_h
X#define cglmc_curve_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xfloat
Xglmc_smc(float s, mat4 m, vec4 c);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_curve_h */
6590266d691d78ff0608b19443556c75
echo x - cglm/call/bezier.h
sed 's/^X//' >cglm/call/bezier.h << '2321d08cf4d33eaba2b9056577b4509b'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_bezier_h
X#define cglmc_bezier_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xfloat
Xglmc_bezier(float s, float p0, float c0, float c1, float p1);
X
XCGLM_EXPORT
Xfloat
Xglmc_hermite(float s, float p0, float t0, float t1, float p1);
X
XCGLM_EXPORT
Xfloat
Xglmc_decasteljau(float prm, float p0, float c0, float c1, float p1);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_bezier_h */
2321d08cf4d33eaba2b9056577b4509b
echo c - cglm/simd
mkdir -p cglm/simd > /dev/null 2>&1
echo x - cglm/simd/intrin.h
sed 's/^X//' >cglm/simd/intrin.h << '40fd14d33e21c45b7c87a6e1657f80d8'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_intrin_h
X#define cglm_intrin_h
X
X#if defined( _MSC_VER )
X#  if (defined(_M_AMD64) || defined(_M_X64)) || _M_IX86_FP == 2
X#    ifndef __SSE2__
X#      define __SSE2__
X#    endif
X#  elif _M_IX86_FP == 1
X#    ifndef __SSE__
X#      define __SSE__
X#    endif
X#  endif
X/* do not use alignment for older visual studio versions */
X#  if _MSC_VER < 1913     /* Visual Studio 2017 version 15.6 */
X#    define CGLM_ALL_UNALIGNED
X#  endif
X#endif
X
X#if defined( __SSE__ ) || defined( __SSE2__ )
X#  include <xmmintrin.h>
X#  include <emmintrin.h>
X#  define CGLM_SSE_FP 1
X#  ifndef CGLM_SIMD_x86
X#    define CGLM_SIMD_x86
X#  endif
X#endif
X
X#if defined(__SSE3__)
X#  include <x86intrin.h>
X#  ifndef CGLM_SIMD_x86
X#    define CGLM_SIMD_x86
X#  endif
X#endif
X
X#if defined(__SSE4_1__)
X#  include <smmintrin.h>
X#  ifndef CGLM_SIMD_x86
X#    define CGLM_SIMD_x86
X#  endif
X#endif
X
X#if defined(__SSE4_2__)
X#  include <nmmintrin.h>
X#  ifndef CGLM_SIMD_x86
X#    define CGLM_SIMD_x86
X#  endif
X#endif
X
X#ifdef __AVX__
X#  include <immintrin.h>
X#  define CGLM_AVX_FP 1
X#  ifndef CGLM_SIMD_x86
X#    define CGLM_SIMD_x86
X#  endif
X#endif
X
X/* ARM Neon */
X#if defined(__ARM_NEON)
X#  include <arm_neon.h>
X#  if defined(__ARM_NEON_FP)
X#    define CGLM_NEON_FP 1
X#    ifndef CGLM_SIMD_ARM
X#      define CGLM_SIMD_ARM
X#    endif
X#  endif
X#endif
X
X#if defined(CGLM_SIMD_x86) || defined(CGLM_NEON_FP)
X#  ifndef CGLM_SIMD
X#    define CGLM_SIMD
X#  endif
X#endif
X
X#if defined(CGLM_SIMD_x86)
X#  include "x86.h"
X#endif
X
X#if defined(CGLM_SIMD_ARM)
X#  include "arm.h"
X#endif
X
X#endif /* cglm_intrin_h */
40fd14d33e21c45b7c87a6e1657f80d8
echo x - cglm/simd/x86.h
sed 's/^X//' >cglm/simd/x86.h << '0731aa310eb55bddd4bf94d69b9b8a4c'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_simd_x86_h
X#define cglm_simd_x86_h
X#include "intrin.h"
X#ifdef CGLM_SIMD_x86
X
X#ifdef CGLM_ALL_UNALIGNED
X#  define glmm_load(p)      _mm_loadu_ps(p)
X#  define glmm_store(p, a)  _mm_storeu_ps(p, a)
X#else
X#  define glmm_load(p)      _mm_load_ps(p)
X#  define glmm_store(p, a)  _mm_store_ps(p, a)
X#endif
X
X#ifdef CGLM_USE_INT_DOMAIN
X#  define glmm_shuff1(xmm, z, y, x, w)                                        \
X     _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(xmm),                \
X                                        _MM_SHUFFLE(z, y, x, w)))
X#else
X#  define glmm_shuff1(xmm, z, y, x, w)                                        \
X       _mm_shuffle_ps(xmm, xmm, _MM_SHUFFLE(z, y, x, w))
X#endif
X
X#define glmm_shuff1x(xmm, x) glmm_shuff1(xmm, x, x, x, x)
X#define glmm_shuff2(a, b, z0, y0, x0, w0, z1, y1, x1, w1)                     \
X     glmm_shuff1(_mm_shuffle_ps(a, b, _MM_SHUFFLE(z0, y0, x0, w0)),           \
X                 z1, y1, x1, w1)
X
X#ifdef __AVX__
X#  ifdef CGLM_ALL_UNALIGNED
X#    define glmm_load256(p)      _mm256_loadu_ps(p)
X#    define glmm_store256(p, a)  _mm256_storeu_ps(p, a)
X#  else
X#    define glmm_load256(p)      _mm256_load_ps(p)
X#    define glmm_store256(p, a)  _mm256_store_ps(p, a)
X#  endif
X#endif
X
Xstatic inline
X__m128
Xglmm_abs(__m128 x) {
X  return _mm_andnot_ps(_mm_set1_ps(-0.0f), x);
X}
X
Xstatic inline
X__m128
Xglmm_vhadds(__m128 v) {
X#if defined(__SSE3__)
X  __m128 shuf, sums;
X  shuf = _mm_movehdup_ps(v);
X  sums = _mm_add_ps(v, shuf);
X  shuf = _mm_movehl_ps(shuf, sums);
X  sums = _mm_add_ss(sums, shuf);
X  return sums;
X#else
X  __m128 shuf, sums;
X  shuf = glmm_shuff1(v, 2, 3, 0, 1);
X  sums = _mm_add_ps(v, shuf);
X  shuf = _mm_movehl_ps(shuf, sums);
X  sums = _mm_add_ss(sums, shuf);
X  return sums;
X#endif
X}
X
Xstatic inline
Xfloat
Xglmm_hadd(__m128 v) {
X  return _mm_cvtss_f32(glmm_vhadds(v));
X}
X
Xstatic inline
X__m128
Xglmm_vhmin(__m128 v) {
X  __m128 x0, x1, x2;
X  x0 = _mm_movehl_ps(v, v);     /* [2, 3, 2, 3] */
X  x1 = _mm_min_ps(x0, v);       /* [0|2, 1|3, 2|2, 3|3] */
X  x2 = glmm_shuff1x(x1, 1);     /* [1|3, 1|3, 1|3, 1|3] */
X  return _mm_min_ss(x1, x2);
X}
X
Xstatic inline
Xfloat
Xglmm_hmin(__m128 v) {
X  return _mm_cvtss_f32(glmm_vhmin(v));
X}
X
Xstatic inline
X__m128
Xglmm_vhmax(__m128 v) {
X  __m128 x0, x1, x2;
X  x0 = _mm_movehl_ps(v, v);     /* [2, 3, 2, 3] */
X  x1 = _mm_max_ps(x0, v);       /* [0|2, 1|3, 2|2, 3|3] */
X  x2 = glmm_shuff1x(x1, 1);     /* [1|3, 1|3, 1|3, 1|3] */
X  return _mm_max_ss(x1, x2);
X}
X
Xstatic inline
Xfloat
Xglmm_hmax(__m128 v) {
X  return _mm_cvtss_f32(glmm_vhmax(v));
X}
X
Xstatic inline
X__m128
Xglmm_vdots(__m128 a, __m128 b) {
X#if (defined(__SSE4_1__) || defined(__SSE4_2__)) && defined(CGLM_SSE4_DOT)
X  return _mm_dp_ps(a, b, 0xFF);
X#elif defined(__SSE3__) && defined(CGLM_SSE3_DOT)
X  __m128 x0, x1;
X  x0 = _mm_mul_ps(a, b);
X  x1 = _mm_hadd_ps(x0, x0);
X  return _mm_hadd_ps(x1, x1);
X#else
X  return glmm_vhadds(_mm_mul_ps(a, b));
X#endif
X}
X
Xstatic inline
X__m128
Xglmm_vdot(__m128 a, __m128 b) {
X#if (defined(__SSE4_1__) || defined(__SSE4_2__)) && defined(CGLM_SSE4_DOT)
X  return _mm_dp_ps(a, b, 0xFF);
X#elif defined(__SSE3__) && defined(CGLM_SSE3_DOT)
X  __m128 x0, x1;
X  x0 = _mm_mul_ps(a, b);
X  x1 = _mm_hadd_ps(x0, x0);
X  return _mm_hadd_ps(x1, x1);
X#else
X  __m128 x0;
X  x0 = _mm_mul_ps(a, b);
X  x0 = _mm_add_ps(x0, glmm_shuff1(x0, 1, 0, 3, 2));
X  return _mm_add_ps(x0, glmm_shuff1(x0, 0, 1, 0, 1));
X#endif
X}
X
Xstatic inline
Xfloat
Xglmm_dot(__m128 a, __m128 b) {
X  return _mm_cvtss_f32(glmm_vdots(a, b));
X}
X
Xstatic inline
Xfloat
Xglmm_norm(__m128 a) {
X  return _mm_cvtss_f32(_mm_sqrt_ss(glmm_vhadds(_mm_mul_ps(a, a))));
X}
X
Xstatic inline
Xfloat
Xglmm_norm2(__m128 a) {
X  return _mm_cvtss_f32(glmm_vhadds(_mm_mul_ps(a, a)));
X}
X
Xstatic inline
Xfloat
Xglmm_norm_one(__m128 a) {
X  return _mm_cvtss_f32(glmm_vhadds(glmm_abs(a)));
X}
X
Xstatic inline
Xfloat
Xglmm_norm_inf(__m128 a) {
X  return _mm_cvtss_f32(glmm_vhmax(glmm_abs(a)));
X}
X
Xstatic inline
X__m128
Xglmm_load3(float v[3]) {
X  __m128i xy;
X  __m128  z;
X
X  xy = _mm_loadl_epi64((const __m128i *)v);
X  z  = _mm_load_ss(&v[2]);
X
X  return _mm_movelh_ps(_mm_castsi128_ps(xy), z);
X}
X
Xstatic inline
Xvoid
Xglmm_store3(float v[3], __m128 vx) {
X  _mm_storel_pi((__m64 *)&v[0], vx);
X  _mm_store_ss(&v[2], glmm_shuff1(vx, 2, 2, 2, 2));
X}
X
X#endif
X#endif /* cglm_simd_x86_h */
0731aa310eb55bddd4bf94d69b9b8a4c
echo x - cglm/simd/arm.h
sed 's/^X//' >cglm/simd/arm.h << '998e1f14edb7e60145b29668a1b95898'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_simd_arm_h
X#define cglm_simd_arm_h
X#include "intrin.h"
X#ifdef CGLM_SIMD_ARM
X
X#define glmm_load(p)      vld1q_f32(p)
X#define glmm_store(p, a)  vst1q_f32(p, a)
X
Xstatic inline
Xfloat32x4_t
Xglmm_abs(float32x4_t v) {
X  return vabsq_f32(v);
X}
X
Xstatic inline
Xfloat
Xglmm_hadd(float32x4_t v) {
X#if defined(__aarch64__)
X  return vaddvq_f32(v);
X#else
X  v = vaddq_f32(v, vrev64q_f32(v));
X  v = vaddq_f32(v, vcombine_f32(vget_high_f32(v), vget_low_f32(v)));
X  return vgetq_lane_f32(v, 0);
X#endif
X}
X
Xstatic inline
Xfloat
Xglmm_hmin(float32x4_t v) {
X  v = vpmin_f32(vget_low_f32(v), vget_high_f32(v));
X  v = vpmin_f32(v, v);
X  return vget_lane_f32(v, 0);
X}
X
Xstatic inline
Xfloat
Xglmm_hmax(float32x4_t v) {
X  v = vpmax_f32(vget_low_f32(v), vget_high_f32(v));
X  v = vpmax_f32(v, v);
X  return vget_lane_f32(v, 0);
X}
X
Xstatic inline
Xfloat
Xglmm_dot(float32x4_t a, float32x4_t b) {
X  return glmm_hadd(vmulq_f32(a, b));
X}
X
Xstatic inline
Xfloat
Xglmm_norm(float32x4_t a) {
X  return sqrtf(glmm_dot(a, a));
X}
X
Xstatic inline
Xfloat
Xglmm_norm2(float32x4_t a) {
X  return glmm_dot(a, a);
X}
X
Xstatic inline
Xfloat
Xglmm_norm_one(float32x4_t a) {
X  return glmm_hadd(glmm_abs(a));
X}
X
Xstatic inline
Xfloat
Xglmm_norm_inf(float32x4_t a) {
X  return glmm_hmax(glmm_abs(a));
X}
X
X#endif
X#endif /* cglm_simd_arm_h */
998e1f14edb7e60145b29668a1b95898
echo c - cglm/simd/avx
mkdir -p cglm/simd/avx > /dev/null 2>&1
echo x - cglm/simd/avx/mat4.h
sed 's/^X//' >cglm/simd/avx/mat4.h << '38a2bfbfcad1a6f209d7d53eb10fc093'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_mat_simd_avx_h
X#define cglm_mat_simd_avx_h
X#ifdef __AVX__
X
X#include "../../common.h"
X#include "../intrin.h"
X
X#include <immintrin.h>
X
XCGLM_INLINE
Xvoid
Xglm_mat4_mul_avx(mat4 m1, mat4 m2, mat4 dest) {
X  /* D = R * L (Column-Major) */
X
X  __m256 y0, y1, y2, y3, y4, y5, y6, y7, y8, y9;
X
X  y0 = glmm_load256(m2[0]); /* h g f e d c b a */
X  y1 = glmm_load256(m2[2]); /* p o n m l k j i */
X
X  y2 = glmm_load256(m1[0]); /* h g f e d c b a */
X  y3 = glmm_load256(m1[2]); /* p o n m l k j i */
X
X  /* 0x03: 0b00000011 */
X  y4 = _mm256_permute2f128_ps(y2, y2, 0x03); /* d c b a h g f e */
X  y5 = _mm256_permute2f128_ps(y3, y3, 0x03); /* l k j i p o n m */
X
X  /* f f f f a a a a */
X  /* h h h h c c c c */
X  /* e e e e b b b b */
X  /* g g g g d d d d */
X  y6 = _mm256_permutevar_ps(y0, _mm256_set_epi32(1, 1, 1, 1, 0, 0, 0, 0));
X  y7 = _mm256_permutevar_ps(y0, _mm256_set_epi32(3, 3, 3, 3, 2, 2, 2, 2));
X  y8 = _mm256_permutevar_ps(y0, _mm256_set_epi32(0, 0, 0, 0, 1, 1, 1, 1));
X  y9 = _mm256_permutevar_ps(y0, _mm256_set_epi32(2, 2, 2, 2, 3, 3, 3, 3));
X
X  glmm_store256(dest[0],
X                _mm256_add_ps(_mm256_add_ps(_mm256_mul_ps(y2, y6),
X                                            _mm256_mul_ps(y3, y7)),
X                              _mm256_add_ps(_mm256_mul_ps(y4, y8),
X                                            _mm256_mul_ps(y5, y9))));
X
X  /* n n n n i i i i */
X  /* p p p p k k k k */
X  /* m m m m j j j j */
X  /* o o o o l l l l */
X  y6 = _mm256_permutevar_ps(y1, _mm256_set_epi32(1, 1, 1, 1, 0, 0, 0, 0));
X  y7 = _mm256_permutevar_ps(y1, _mm256_set_epi32(3, 3, 3, 3, 2, 2, 2, 2));
X  y8 = _mm256_permutevar_ps(y1, _mm256_set_epi32(0, 0, 0, 0, 1, 1, 1, 1));
X  y9 = _mm256_permutevar_ps(y1, _mm256_set_epi32(2, 2, 2, 2, 3, 3, 3, 3));
X
X  glmm_store256(dest[2],
X                _mm256_add_ps(_mm256_add_ps(_mm256_mul_ps(y2, y6),
X                                            _mm256_mul_ps(y3, y7)),
X                              _mm256_add_ps(_mm256_mul_ps(y4, y8),
X                                            _mm256_mul_ps(y5, y9))));
X}
X
X#endif
X#endif /* cglm_mat_simd_avx_h */
38a2bfbfcad1a6f209d7d53eb10fc093
echo x - cglm/simd/avx/affine.h
sed 's/^X//' >cglm/simd/avx/affine.h << '7da77218b193a8015b6d2103962d5cd0'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_affine_mat_avx_h
X#define cglm_affine_mat_avx_h
X#ifdef __AVX__
X
X#include "../../common.h"
X#include "../intrin.h"
X
X#include <immintrin.h>
X
XCGLM_INLINE
Xvoid
Xglm_mul_avx(mat4 m1, mat4 m2, mat4 dest) {
X  /* D = R * L (Column-Major) */
X
X  __m256 y0, y1, y2, y3, y4, y5, y6, y7, y8, y9;
X
X  y0 = glmm_load256(m2[0]); /* h g f e d c b a */
X  y1 = glmm_load256(m2[2]); /* p o n m l k j i */
X
X  y2 = glmm_load256(m1[0]); /* h g f e d c b a */
X  y3 = glmm_load256(m1[2]); /* p o n m l k j i */
X
X  /* 0x03: 0b00000011 */
X  y4 = _mm256_permute2f128_ps(y2, y2, 0x03); /* d c b a h g f e */
X  y5 = _mm256_permute2f128_ps(y3, y3, 0x03); /* l k j i p o n m */
X
X  /* f f f f a a a a */
X  /* h h h h c c c c */
X  /* e e e e b b b b */
X  /* g g g g d d d d */
X  y6 = _mm256_permutevar_ps(y0, _mm256_set_epi32(1, 1, 1, 1, 0, 0, 0, 0));
X  y7 = _mm256_permutevar_ps(y0, _mm256_set_epi32(3, 3, 3, 3, 2, 2, 2, 2));
X  y8 = _mm256_permutevar_ps(y0, _mm256_set_epi32(0, 0, 0, 0, 1, 1, 1, 1));
X  y9 = _mm256_permutevar_ps(y0, _mm256_set_epi32(2, 2, 2, 2, 3, 3, 3, 3));
X
X  glmm_store256(dest[0],
X                _mm256_add_ps(_mm256_add_ps(_mm256_mul_ps(y2, y6),
X                                            _mm256_mul_ps(y3, y7)),
X                              _mm256_add_ps(_mm256_mul_ps(y4, y8),
X                                            _mm256_mul_ps(y5, y9))));
X
X  /* n n n n i i i i */
X  /* p p p p k k k k */
X  /* m m m m j j j j */
X  /* o o o o l l l l */
X  y6 = _mm256_permutevar_ps(y1, _mm256_set_epi32(1, 1, 1, 1, 0, 0, 0, 0));
X  y7 = _mm256_permutevar_ps(y1, _mm256_set_epi32(3, 3, 3, 3, 2, 2, 2, 2));
X  y8 = _mm256_permutevar_ps(y1, _mm256_set_epi32(0, 0, 0, 0, 1, 1, 1, 1));
X  y9 = _mm256_permutevar_ps(y1, _mm256_set_epi32(2, 2, 2, 2, 3, 3, 3, 3));
X
X  glmm_store256(dest[2],
X                _mm256_add_ps(_mm256_add_ps(_mm256_mul_ps(y2, y6),
X                                            _mm256_mul_ps(y3, y7)),
X                              _mm256_add_ps(_mm256_mul_ps(y4, y8),
X                                            _mm256_mul_ps(y5, y9))));
X}
X
X#endif
X#endif /* cglm_affine_mat_avx_h */
7da77218b193a8015b6d2103962d5cd0
echo c - cglm/simd/neon
mkdir -p cglm/simd/neon > /dev/null 2>&1
echo x - cglm/simd/neon/mat4.h
sed 's/^X//' >cglm/simd/neon/mat4.h << '381ead76b0d2f10d8931ac7bfce21352'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_mat4_neon_h
X#define cglm_mat4_neon_h
X#if defined(__ARM_NEON_FP)
X
X#include "../../common.h"
X#include "../intrin.h"
X
XCGLM_INLINE
Xvoid
Xglm_mat4_mul_neon(mat4 m1, mat4 m2, mat4 dest) {
X  /* D = R * L (Column-Major) */
X  float32x4_t l0, l1, l2, l3, r, d0, d1, d2, d3;
X
X  l0 = vld1q_f32(m2[0]);
X  l1 = vld1q_f32(m2[1]);
X  l2 = vld1q_f32(m2[2]);
X  l3 = vld1q_f32(m2[3]);
X
X  r  = vld1q_f32(m1[0]);
X  d0 = vmulq_lane_f32(r, vget_low_f32(l0), 0);
X  d1 = vmulq_lane_f32(r, vget_low_f32(l1), 0);
X  d2 = vmulq_lane_f32(r, vget_low_f32(l2), 0);
X  d3 = vmulq_lane_f32(r, vget_low_f32(l3), 0);
X
X  r  = vld1q_f32(m1[1]);
X  d0 = vmlaq_lane_f32(d0, r, vget_low_f32(l0), 1);
X  d1 = vmlaq_lane_f32(d1, r, vget_low_f32(l1), 1);
X  d2 = vmlaq_lane_f32(d2, r, vget_low_f32(l2), 1);
X  d3 = vmlaq_lane_f32(d3, r, vget_low_f32(l3), 1);
X
X  r  = vld1q_f32(m1[2]);
X  d0 = vmlaq_lane_f32(d0, r, vget_high_f32(l0), 0);
X  d1 = vmlaq_lane_f32(d1, r, vget_high_f32(l1), 0);
X  d2 = vmlaq_lane_f32(d2, r, vget_high_f32(l2), 0);
X  d3 = vmlaq_lane_f32(d3, r, vget_high_f32(l3), 0);
X
X  r  = vld1q_f32(m1[3]);
X  d0 = vmlaq_lane_f32(d0, r, vget_high_f32(l0), 1);
X  d1 = vmlaq_lane_f32(d1, r, vget_high_f32(l1), 1);
X  d2 = vmlaq_lane_f32(d2, r, vget_high_f32(l2), 1);
X  d3 = vmlaq_lane_f32(d3, r, vget_high_f32(l3), 1);
X
X  vst1q_f32(dest[0], d0);
X  vst1q_f32(dest[1], d1);
X  vst1q_f32(dest[2], d2);
X  vst1q_f32(dest[3], d3);
X}
X
X#endif
X#endif /* cglm_mat4_neon_h */
381ead76b0d2f10d8931ac7bfce21352
echo c - cglm/simd/sse2
mkdir -p cglm/simd/sse2 > /dev/null 2>&1
echo x - cglm/simd/sse2/affine.h
sed 's/^X//' >cglm/simd/sse2/affine.h << '246a5fd039f1c4dd46c2d8586b8d56dc'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_affine_mat_sse2_h
X#define cglm_affine_mat_sse2_h
X#if defined( __SSE__ ) || defined( __SSE2__ )
X
X#include "../../common.h"
X#include "../intrin.h"
X
XCGLM_INLINE
Xvoid
Xglm_mul_sse2(mat4 m1, mat4 m2, mat4 dest) {
X  /* D = R * L (Column-Major) */
X  __m128 l0, l1, l2, l3, r;
X
X  l0 = glmm_load(m1[0]);
X  l1 = glmm_load(m1[1]);
X  l2 = glmm_load(m1[2]);
X  l3 = glmm_load(m1[3]);
X
X  r = glmm_load(m2[0]);
X  glmm_store(dest[0],
X             _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
X                                   _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
X                        _mm_mul_ps(glmm_shuff1x(r, 2), l2)));
X
X  r = glmm_load(m2[1]);
X  glmm_store(dest[1],
X             _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
X                                   _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
X                        _mm_mul_ps(glmm_shuff1x(r, 2), l2)));
X
X  r = glmm_load(m2[2]);
X  glmm_store(dest[2],
X             _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
X                                   _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
X                        _mm_mul_ps(glmm_shuff1x(r, 2), l2)));
X
X  r = glmm_load(m2[3]);
X  glmm_store(dest[3],
X             _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
X                                   _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
X                        _mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 2), l2),
X                                   _mm_mul_ps(glmm_shuff1x(r, 3), l3))));
X}
X
XCGLM_INLINE
Xvoid
Xglm_mul_rot_sse2(mat4 m1, mat4 m2, mat4 dest) {
X  /* D = R * L (Column-Major) */
X  __m128 l0, l1, l2, l3, r;
X
X  l0 = glmm_load(m1[0]);
X  l1 = glmm_load(m1[1]);
X  l2 = glmm_load(m1[2]);
X  l3 = glmm_load(m1[3]);
X
X  r = glmm_load(m2[0]);
X  glmm_store(dest[0],
X             _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
X                                   _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
X                        _mm_mul_ps(glmm_shuff1x(r, 2), l2)));
X
X  r = glmm_load(m2[1]);
X  glmm_store(dest[1],
X             _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
X                                   _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
X                        _mm_mul_ps(glmm_shuff1x(r, 2), l2)));
X
X  r = glmm_load(m2[2]);
X  glmm_store(dest[2],
X             _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
X                                   _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
X                        _mm_mul_ps(glmm_shuff1x(r, 2), l2)));
X
X  glmm_store(dest[3], l3);
X}
X
XCGLM_INLINE
Xvoid
Xglm_inv_tr_sse2(mat4 mat) {
X  __m128 r0, r1, r2, r3, x0, x1;
X
X  r0 = glmm_load(mat[0]);
X  r1 = glmm_load(mat[1]);
X  r2 = glmm_load(mat[2]);
X  r3 = glmm_load(mat[3]);
X  x1 = _mm_set_ps(1.0f, 0.0f, 0.0f, 0.0f);
X
X  _MM_TRANSPOSE4_PS(r0, r1, r2, x1);
X
X  x0 = _mm_add_ps(_mm_mul_ps(r0, glmm_shuff1(r3, 0, 0, 0, 0)),
X                  _mm_mul_ps(r1, glmm_shuff1(r3, 1, 1, 1, 1)));
X  x0 = _mm_add_ps(x0, _mm_mul_ps(r2, glmm_shuff1(r3, 2, 2, 2, 2)));
X  x0 = _mm_xor_ps(x0, _mm_set1_ps(-0.f));
X
X  x0 = _mm_add_ps(x0, x1);
X
X  glmm_store(mat[0], r0);
X  glmm_store(mat[1], r1);
X  glmm_store(mat[2], r2);
X  glmm_store(mat[3], x0);
X}
X
X#endif
X#endif /* cglm_affine_mat_sse2_h */
246a5fd039f1c4dd46c2d8586b8d56dc
echo x - cglm/simd/sse2/mat4.h
sed 's/^X//' >cglm/simd/sse2/mat4.h << '07f8b8c5e0aaa590b3f1a37415518ffb'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_mat_sse_h
X#define cglm_mat_sse_h
X#if defined( __SSE__ ) || defined( __SSE2__ )
X
X#include "../../common.h"
X#include "../intrin.h"
X
X#define glm_mat4_inv_precise_sse2(mat, dest) glm_mat4_inv_sse2(mat, dest)
X
XCGLM_INLINE
Xvoid
Xglm_mat4_scale_sse2(mat4 m, float s) {
X  __m128 x0;
X  x0 = _mm_set1_ps(s);
X
X  glmm_store(m[0], _mm_mul_ps(glmm_load(m[0]), x0));
X  glmm_store(m[1], _mm_mul_ps(glmm_load(m[1]), x0));
X  glmm_store(m[2], _mm_mul_ps(glmm_load(m[2]), x0));
X  glmm_store(m[3], _mm_mul_ps(glmm_load(m[3]), x0));
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat4_transp_sse2(mat4 m, mat4 dest) {
X  __m128 r0, r1, r2, r3;
X
X  r0 = glmm_load(m[0]);
X  r1 = glmm_load(m[1]);
X  r2 = glmm_load(m[2]);
X  r3 = glmm_load(m[3]);
X
X  _MM_TRANSPOSE4_PS(r0, r1, r2, r3);
X
X  glmm_store(dest[0], r0);
X  glmm_store(dest[1], r1);
X  glmm_store(dest[2], r2);
X  glmm_store(dest[3], r3);
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat4_mul_sse2(mat4 m1, mat4 m2, mat4 dest) {
X  /* D = R * L (Column-Major) */
X
X  __m128 l0, l1, l2, l3, r;
X
X  l0 = glmm_load(m1[0]);
X  l1 = glmm_load(m1[1]);
X  l2 = glmm_load(m1[2]);
X  l3 = glmm_load(m1[3]);
X
X  r = glmm_load(m2[0]);
X  glmm_store(dest[0],
X             _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
X                                   _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
X                        _mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 2), l2),
X                                   _mm_mul_ps(glmm_shuff1x(r, 3), l3))));
X  r = glmm_load(m2[1]);
X  glmm_store(dest[1],
X             _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
X                                   _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
X                        _mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 2), l2),
X                                   _mm_mul_ps(glmm_shuff1x(r, 3), l3))));
X  r = glmm_load(m2[2]);
X  glmm_store(dest[2],
X             _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
X                                   _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
X                        _mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 2), l2),
X                                   _mm_mul_ps(glmm_shuff1x(r, 3), l3))));
X
X  r = glmm_load(m2[3]);
X  glmm_store(dest[3],
X             _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
X                                   _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
X                        _mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 2), l2),
X                                   _mm_mul_ps(glmm_shuff1x(r, 3), l3))));
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat4_mulv_sse2(mat4 m, vec4 v, vec4 dest) {
X  __m128 x0, x1, x2;
X
X  x0 = glmm_load(v);
X  x1 = _mm_add_ps(_mm_mul_ps(glmm_load(m[0]), glmm_shuff1x(x0, 0)),
X                  _mm_mul_ps(glmm_load(m[1]), glmm_shuff1x(x0, 1)));
X
X  x2 = _mm_add_ps(_mm_mul_ps(glmm_load(m[2]), glmm_shuff1x(x0, 2)),
X                  _mm_mul_ps(glmm_load(m[3]), glmm_shuff1x(x0, 3)));
X
X  glmm_store(dest, _mm_add_ps(x1, x2));
X}
X
XCGLM_INLINE
Xfloat
Xglm_mat4_det_sse2(mat4 mat) {
X  __m128 r0, r1, r2, r3, x0, x1, x2;
X
X  /* 127 <- 0, [square] det(A) = det(At) */
X  r0 = glmm_load(mat[0]); /* d c b a */
X  r1 = glmm_load(mat[1]); /* h g f e */
X  r2 = glmm_load(mat[2]); /* l k j i */
X  r3 = glmm_load(mat[3]); /* p o n m */
X
X  /*
X   t[1] = j * p - n * l;
X   t[2] = j * o - n * k;
X   t[3] = i * p - m * l;
X   t[4] = i * o - m * k;
X   */
X  x0 = _mm_sub_ps(_mm_mul_ps(glmm_shuff1(r2, 0, 0, 1, 1),
X                             glmm_shuff1(r3, 2, 3, 2, 3)),
X                  _mm_mul_ps(glmm_shuff1(r3, 0, 0, 1, 1),
X                             glmm_shuff1(r2, 2, 3, 2, 3)));
X  /*
X   t[0] = k * p - o * l;
X   t[0] = k * p - o * l;
X   t[5] = i * n - m * j;
X   t[5] = i * n - m * j;
X   */
X  x1 = _mm_sub_ps(_mm_mul_ps(glmm_shuff1(r2, 0, 0, 2, 2),
X                             glmm_shuff1(r3, 1, 1, 3, 3)),
X                  _mm_mul_ps(glmm_shuff1(r3, 0, 0, 2, 2),
X                             glmm_shuff1(r2, 1, 1, 3, 3)));
X
X  /*
X     a * (f * t[0] - g * t[1] + h * t[2])
X   - b * (e * t[0] - g * t[3] + h * t[4])
X   + c * (e * t[1] - f * t[3] + h * t[5])
X   - d * (e * t[2] - f * t[4] + g * t[5])
X   */
X  x2 = _mm_sub_ps(_mm_mul_ps(glmm_shuff1(r1, 0, 0, 0, 1),
X                             _mm_shuffle_ps(x1, x0, _MM_SHUFFLE(1, 0, 0, 0))),
X                  _mm_mul_ps(glmm_shuff1(r1, 1, 1, 2, 2),
X                             glmm_shuff1(x0, 3, 2, 2, 0)));
X
X  x2 = _mm_add_ps(x2,
X                  _mm_mul_ps(glmm_shuff1(r1, 2, 3, 3, 3),
X                             _mm_shuffle_ps(x0, x1, _MM_SHUFFLE(2, 2, 3, 1))));
X  x2 = _mm_xor_ps(x2, _mm_set_ps(-0.f, 0.f, -0.f, 0.f));
X
X  x0 = _mm_mul_ps(r0, x2);
X  x0 = _mm_add_ps(x0, glmm_shuff1(x0, 0, 1, 2, 3));
X  x0 = _mm_add_ps(x0, glmm_shuff1(x0, 1, 3, 3, 1));
X
X  return _mm_cvtss_f32(x0);
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat4_inv_fast_sse2(mat4 mat, mat4 dest) {
X  __m128 r0, r1, r2, r3,
X         v0, v1, v2, v3,
X         t0, t1, t2, t3, t4, t5,
X         x0, x1, x2, x3, x4, x5, x6, x7;
X
X  /* 127 <- 0 */
X  r0 = glmm_load(mat[0]); /* d c b a */
X  r1 = glmm_load(mat[1]); /* h g f e */
X  r2 = glmm_load(mat[2]); /* l k j i */
X  r3 = glmm_load(mat[3]); /* p o n m */
X
X  x0 = _mm_shuffle_ps(r2, r3, _MM_SHUFFLE(3, 2, 3, 2));  /* p o l k */
X  x1 = glmm_shuff1(x0, 1, 3, 3, 3);                      /* l p p p */
X  x2 = glmm_shuff1(x0, 0, 2, 2, 2);                      /* k o o o */
X  x0 = _mm_shuffle_ps(r2, r1, _MM_SHUFFLE(3, 3, 3, 3));  /* h h l l */
X  x3 = _mm_shuffle_ps(r2, r1, _MM_SHUFFLE(2, 2, 2, 2));  /* g g k k */
X
X  /* t1[0] = k * p - o * l;
X     t1[0] = k * p - o * l;
X     t2[0] = g * p - o * h;
X     t3[0] = g * l - k * h; */
X  t0 = _mm_sub_ps(_mm_mul_ps(x3, x1), _mm_mul_ps(x2, x0));
X
X  x4 = _mm_shuffle_ps(r2, r3, _MM_SHUFFLE(2, 1, 2, 1)); /* o n k j */
X  x4 = glmm_shuff1(x4, 0, 2, 2, 2);                     /* j n n n */
X  x5 = _mm_shuffle_ps(r2, r1, _MM_SHUFFLE(1, 1, 1, 1)); /* f f j j */
X
X  /* t1[1] = j * p - n * l;
X     t1[1] = j * p - n * l;
X     t2[1] = f * p - n * h;
X     t3[1] = f * l - j * h; */
X  t1 = _mm_sub_ps(_mm_mul_ps(x5, x1), _mm_mul_ps(x4, x0));
X
X  /* t1[2] = j * o - n * k
X     t1[2] = j * o - n * k;
X     t2[2] = f * o - n * g;
X     t3[2] = f * k - j * g; */
X  t2 = _mm_sub_ps(_mm_mul_ps(x5, x2), _mm_mul_ps(x4, x3));
X
X  x6 = _mm_shuffle_ps(r2, r1, _MM_SHUFFLE(0, 0, 0, 0)); /* e e i i */
X  x7 = glmm_shuff2(r3, r2, 0, 0, 0, 0, 2, 0, 0, 0);     /* i m m m */
X
X  /* t1[3] = i * p - m * l;
X     t1[3] = i * p - m * l;
X     t2[3] = e * p - m * h;
X     t3[3] = e * l - i * h; */
X  t3 = _mm_sub_ps(_mm_mul_ps(x6, x1), _mm_mul_ps(x7, x0));
X
X  /* t1[4] = i * o - m * k;
X     t1[4] = i * o - m * k;
X     t2[4] = e * o - m * g;
X     t3[4] = e * k - i * g; */
X  t4 = _mm_sub_ps(_mm_mul_ps(x6, x2), _mm_mul_ps(x7, x3));
X
X  /* t1[5] = i * n - m * j;
X     t1[5] = i * n - m * j;
X     t2[5] = e * n - m * f;
X     t3[5] = e * j - i * f; */
X  t5 = _mm_sub_ps(_mm_mul_ps(x6, x4), _mm_mul_ps(x7, x5));
X
X  x0 = glmm_shuff2(r1, r0, 0, 0, 0, 0, 2, 2, 2, 0); /* a a a e */
X  x1 = glmm_shuff2(r1, r0, 1, 1, 1, 1, 2, 2, 2, 0); /* b b b f */
X  x2 = glmm_shuff2(r1, r0, 2, 2, 2, 2, 2, 2, 2, 0); /* c c c g */
X  x3 = glmm_shuff2(r1, r0, 3, 3, 3, 3, 2, 2, 2, 0); /* d d d h */
X
X  /*
X   dest[0][0] =  f * t1[0] - g * t1[1] + h * t1[2];
X   dest[0][1] =-(b * t1[0] - c * t1[1] + d * t1[2]);
X   dest[0][2] =  b * t2[0] - c * t2[1] + d * t2[2];
X   dest[0][3] =-(b * t3[0] - c * t3[1] + d * t3[2]); */
X  v0 = _mm_add_ps(_mm_mul_ps(x3, t2),
X                  _mm_sub_ps(_mm_mul_ps(x1, t0),
X                             _mm_mul_ps(x2, t1)));
X  v0 = _mm_xor_ps(v0, _mm_set_ps(-0.f, 0.f, -0.f, 0.f));
X
X  /*
X   dest[1][0] =-(e * t1[0] - g * t1[3] + h * t1[4]);
X   dest[1][1] =  a * t1[0] - c * t1[3] + d * t1[4];
X   dest[1][2] =-(a * t2[0] - c * t2[3] + d * t2[4]);
X   dest[1][3] =  a * t3[0] - c * t3[3] + d * t3[4]; */
X  v1 = _mm_add_ps(_mm_mul_ps(x3, t4),
X                  _mm_sub_ps(_mm_mul_ps(x0, t0),
X                             _mm_mul_ps(x2, t3)));
X  v1 = _mm_xor_ps(v1, _mm_set_ps(0.f, -0.f, 0.f, -0.f));
X
X  /*
X   dest[2][0] =  e * t1[1] - f * t1[3] + h * t1[5];
X   dest[2][1] =-(a * t1[1] - b * t1[3] + d * t1[5]);
X   dest[2][2] =  a * t2[1] - b * t2[3] + d * t2[5];
X   dest[2][3] =-(a * t3[1] - b * t3[3] + d * t3[5]);*/
X  v2 = _mm_add_ps(_mm_mul_ps(x3, t5),
X                  _mm_sub_ps(_mm_mul_ps(x0, t1),
X                             _mm_mul_ps(x1, t3)));
X  v2 = _mm_xor_ps(v2, _mm_set_ps(-0.f, 0.f, -0.f, 0.f));
X
X  /*
X   dest[3][0] =-(e * t1[2] - f * t1[4] + g * t1[5]);
X   dest[3][1] =  a * t1[2] - b * t1[4] + c * t1[5];
X   dest[3][2] =-(a * t2[2] - b * t2[4] + c * t2[5]);
X   dest[3][3] =  a * t3[2] - b * t3[4] + c * t3[5]; */
X  v3 = _mm_add_ps(_mm_mul_ps(x2, t5),
X                  _mm_sub_ps(_mm_mul_ps(x0, t2),
X                             _mm_mul_ps(x1, t4)));
X  v3 = _mm_xor_ps(v3, _mm_set_ps(0.f, -0.f, 0.f, -0.f));
X
X  /* determinant */
X  x0 = _mm_shuffle_ps(v0, v1, _MM_SHUFFLE(0, 0, 0, 0));
X  x1 = _mm_shuffle_ps(v2, v3, _MM_SHUFFLE(0, 0, 0, 0));
X  x0 = _mm_shuffle_ps(x0, x1, _MM_SHUFFLE(2, 0, 2, 0));
X
X  x0 = _mm_mul_ps(x0, r0);
X  x0 = _mm_add_ps(x0, glmm_shuff1(x0, 0, 1, 2, 3));
X  x0 = _mm_add_ps(x0, glmm_shuff1(x0, 1, 0, 0, 1));
X  x0 = _mm_rcp_ps(x0);
X
X  glmm_store(dest[0], _mm_mul_ps(v0, x0));
X  glmm_store(dest[1], _mm_mul_ps(v1, x0));
X  glmm_store(dest[2], _mm_mul_ps(v2, x0));
X  glmm_store(dest[3], _mm_mul_ps(v3, x0));
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat4_inv_sse2(mat4 mat, mat4 dest) {
X  __m128 r0, r1, r2, r3,
X         v0, v1, v2, v3,
X         t0, t1, t2, t3, t4, t5,
X         x0, x1, x2, x3, x4, x5, x6, x7;
X
X  /* 127 <- 0 */
X  r0 = glmm_load(mat[0]); /* d c b a */
X  r1 = glmm_load(mat[1]); /* h g f e */
X  r2 = glmm_load(mat[2]); /* l k j i */
X  r3 = glmm_load(mat[3]); /* p o n m */
X
X  x0 = _mm_shuffle_ps(r2, r3, _MM_SHUFFLE(3, 2, 3, 2));  /* p o l k */
X  x1 = glmm_shuff1(x0, 1, 3, 3, 3);                      /* l p p p */
X  x2 = glmm_shuff1(x0, 0, 2, 2, 2);                      /* k o o o */
X  x0 = _mm_shuffle_ps(r2, r1, _MM_SHUFFLE(3, 3, 3, 3));  /* h h l l */
X  x3 = _mm_shuffle_ps(r2, r1, _MM_SHUFFLE(2, 2, 2, 2));  /* g g k k */
X
X  /* t1[0] = k * p - o * l;
X     t1[0] = k * p - o * l;
X     t2[0] = g * p - o * h;
X     t3[0] = g * l - k * h; */
X  t0 = _mm_sub_ps(_mm_mul_ps(x3, x1), _mm_mul_ps(x2, x0));
X
X  x4 = _mm_shuffle_ps(r2, r3, _MM_SHUFFLE(2, 1, 2, 1)); /* o n k j */
X  x4 = glmm_shuff1(x4, 0, 2, 2, 2);                     /* j n n n */
X  x5 = _mm_shuffle_ps(r2, r1, _MM_SHUFFLE(1, 1, 1, 1)); /* f f j j */
X
X  /* t1[1] = j * p - n * l;
X     t1[1] = j * p - n * l;
X     t2[1] = f * p - n * h;
X     t3[1] = f * l - j * h; */
X  t1 = _mm_sub_ps(_mm_mul_ps(x5, x1), _mm_mul_ps(x4, x0));
X
X  /* t1[2] = j * o - n * k
X     t1[2] = j * o - n * k;
X     t2[2] = f * o - n * g;
X     t3[2] = f * k - j * g; */
X  t2 = _mm_sub_ps(_mm_mul_ps(x5, x2), _mm_mul_ps(x4, x3));
X
X  x6 = _mm_shuffle_ps(r2, r1, _MM_SHUFFLE(0, 0, 0, 0)); /* e e i i */
X  x7 = glmm_shuff2(r3, r2, 0, 0, 0, 0, 2, 0, 0, 0);     /* i m m m */
X
X  /* t1[3] = i * p - m * l;
X     t1[3] = i * p - m * l;
X     t2[3] = e * p - m * h;
X     t3[3] = e * l - i * h; */
X  t3 = _mm_sub_ps(_mm_mul_ps(x6, x1), _mm_mul_ps(x7, x0));
X
X  /* t1[4] = i * o - m * k;
X     t1[4] = i * o - m * k;
X     t2[4] = e * o - m * g;
X     t3[4] = e * k - i * g; */
X  t4 = _mm_sub_ps(_mm_mul_ps(x6, x2), _mm_mul_ps(x7, x3));
X
X  /* t1[5] = i * n - m * j;
X     t1[5] = i * n - m * j;
X     t2[5] = e * n - m * f;
X     t3[5] = e * j - i * f; */
X  t5 = _mm_sub_ps(_mm_mul_ps(x6, x4), _mm_mul_ps(x7, x5));
X
X  x0 = glmm_shuff2(r1, r0, 0, 0, 0, 0, 2, 2, 2, 0); /* a a a e */
X  x1 = glmm_shuff2(r1, r0, 1, 1, 1, 1, 2, 2, 2, 0); /* b b b f */
X  x2 = glmm_shuff2(r1, r0, 2, 2, 2, 2, 2, 2, 2, 0); /* c c c g */
X  x3 = glmm_shuff2(r1, r0, 3, 3, 3, 3, 2, 2, 2, 0); /* d d d h */
X
X  /*
X   dest[0][0] =  f * t1[0] - g * t1[1] + h * t1[2];
X   dest[0][1] =-(b * t1[0] - c * t1[1] + d * t1[2]);
X   dest[0][2] =  b * t2[0] - c * t2[1] + d * t2[2];
X   dest[0][3] =-(b * t3[0] - c * t3[1] + d * t3[2]); */
X  v0 = _mm_add_ps(_mm_mul_ps(x3, t2),
X                  _mm_sub_ps(_mm_mul_ps(x1, t0),
X                             _mm_mul_ps(x2, t1)));
X  v0 = _mm_xor_ps(v0, _mm_set_ps(-0.f, 0.f, -0.f, 0.f));
X
X  /*
X   dest[1][0] =-(e * t1[0] - g * t1[3] + h * t1[4]);
X   dest[1][1] =  a * t1[0] - c * t1[3] + d * t1[4];
X   dest[1][2] =-(a * t2[0] - c * t2[3] + d * t2[4]);
X   dest[1][3] =  a * t3[0] - c * t3[3] + d * t3[4]; */
X  v1 = _mm_add_ps(_mm_mul_ps(x3, t4),
X                  _mm_sub_ps(_mm_mul_ps(x0, t0),
X                             _mm_mul_ps(x2, t3)));
X  v1 = _mm_xor_ps(v1, _mm_set_ps(0.f, -0.f, 0.f, -0.f));
X
X  /*
X   dest[2][0] =  e * t1[1] - f * t1[3] + h * t1[5];
X   dest[2][1] =-(a * t1[1] - b * t1[3] + d * t1[5]);
X   dest[2][2] =  a * t2[1] - b * t2[3] + d * t2[5];
X   dest[2][3] =-(a * t3[1] - b * t3[3] + d * t3[5]);*/
X  v2 = _mm_add_ps(_mm_mul_ps(x3, t5),
X                  _mm_sub_ps(_mm_mul_ps(x0, t1),
X                             _mm_mul_ps(x1, t3)));
X  v2 = _mm_xor_ps(v2, _mm_set_ps(-0.f, 0.f, -0.f, 0.f));
X
X  /*
X   dest[3][0] =-(e * t1[2] - f * t1[4] + g * t1[5]);
X   dest[3][1] =  a * t1[2] - b * t1[4] + c * t1[5];
X   dest[3][2] =-(a * t2[2] - b * t2[4] + c * t2[5]);
X   dest[3][3] =  a * t3[2] - b * t3[4] + c * t3[5]; */
X  v3 = _mm_add_ps(_mm_mul_ps(x2, t5),
X                  _mm_sub_ps(_mm_mul_ps(x0, t2),
X                             _mm_mul_ps(x1, t4)));
X  v3 = _mm_xor_ps(v3, _mm_set_ps(0.f, -0.f, 0.f, -0.f));
X
X  /* determinant */
X  x0 = _mm_shuffle_ps(v0, v1, _MM_SHUFFLE(0, 0, 0, 0));
X  x1 = _mm_shuffle_ps(v2, v3, _MM_SHUFFLE(0, 0, 0, 0));
X  x0 = _mm_shuffle_ps(x0, x1, _MM_SHUFFLE(2, 0, 2, 0));
X
X  x0 = _mm_mul_ps(x0, r0);
X  x0 = _mm_add_ps(x0, glmm_shuff1(x0, 0, 1, 2, 3));
X  x0 = _mm_add_ps(x0, glmm_shuff1(x0, 1, 0, 0, 1));
X  x0 = _mm_div_ps(_mm_set1_ps(1.0f), x0);
X
X  glmm_store(dest[0], _mm_mul_ps(v0, x0));
X  glmm_store(dest[1], _mm_mul_ps(v1, x0));
X  glmm_store(dest[2], _mm_mul_ps(v2, x0));
X  glmm_store(dest[3], _mm_mul_ps(v3, x0));
X}
X
X#endif
X#endif /* cglm_mat_sse_h */
07f8b8c5e0aaa590b3f1a37415518ffb
echo x - cglm/simd/sse2/mat3.h
sed 's/^X//' >cglm/simd/sse2/mat3.h << '0f164d334a0cb2dfb8db09d8489abc86'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_mat3_sse_h
X#define cglm_mat3_sse_h
X#if defined( __SSE__ ) || defined( __SSE2__ )
X
X#include "../../common.h"
X#include "../intrin.h"
X
XCGLM_INLINE
Xvoid
Xglm_mat3_mul_sse2(mat3 m1, mat3 m2, mat3 dest) {
X  __m128 l0, l1, l2;
X  __m128 r0, r1, r2;
X  __m128 x0, x1, x2;
X
X  l0 = _mm_loadu_ps(m1[0]);
X  l1 = _mm_loadu_ps(&m1[1][1]);
X  l2 = _mm_set1_ps(m1[2][2]);
X
X  r0 = _mm_loadu_ps(m2[0]);
X  r1 = _mm_loadu_ps(&m2[1][1]);
X  r2 = _mm_set1_ps(m2[2][2]);
X
X  x1 = glmm_shuff2(l0, l1, 1, 0, 3, 3, 0, 3, 2, 0);
X  x2 = glmm_shuff2(l1, l2, 0, 0, 3, 2, 0, 2, 1, 0);
X
X  x0 = _mm_add_ps(_mm_mul_ps(glmm_shuff1(l0, 0, 2, 1, 0),
X                             glmm_shuff1(r0, 3, 0, 0, 0)),
X                  _mm_mul_ps(x1, glmm_shuff2(r0, r1, 0, 0, 1, 1, 2, 0, 0, 0)));
X
X  x0 = _mm_add_ps(x0,
X                  _mm_mul_ps(x2, glmm_shuff2(r0, r1, 1, 1, 2, 2, 2, 0, 0, 0)));
X
X  _mm_storeu_ps(dest[0], x0);
X
X  x0 = _mm_add_ps(_mm_mul_ps(glmm_shuff1(l0, 1, 0, 2, 1),
X                             _mm_shuffle_ps(r0, r1, _MM_SHUFFLE(2, 2, 3, 3))),
X                  _mm_mul_ps(glmm_shuff1(x1, 1, 0, 2, 1),
X                             glmm_shuff1(r1, 3, 3, 0, 0)));
X
X  x0 = _mm_add_ps(x0,
X                  _mm_mul_ps(glmm_shuff1(x2, 1, 0, 2, 1),
X                             _mm_shuffle_ps(r1, r2, _MM_SHUFFLE(0, 0, 1, 1))));
X
X  _mm_storeu_ps(&dest[1][1], x0);
X
X  dest[2][2] = m1[0][2] * m2[2][0]
X             + m1[1][2] * m2[2][1]
X             + m1[2][2] * m2[2][2];
X}
X
X#endif
X#endif /* cglm_mat3_sse_h */
0f164d334a0cb2dfb8db09d8489abc86
echo x - cglm/simd/sse2/quat.h
sed 's/^X//' >cglm/simd/sse2/quat.h << '4c27eba24ad06de2a67fc455944323ba'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_quat_simd_h
X#define cglm_quat_simd_h
X#if defined( __SSE__ ) || defined( __SSE2__ )
X
X#include "../../common.h"
X#include "../intrin.h"
X
XCGLM_INLINE
Xvoid
Xglm_quat_mul_sse2(versor p, versor q, versor dest) {
X  /*
X   + (a1 b2 + b1 a2 + c1 d2 − d1 c2)i
X   + (a1 c2 − b1 d2 + c1 a2 + d1 b2)j
X   + (a1 d2 + b1 c2 − c1 b2 + d1 a2)k
X     a1 a2 − b1 b2 − c1 c2 − d1 d2
X   */
X
X  __m128 xp, xq, x0, r;
X
X  xp = glmm_load(p); /* 3 2 1 0 */
X  xq = glmm_load(q);
X
X  r  = _mm_mul_ps(glmm_shuff1x(xp, 3), xq);
X
X  x0 = _mm_xor_ps(glmm_shuff1x(xp, 0), _mm_set_ps(-0.f, 0.f, -0.f, 0.f));
X  r  = _mm_add_ps(r, _mm_mul_ps(x0, glmm_shuff1(xq, 0, 1, 2, 3)));
X
X  x0 = _mm_xor_ps(glmm_shuff1x(xp, 1), _mm_set_ps(-0.f, -0.f, 0.f, 0.f));
X  r  = _mm_add_ps(r, _mm_mul_ps(x0, glmm_shuff1(xq, 1, 0, 3, 2)));
X
X  x0 = _mm_xor_ps(glmm_shuff1x(xp, 2), _mm_set_ps(-0.f, 0.f, 0.f, -0.f));
X  r  = _mm_add_ps(r, _mm_mul_ps(x0, glmm_shuff1(xq, 2, 3, 0, 1)));
X
X  glmm_store(dest, r);
X}
X
X
X#endif
X#endif /* cglm_quat_simd_h */
4c27eba24ad06de2a67fc455944323ba
echo c - cglm/struct
mkdir -p cglm/struct > /dev/null 2>&1
echo x - cglm/struct/mat4.h
sed 's/^X//' >cglm/struct/mat4.h << '70d9775a551f5d6f28b21cec23b6874e'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*!
X * Most of functions in this header are optimized manually with SIMD
X * if available. You dont need to call/incude SIMD headers manually
X */
X
X/*
X Macros:
X   GLMS_MAT4_IDENTITY_INIT
X   GLMS_MAT4_ZERO_INIT
X   GLMS_MAT4_IDENTITY
X   GLMS_MAT4_ZERO
X
X Functions:
X   CGLM_INLINE mat4s   glms_mat4_ucopy(mat4s mat);
X   CGLM_INLINE mat4s   glms_mat4_copy(mat4s mat);
X   CGLM_INLINE mat4s   glms_mat4_identity(void);
X   CGLM_INLINE void    glms_mat4_identity_array(mat4s * __restrict mat, size_t count);
X   CGLM_INLINE mat4s   glms_mat4_zero(void);
X   CGLM_INLINE mat3s   glms_mat4_pick3(mat4s mat);
X   CGLM_INLINE mat3s   glms_mat4_pick3t(mat4s mat);
X   CGLM_INLINE mat4s   glms_mat4_ins3(mat3s mat);
X   CGLM_INLINE mat4s   glms_mat4_mul(mat4s m1, mat4s m2);
X   CGLM_INLINE mat4s   glms_mat4_mulN(mat4s * __restrict matrices[], uint32_t len);
X   CGLM_INLINE vec4s   glms_mat4_mulv(mat4s m, vec4s v);
X   CGLM_INLINE float   glms_mat4_trace(mat4s m);
X   CGLM_INLINE float   glms_mat4_trace3(mat4s m);
X   CGLM_INLINE versors glms_mat4_quat(mat4s m);
X   CGLM_INLINE vec3s   glms_mat4_mulv3(mat4s m, vec3s v, float last);
X   CGLM_INLINE mat4s   glms_mat4_transpose(mat4s m);
X   CGLM_INLINE mat4s   glms_mat4_scale_p(mat4s m, float s);
X   CGLM_INLINE mat4s   glms_mat4_scale(mat4s m, float s);
X   CGLM_INLINE float   glms_mat4_det(mat4s mat);
X   CGLM_INLINE mat4s   glms_mat4_inv(mat4s mat);
X   CGLM_INLINE mat4s   glms_mat4_inv_fast(mat4s mat);
X   CGLM_INLINE mat4s   glms_mat4_swap_col(mat4s mat, int col1, int col2);
X   CGLM_INLINE mat4s   glms_mat4_swap_row(mat4s mat, int row1, int row2);
X   CGLM_INLINE float   glms_mat4_rmc(vec4s r, mat4s m, vec4s c);
X */
X
X#ifndef cglms_mat4s_h
X#define cglms_mat4s_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../mat4.h"
X#include "vec4.h"
X#include "vec3.h"
X
X#define GLMS_MAT4_IDENTITY_INIT  {GLM_MAT4_IDENTITY_INIT}
X#define GLMS_MAT4_ZERO_INIT      {GLM_MAT4_ZERO_INIT}
X
X/* for C only */
X#define GLMS_MAT4_IDENTITY ((mat4s)GLMS_MAT4_IDENTITY_INIT)
X#define GLMS_MAT4_ZERO     ((mat4s)GLMS_MAT4_ZERO_INIT)
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * matrix may not be aligned, u stands for unaligned, this may be useful when
X * copying a matrix from external source e.g. asset importer...
X *
X * @param[in]  mat  source
X * @returns         destination
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_ucopy(mat4s mat) {
X  mat4s r;
X  glm_mat4_ucopy(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * @param[in]  mat  source
X * @returns         destination
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_copy(mat4s mat) {
X  mat4s r;
X  glm_mat4_copy(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief make given matrix identity. It is identical with below, 
X *        but it is more easy to do that with this func especially for members
X *        e.g. glm_mat4_identity(aStruct->aMatrix);
X *
X * @code
X * glm_mat4_copy(GLM_MAT4_IDENTITY, mat); // C only
X *
X * // or
X * mat4 mat = GLM_MAT4_IDENTITY_INIT;
X * @endcode
X *
X * @retuns  destination
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_identity(void) {
X  mat4s r;
X  glm_mat4_identity(r.raw);
X  return r;
X}
X
X/*!
X * @brief make given matrix array's each element identity matrix
X *
X * @param[in, out]  mat   matrix array (must be aligned (16/32)
X *                        if alignment is not disabled)
X *
X * @param[in]       count count of matrices
X */
XCGLM_INLINE
Xvoid
Xglms_mat4_identity_array(mat4s * __restrict mat, size_t count) {
X  CGLM_ALIGN_MAT mat4s t = GLMS_MAT4_IDENTITY_INIT;
X  size_t i;
X
X  for (i = 0; i < count; i++) {
X    glm_mat4_copy(t.raw, mat[i].raw);
X  }
X}
X
X/*!
X * @brief make given matrix zero.
X *
X * @returns  matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_zero(void) {
X  mat4s r;
X  glm_mat4_zero(r.raw);
X  return r;
X}
X
X/*!
X * @brief copy upper-left of mat4 to mat3
X *
X * @param[in]  mat  source
X * @returns         destination
X */
XCGLM_INLINE
Xmat3s
Xglms_mat4_pick3(mat4s mat) {
X  mat3s r;
X  glm_mat4_pick3(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief copy upper-left of mat4 to mat3 (transposed)
X *
X * the postfix t stands for transpose
X *
X * @param[in]  mat  source
X * @returns         destination
X */
XCGLM_INLINE
Xmat3s
Xglms_mat4_pick3t(mat4s mat) {
X  mat3s r;
X  glm_mat4_pick3t(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief copy mat3 to mat4's upper-left
X *
X * @param[in]  mat  source
X * @returns         destination
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_ins3(mat3s mat) {
X  mat4s r;
X  glm_mat4_ins3(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * m1, m2 and dest matrices can be same matrix, it is possible to write this:
X *
X * @code
X * mat4 m = GLM_MAT4_IDENTITY_INIT;
X * glm_mat4_mul(m, m, m);
X * @endcode
X *
X * @param[in]  m1   left matrix
X * @param[in]  m2   right matrix
X * @returns         destination matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_mul(mat4s m1, mat4s m2) {
X  mat4s r;
X  glm_mat4_mul(m1.raw, m2.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief mupliply N mat4 matrices and store result in dest
X *
X * this function lets you multiply multiple (more than two or more...) matrices
X * <br><br>multiplication will be done in loop, this may reduce instructions
X * size but if <b>len</b> is too small then compiler may unroll whole loop,
X * usage:
X * @code
X * mat m1, m2, m3, m4, res;
X *
X * res = glm_mat4_mulN((mat4 *[]){&m1, &m2, &m3, &m4}, 4);
X * @endcode
X *
X * @warning matrices parameter is pointer array not mat4 array!
X *
X * @param[in]  matrices mat4 * array
X * @param[in]  len      matrices count
X * @returns             result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_mulN(mat4s * __restrict matrices[], uint32_t len) {
X  CGLM_ALIGN_MAT mat4s r = GLMS_MAT4_IDENTITY_INIT;
X  size_t i;
X
X  for (i = 0; i < len; i++) {
X    r = glms_mat4_mul(r, *matrices[i]);
X  }
X  
X  return r;
X}
X
X/*!
X * @brief multiply mat4 with vec4 (column vector) and store in dest vector
X *
X * @param[in]  m    mat4 (left)
X * @param[in]  v    vec4 (right, column vector)
X * @returns         vec4 (result, column vector)
X */
XCGLM_INLINE
Xvec4s
Xglms_mat4_mulv(mat4s m, vec4s v) {
X  vec4s r;
X  glm_mat4_mulv(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief trace of matrix
X *
X * sum of the elements on the main diagonal from upper left to the lower right
X *
X * @param[in]  m matrix
X */
XCGLM_INLINE
Xfloat
Xglms_mat4_trace(mat4s m) {
X  return glm_mat4_trace(m.raw);
X}
X
X/*!
X * @brief trace of matrix (rotation part)
X *
X * sum of the elements on the main diagonal from upper left to the lower right
X *
X * @param[in]  m matrix
X */
XCGLM_INLINE
Xfloat
Xglms_mat4_trace3(mat4s m) {
X  return glm_mat4_trace3(m.raw);
X}
X
X/*!
X * @brief convert mat4's rotation part to quaternion
X *
X * @param[in]  m    affine matrix
X * @returns         destination quaternion
X */
XCGLM_INLINE
Xversors
Xglms_mat4_quat(mat4s m) {
X  versors r;
X  glm_mat4_quat(m.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply vector with mat4
X *
X * @param[in]  m    mat4(affine transform)
X * @param[in]  v    vec3
X * @param[in]  last 4th item to make it vec4
X * @returns         result vector (vec3)
X */
XCGLM_INLINE
Xvec3s
Xglms_mat4_mulv3(mat4s m, vec3s v, float last) {
X  vec3s r;
X  glm_mat4_mulv3(m.raw, v.raw, last, r.raw);
X  return r;
X}
X
X/*!
X * @brief tranpose mat4 and store result in same matrix
X *
X * @param[in] m source
X * @returns     result
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_transpose(mat4s m) {
X  glm_mat4_transpose(m.raw);
X  return m;
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix without simd optimization
X *
X * multiply matrix with scalar
X *
X * @param[in] m matrix
X * @param[in] s scalar
X * @returns     matrix    
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_scale_p(mat4s m, float s) {
X  glm_mat4_scale_p(m.raw, s);
X  return m;
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in] m matrix
X * @param[in] s scalar
X * @returns     matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_scale(mat4s m, float s) {
X  glm_mat4_scale(m.raw, s);
X  return m;
X}
X
X/*!
X * @brief mat4 determinant
X *
X * @param[in] mat matrix
X *
X * @return determinant
X */
XCGLM_INLINE
Xfloat
Xglms_mat4_det(mat4s mat) {
X  return glm_mat4_det(mat.raw);
X}
X
X/*!
X * @brief inverse mat4 and store in dest
X *
X * @param[in]  mat  matrix
X * @returns         inverse matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_inv(mat4s mat) {
X  mat4s r;
X  glm_mat4_inv(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief inverse mat4 and store in dest
X *
X * this func uses reciprocal approximation without extra corrections
X * e.g Newton-Raphson. this should work faster than normal,
X * to get more precise use glm_mat4_inv version.
X *
X * NOTE: You will lose precision, glm_mat4_inv is more accurate
X *
X * @param[in]  mat  matrix
X * @returns         inverse matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_inv_fast(mat4s mat) {
X  mat4s r;
X  glm_mat4_inv_fast(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief swap two matrix columns
X *
X * @param[in] mat  matrix
X * @param[in] col1 col1
X * @param[in] col2 col2
X * @returns        matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_swap_col(mat4s mat, int col1, int col2) {
X  glm_mat4_swap_col(mat.raw, col1, col2);
X  return mat;
X}
X
X/*!
X * @brief swap two matrix rows
X *
X * @param[in] mat  matrix
X * @param[in] row1 row1
X * @param[in] row2 row2
X * @returns        matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_swap_row(mat4s mat, int row1, int row2) {
X  glm_mat4_swap_row(mat.raw, row1, row2);
X  return mat;
X}
X
X/*!
X * @brief helper for  R (row vector) * M (matrix) * C (column vector)
X *
X * rmc stands for Row * Matrix * Column
X *
X * the result is scalar because R * M = Matrix1x4 (row vector),
X * then Matrix1x4 * Vec4 (column vector) = Matrix1x1 (Scalar)
X *
X * @param[in]  r   row vector or matrix1x4
X * @param[in]  m   matrix4x4
X * @param[in]  c   column vector or matrix4x1
X *
X * @return scalar value e.g. B(s)
X */
XCGLM_INLINE
Xfloat
Xglms_mat4_rmc(vec4s r, mat4s m, vec4s c) {
X  return glm_mat4_rmc(r.raw, m.raw, c.raw);
X}
X
X#endif /* cglms_mat4s_h */
70d9775a551f5d6f28b21cec23b6874e
echo x - cglm/struct/mat3.h
sed 's/^X//' >cglm/struct/mat3.h << '1a123a2ad7db2666d2dbb9fecacecc2c'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLMS_MAT3_IDENTITY_INIT
X   GLMS_MAT3_ZERO_INIT
X   GLMS_MAT3_IDENTITY
X   GLMS_MAT3_ZERO
X
X Functions:
X   CGLM_INLINE mat3s  glms_mat3_copy(mat3s mat);
X   CGLM_INLINE mat3s  glms_mat3_identity(void);
X   CGLM_INLINE void   glms_mat3_identity_array(mat3s * __restrict mat, size_t count);
X   CGLM_INLINE mat3s  glms_mat3_zero(void);
X   CGLM_INLINE mat3s  glms_mat3_mul(mat3s m1, mat3s m2);
X   CGLM_INLINE ma3s   glms_mat3_transpose(mat3s m);
X   CGLM_INLINE vec3s  glms_mat3_mulv(mat3s m, vec3s v);
X   CGLM_INLINE float  glms_mat3_trace(mat3s m);
X   CGLM_INLINE versor glms_mat3_quat(mat3s m);
X   CGLM_INLINE mat3s  glms_mat3_scale(mat3s m, float s);
X   CGLM_INLINE float  glms_mat3_det(mat3s mat);
X   CGLM_INLINE mat3s  glms_mat3_inv(mat3s mat);
X   CGLM_INLINE mat3s  glms_mat3_swap_col(mat3s mat, int col1, int col2);
X   CGLM_INLINE mat3s  glms_mat3_swap_row(mat3s mat, int row1, int row2);
X   CGLM_INLINE float  glms_mat3_rmc(vec3s r, mat3s m, vec3s c);
X */
X
X#ifndef cglms_mat3s_h
X#define cglms_mat3s_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../mat3.h"
X#include "vec3.h"
X
X#define GLMS_MAT3_IDENTITY_INIT  {GLM_MAT3_IDENTITY_INIT}
X#define GLMS_MAT3_ZERO_INIT      {GLM_MAT3_ZERO_INIT}
X
X/* for C only */
X#define GLMS_MAT3_IDENTITY ((mat3s)GLMS_MAT3_IDENTITY_INIT)
X#define GLMS_MAT3_ZERO     ((mat3s)GLMS_MAT3_ZERO_INIT)
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * @param[in]  mat  source
X * @returns         destination
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_copy(mat3s mat) {
X  mat3s r;
X  glm_mat3_copy(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief make given matrix identity. It is identical with below,
X *        but it is more easy to do that with this func especially for members
X *        e.g. glm_mat3_identity(aStruct->aMatrix);
X *
X * @code
X * glm_mat3_copy(GLM_MAT3_IDENTITY, mat); // C only
X *
X * // or
X * mat3 mat = GLM_MAT3_IDENTITY_INIT;
X * @endcode
X *
X * @returns  destination
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_identity(void) {
X  mat3s r;
X  glm_mat3_identity(r.raw);
X  return r;
X}
X
X/*!
X * @brief make given matrix array's each element identity matrix
X *
X * @param[in, out]  mat   matrix array (must be aligned (16/32)
X *                        if alignment is not disabled)
X *
X * @param[in]       count count of matrices
X */
XCGLM_INLINE
Xvoid
Xglms_mat3_identity_array(mat3s * __restrict mat, size_t count) {
X  CGLM_ALIGN_MAT mat3s t = GLMS_MAT3_IDENTITY_INIT;
X  size_t i;
X
X  for (i = 0; i < count; i++) {
X    glm_mat3_copy(t.raw, mat[i].raw);
X  }
X}
X
X/*!
X * @brief make given matrix zero.
X *
X * @returns  matrix
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_zero(void) {
X  mat3s r;
X  glm_mat3_zero(r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * m1, m2 and dest matrices can be same matrix, it is possible to write this:
X *
X * @code
X * mat3 m = GLM_MAT3_IDENTITY_INIT;
X * glm_mat3_mul(m, m, m);
X * @endcode
X *
X * @param[in]  m1   left matrix
X * @param[in]  m2   right matrix
X * @returns         destination matrix
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_mul(mat3s m1, mat3s m2) {
X  mat3s r;
X  glm_mat3_mul(m1.raw, m2.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief tranpose mat3 and store result in same matrix
X *
X * @param[in, out] m source and dest
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_transpose(mat3s m) {
X  glm_mat3_transpose(m.raw);
X  return m;
X}
X
X/*!
X * @brief multiply mat3 with vec3 (column vector) and store in dest vector
X *
X * @param[in]  m    mat3 (left)
X * @param[in]  v    vec3 (right, column vector)
X * @returns         vec3 (result, column vector)
X */
XCGLM_INLINE
Xvec3s
Xglms_mat3_mulv(mat3s m, vec3s v) {
X  vec3s r;
X  glm_mat3_mulv(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief trace of matrix
X *
X * sum of the elements on the main diagonal from upper left to the lower right
X *
X * @param[in]  m matrix
X */
XCGLM_INLINE
Xfloat
Xglms_mat3_trace(mat3s m) {
X  return glm_mat3_trace(m.raw);
X}
X
X/*!
X * @brief convert mat3 to quaternion
X *
X * @param[in]  m    rotation matrix
X * @returns         destination quaternion
X */
XCGLM_INLINE
Xversors
Xglms_mat3_quat(mat3s m) {
X  versors r;
X  glm_mat3_quat(m.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in]      m matrix
X * @param[in]      s scalar
X * @returns          scaled matrix
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_scale(mat3s m, float s) {
X  glm_mat3_scale(m.raw, s);
X  return m;
X}
X
X/*!
X * @brief mat3 determinant
X *
X * @param[in] mat matrix
X *
X * @return determinant
X */
XCGLM_INLINE
Xfloat
Xglms_mat3_det(mat3s mat) {
X  return glm_mat3_det(mat.raw);
X}
X
X/*!
X * @brief inverse mat3 and store in dest
X *
X * @param[in]  mat  matrix
X * @returns         inverse matrix
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_inv(mat3s mat) {
X  mat3s r;
X  glm_mat3_inv(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief swap two matrix columns
X *
X * @param[in]     mat  matrix
X * @param[in]     col1 col1
X * @param[in]     col2 col2
X * @returns            matrix
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_swap_col(mat3s mat, int col1, int col2) {
X  glm_mat3_swap_col(mat.raw, col1, col2);
X  return mat;
X}
X
X/*!
X * @brief swap two matrix rows
X *
X * @param[in]     mat  matrix
X * @param[in]     row1 row1
X * @param[in]     row2 row2
X * @returns            matrix
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_swap_row(mat3s mat, int row1, int row2) {
X  glm_mat3_swap_row(mat.raw, row1, row2);
X  return mat;
X}
X
X/*!
X * @brief helper for  R (row vector) * M (matrix) * C (column vector)
X *
X * rmc stands for Row * Matrix * Column
X *
X * the result is scalar because R * M = Matrix1x3 (row vector),
X * then Matrix1x3 * Vec3 (column vector) = Matrix1x1 (Scalar)
X *
X * @param[in]  r   row vector or matrix1x3
X * @param[in]  m   matrix3x3
X * @param[in]  c   column vector or matrix3x1
X *
X * @return scalar value e.g. Matrix1x1
X */
XCGLM_INLINE
Xfloat
Xglms_mat3_rmc(vec3s r, mat3s m, vec3s c) {
X  return glm_mat3_rmc(r.raw, m.raw, c.raw);
X}
X
X#endif /* cglms_mat3s_h */
1a123a2ad7db2666d2dbb9fecacecc2c
echo x - cglm/struct/vec3.h
sed 's/^X//' >cglm/struct/vec3.h << '2b28b2853bd04cae97aa27342ff40c44'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLMS_VEC3_ONE_INIT
X   GLMS_VEC3_ZERO_INIT
X   GLMS_VEC3_ONE
X   GLMS_VEC3_ZERO
X   GLMS_YUP
X   GLMS_ZUP
X   GLMS_XUP
X
X Functions:
X   CGLM_INLINE vec3s glms_vec3(vec4s v4);
X   CGLM_INLINE void  glms_vec3_pack(vec3s dst[], vec3 src[], size_t len);
X   CGLM_INLINE void  glms_vec3_unpack(vec3 dst[], vec3s src[], size_t len);
X   CGLM_INLINE vec3s glms_vec3_zero(void);
X   CGLM_INLINE vec3s glms_vec3_one(void);
X   CGLM_INLINE float glms_vec3_dot(vec3s a, vec3s b);
X   CGLM_INLINE float glms_vec3_norm2(vec3s v);
X   CGLM_INLINE float glms_vec3_norm(vec3s v);
X   CGLM_INLINE float glms_vec3_norm_one(vec3s v);
X   CGLM_INLINE float glms_vec3_norm_inf(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_add(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_adds(vec3s a, float s);
X   CGLM_INLINE vec3s glms_vec3_sub(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_subs(vec3s a, float s);
X   CGLM_INLINE vec3s glms_vec3_mul(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_scale(vec3s v, float s);
X   CGLM_INLINE vec3s glms_vec3_scale_as(vec3s v, float s);
X   CGLM_INLINE vec3s glms_vec3_div(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_divs(vec3s a, float s);
X   CGLM_INLINE vec3s glms_vec3_addadd(vec3s a, vec3s b, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_subadd(vec3s a, vec3s b, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_muladd(vec3s a, vec3s b, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_muladds(vec3s a, float s, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_maxadd(vec3s a, vec3s b, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_minadd(vec3s a, vec3s b, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_flipsign(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_negate(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_inv(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_normalize(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_cross(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_crossn(vec3s a, vec3s b);
X   CGLM_INLINE float glms_vec3_angle(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_rotate(vec3s v, float angle, vec3s axis);
X   CGLM_INLINE vec3s glms_vec3_rotate_m4(mat4s m, vec3s v);
X   CGLM_INLINE vec3s glms_vec3_rotate_m3(mat3s m, vec3s v);
X   CGLM_INLINE vec3s glms_vec3_proj(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_center(vec3s a, vec3s b);
X   CGLM_INLINE float glms_vec3_distance(vec3s a, vec3s b);
X   CGLM_INLINE float glms_vec3_distance2(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_maxv(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_minv(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_ortho(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_clamp(vec3s v, float minVal, float maxVal);
X   CGLM_INLINE vec3s glms_vec3_lerp(vec3s from, vec3s to, float t);
X   CGLM_INLINE vec3s glms_vec3_lerpc(vec3s from, vec3s to, float t);
X   CGLM_INLINE vec3s glms_vec3_mix(vec3s from, vec3s to, float t);
X   CGLM_INLINE vec3s glms_vec3_mixc(vec3s from, vec3s to, float t);
X   CGLM_INLINE vec3s glms_vec3_step_uni(float edge, vec3s x);
X   CGLM_INLINE vec3s glms_vec3_step(vec3s edge, vec3s x);
X   CGLM_INLINE vec3s glms_vec3_smoothstep_uni(float edge0, float edge1, vec3s x);
X   CGLM_INLINE vec3s glms_vec3_smoothstep(vec3s edge0, vec3s edge1, vec3s x);
X   CGLM_INLINE vec3s glms_vec3_smoothinterp(vec3s from, vec3s to, float t);
X   CGLM_INLINE vec3s glms_vec3_smoothinterpc(vec3s from, vec3s to, float t);
X   CGLM_INLINE vec3s glms_vec3_swizzle(vec3s v, int mask);
X
X Convenient:
X   CGLM_INLINE vec3s glms_cross(vec3s a, vec3s b);
X   CGLM_INLINE float glms_dot(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_normalize(vec3s v);
X */
X
X#ifndef cglms_vec3s_h
X#define cglms_vec3s_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../util.h"
X#include "../vec3.h"
X#include "vec3-ext.h"
X
X#define GLMS_VEC3_ONE_INIT   {GLM_VEC3_ONE_INIT}
X#define GLMS_VEC3_ZERO_INIT  {GLM_VEC3_ZERO_INIT}
X
X#define GLMS_VEC3_ONE  ((vec3s)GLMS_VEC3_ONE_INIT)
X#define GLMS_VEC3_ZERO ((vec3s)GLMS_VEC3_ZERO_INIT)
X
X#define GLMS_YUP  ((vec3s){{0.0f, 1.0f, 0.0f}})
X#define GLMS_ZUP  ((vec3s){{0.0f, 0.0f, 1.0f}})
X#define GLMS_XUP  ((vec3s){{1.0f, 0.0f, 0.0f}})
X
X/*!
X * @brief init vec3 using vec4
X *
X * @param[in]  v4   vector4
X * @returns         destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3(vec4s v4) {
X  vec3s r;
X  glm_vec3(v4.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief pack an array of vec3 into an array of vec3s
X *
X * @param[out] dst array of vec3
X * @param[in]  src array of vec3s
X * @param[in]  len number of elements
X */
XCGLM_INLINE
Xvoid
Xglms_vec3_pack(vec3s dst[], vec3 src[], size_t len) {
X  size_t i;
X
X  for (i = 0; i < len; i++) {
X    glm_vec3_copy(src[i], dst[i].raw);
X  }
X}
X
X/*!
X * @brief unpack an array of vec3s into an array of vec3
X *
X * @param[out] dst array of vec3s
X * @param[in]  src array of vec3
X * @param[in]  len number of elements
X */
XCGLM_INLINE
Xvoid
Xglms_vec3_unpack(vec3 dst[], vec3s src[], size_t len) {
X  size_t i;
X
X  for (i = 0; i < len; i++) {
X    glm_vec3_copy(src[i].raw, dst[i]);
X  }
X}
X
X/*!
X * @brief make vector zero
X *
X * @returns       zero vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_zero(void) {
X  vec3s r;
X  glm_vec3_zero(r.raw);
X  return r;
X}
X
X/*!
X * @brief make vector one
X *
X * @returns       one vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_one(void) {
X  vec3s r;
X  glm_vec3_one(r.raw);
X  return r;
X}
X
X/*!
X * @brief vec3 dot product
X *
X * @param[in] a vector1
X * @param[in] b vector2
X *
X * @return dot product
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_dot(vec3s a, vec3s b) {
X  return glm_vec3_dot(a.raw, b.raw);
X}
X
X/*!
X * @brief norm * norm (magnitude) of vec
X *
X * we can use this func instead of calling norm * norm, because it would call
X * sqrtf fuction twice but with this func we can avoid func call, maybe this is
X * not good name for this func
X *
X * @param[in] v vector
X *
X * @return norm * norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_norm2(vec3s v) {
X  return glm_vec3_norm2(v.raw);
X}
X
X/*!
X * @brief norm (magnitude) of vec3
X *
X * @param[in] v vector
X *
X * @return norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_norm(vec3s v) {
X  return glm_vec3_norm(v.raw);
X}
X
X/*!
X * @brief L1 norm of vec3
X * Also known as Manhattan Distance or Taxicab norm.
X * L1 Norm is the sum of the magnitudes of the vectors in a space.
X * It is calculated as the sum of the absolute values of the vector components.
X * In this norm, all the components of the vector are weighted equally.
X *
X * This computes:
X * R = |v[0]| + |v[1]| + |v[2]|
X *
X * @param[in] v vector
X *
X * @return L1 norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_norm_one(vec3s v) {
X  return glm_vec3_norm_one(v.raw);
X}
X
X/*!
X * @brief Infinity norm of vec3
X * Also known as Maximum norm.
X * Infinity Norm is the largest magnitude among each element of a vector.
X * It is calculated as the maximum of the absolute values of the vector components.
X *
X * This computes:
X * inf norm = max(|v[0]|, |v[1]|, |v[2]|)
X *
X * @param[in] v vector
X *
X * @return Infinity norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_norm_inf(vec3s v) {
X  return glm_vec3_norm_inf(v.raw);
X}
X
X/*!
X * @brief add a vector to b vector store result in dest
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_add(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_add(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief add scalar to v vector store result in dest (d = v + s)
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_adds(vec3s a, float s) {
X  vec3s r;
X  glm_vec3_adds(a.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief subtract b vector from a vector store result in dest
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_sub(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_sub(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief subtract scalar from v vector store result in dest (d = v - s)
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_subs(vec3s a, float s) {
X  vec3s r;
X  glm_vec3_subs(a.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply two vector (component-wise multiplication)
X *
X * @param     a     vector1
X * @param     b     vector2
X * @returns         v3 = (a[0] * b[0], a[1] * b[1], a[2] * b[2])
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_mul(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_mul(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply/scale vec3 vector with scalar: result = v * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_scale(vec3s v, float s) {
X  vec3s r;
X  glm_vec3_scale(v.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief make vec3 vector scale as specified: result = unit(v) * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_scale_as(vec3s v, float s) {
X  vec3s r;
X  glm_vec3_scale_as(v.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief div vector with another component-wise division: d = a / b
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         result = (a[0]/b[0], a[1]/b[1], a[2]/b[2])
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_div(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_div(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief div vector with scalar: d = v / s
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         result = (a[0]/s, a[1]/s, a[2]/s)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_divs(vec3s a, float s) {
X  vec3s r;
X  glm_vec3_divs(a.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief add two vectors and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += (a + b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_addadd(vec3s a, vec3s b, vec3s dest) {
X  glm_vec3_addadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief sub two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += (a + b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_subadd(vec3s a, vec3s b, vec3s dest) {
X  glm_vec3_subadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief mul two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += (a * b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_muladd(vec3s a, vec3s b, vec3s dest) {
X  glm_vec3_muladd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief mul vector with scalar and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         dest += (a * b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_muladds(vec3s a, float s, vec3s dest) {
X  glm_vec3_muladds(a.raw, s, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief add max of two vector to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += max(a, b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_maxadd(vec3s a, vec3s b, vec3s dest) {
X  glm_vec3_maxadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief add min of two vector to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += min(a, b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_minadd(vec3s a, vec3s b, vec3s dest) {
X  glm_vec3_minadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief negate vector components and store result in dest
X *
X * @param[in]   v     vector
X * @returns           result vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_flipsign(vec3s v) {
X  glm_vec3_flipsign(v.raw);
X  return v;
X}
X
X/*!
X * @brief negate vector components
X *
X * @param[in]  v  vector
X * @returns       negated vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_negate(vec3s v) {
X  glm_vec3_negate(v.raw);
X  return v;
X}
X
X/*!
X * @brief normalize vec3 and store result in same vec
X *
X * @param[in] v vector
X * @returns     normalized vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_normalize(vec3s v) {
X  glm_vec3_normalize(v.raw);
X  return v;
X}
X
X/*!
X * @brief cross product of two vector (RH)
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_cross(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_cross(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief cross product of two vector (RH) and normalize the result
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_crossn(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_crossn(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief angle betwen two vector
X *
X * @param[in] a  vector1
X * @param[in] b  vector2
X *
X * @return angle as radians
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_angle(vec3s a, vec3s b) {
X  return glm_vec3_angle(a.raw, b.raw);
X}
X
X/*!
X * @brief rotate vec3 around axis by angle using Rodrigues' rotation formula
X *
X * @param[in]     v     vector
X * @param[in]     axis  axis vector (must be unit vector)
X * @param[in]     angle angle by radians
X * @returns             rotated vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_rotate(vec3s v, float angle, vec3s axis) {
X  glm_vec3_rotate(v.raw, angle, axis.raw);
X  return v;
X}
X
X/*!
X * @brief apply rotation matrix to vector
X *
X *  matrix format should be (no perspective):
X *   a  b  c  x
X *   e  f  g  y
X *   i  j  k  z
X *   0  0  0  w
X *
X * @param[in]  m    affine matrix or rot matrix
X * @param[in]  v    vector
X * @returns         rotated vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_rotate_m4(mat4s m, vec3s v) {
X  vec3s r;
X  glm_vec3_rotate_m4(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief apply rotation matrix to vector
X *
X * @param[in]  m    affine matrix or rot matrix
X * @param[in]  v    vector
X * @returns         rotated vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_rotate_m3(mat3s m, vec3s v) {
X  vec3s r;
X  glm_vec3_rotate_m3(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief project a vector onto b vector
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         projected vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_proj(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_proj(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/**
X * @brief find center point of two vector
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         center point
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_center(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_center(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/**
X * @brief distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return      distance
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_distance(vec3s a, vec3s b) {
X  return glm_vec3_distance(a.raw, b.raw);
X}
X
X/**
X * @brief squared distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return      squared distance (distance * distance)
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_distance2(vec3s a, vec3s b) {
X  return glm_vec3_distance2(a.raw, b.raw);
X}
X
X/*!
X * @brief max values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_maxv(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_maxv(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief min values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_minv(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_minv(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief possible orthogonal/perpendicular vector
X *
X * @param[in]  v    vector
X * @returns         orthogonal/perpendicular vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_ortho(vec3s v) {
X  vec3s r;
X  glm_vec3_ortho(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief clamp vector's individual members between min and max values
X *
X * @param[in]       v       vector
X * @param[in]       minVal  minimum value
X * @param[in]       maxVal  maximum value
X * @returns                 clamped vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_clamp(vec3s v, float minVal, float maxVal) {
X  glm_vec3_clamp(v.raw, minVal, maxVal);
X  return v;
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount)
X * @returns           destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_lerp(vec3s from, vec3s to, float t) {
X  vec3s r;
X  glm_vec3_lerp(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief linear interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount) clamped between 0 and 1
X * @returns           destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_lerpc(vec3s from, vec3s to, float t) {
X  vec3s r;
X  glm_vec3_lerpc(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount)
X * @returns           destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_mix(vec3s from, vec3s to, float t) {
X  vec3s r;
X  glm_vec3_mix(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief linear interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount) clamped between 0 and 1
X * @returns           destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_mixc(vec3s from, vec3s to, float t) {
X  vec3s r;
X  glm_vec3_mixc(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief threshold function (unidimensional)
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @returns             0.0 if x < edge, else 1.0
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_step_uni(float edge, vec3s x) {
X  vec3s r;
X  glm_vec3_step_uni(edge, x.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief threshold function
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @returns             0.0 if x < edge, else 1.0
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_step(vec3s edge, vec3s x) {
X  vec3s r;
X  glm_vec3_step(edge.raw, x.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief threshold function with a smooth transition (unidimensional)
X *
X * @param[in]   edge0   low threshold
X * @param[in]   edge1   high threshold
X * @param[in]   x       value to test against threshold
X * @returns             destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_smoothstep_uni(float edge0, float edge1, vec3s x) {
X  vec3s r;
X  glm_vec3_smoothstep_uni(edge0, edge1, x.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief threshold function with a smooth transition
X *
X * @param[in]   edge0   low threshold
X * @param[in]   edge1   high threshold
X * @param[in]   x       value to test against threshold
X * @returns             destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_smoothstep(vec3s edge0, vec3s edge1, vec3s x) {
X  vec3s r;
X  glm_vec3_smoothstep(edge0.raw, edge1.raw, x.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief smooth Hermite interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   t       interpolant (amount)
X * @returns             destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_smoothinterp(vec3s from, vec3s to, float t) {
X  vec3s r;
X  glm_vec3_smoothinterp(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief smooth Hermite interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   t       interpolant (amount) clamped between 0 and 1
X * @returns             destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_smoothinterpc(vec3s from, vec3s to, float t) {
X  vec3s r;
X  glm_vec3_smoothinterpc(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief vec3 cross product
X *
X * this is just convenient wrapper
X *
X * @param[in]  a  source 1
X * @param[in]  b  source 2
X * @returns       destination
X */
XCGLM_INLINE
Xvec3s
Xglms_cross(vec3s a, vec3s b) {
X  vec3s r;
X  glm_cross(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief vec3 dot product
X *
X * this is just convenient wrapper
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return      dot product
X */
XCGLM_INLINE
Xfloat
Xglms_dot(vec3s a, vec3s b) {
X  return glm_dot(a.raw, b.raw);
X}
X
X/*!
X * @brief normalize vec3 and store result in same vec
X *
X * this is just convenient wrapper
X *
X * @param[in]   v   vector
X * @returns         normalized vector
X */
XCGLM_INLINE
Xvec3s
Xglms_normalize(vec3s v) {
X  glm_normalize(v.raw);
X  return v;
X}
X
X/*!
X * @brief swizzle vector components
X *
X * you can use existin masks e.g. GLM_XXX, GLM_ZYX
X *
X * @param[in]  v    source
X * @param[in]  mask mask
X * @returns swizzled vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_swizzle(vec3s v, int mask) {
X  vec3s dest;
X  glm_vec3_swizzle(v.raw, mask, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_vec3s_h */
2b28b2853bd04cae97aa27342ff40c44
echo x - cglm/struct/vec3-ext.h
sed 's/^X//' >cglm/struct/vec3-ext.h << 'e21395184c02ef8dd90484943a2eb658'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*!
X * @brief SIMD like functions
X */
X
X/*
X Functions:
X   CGLM_INLINE vec3s glms_vec3_broadcast(float val);
X   CGLM_INLINE vec3s glms_vec3_fill(float val);
X   CGLM_INLINE bool  glms_vec3_eq(vec3s v, float val);
X   CGLM_INLINE bool  glms_vec3_eq_eps(vec3s v, float val);
X   CGLM_INLINE bool  glms_vec3_eq_all(vec3s v);
X   CGLM_INLINE bool  glms_vec3_eqv(vec3s a, vec3s b);
X   CGLM_INLINE bool  glms_vec3_eqv_eps(vec3s a, vec3s b);
X   CGLM_INLINE float glms_vec3_max(vec3s v);
X   CGLM_INLINE float glms_vec3_min(vec3s v);
X   CGLM_INLINE bool  glms_vec3_isnan(vec3s v);
X   CGLM_INLINE bool  glms_vec3_isinf(vec3s v);
X   CGLM_INLINE bool  glms_vec3_isvalid(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_sign(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_abs(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_fract(vec3s v);
X   CGLM_INLINE float glms_vec3_hadd(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_sqrt(vec3s v);
X */
X
X#ifndef cglms_vec3s_ext_h
X#define cglms_vec3s_ext_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../util.h"
X#include "../vec3-ext.h"
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param[in]  val  value
X * @returns         dest
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_broadcast(float val) {
X  vec3s r;
X  glm_vec3_broadcast(val, r.raw);
X  return r;
X}
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param[in]  val  value
X * @returns         dest
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_fill(float val) {
X  vec3s r;
X  glm_vec3_fill(r.raw, val);
X  return r;
X}
X
X/*!
X * @brief check if vector is equal to value (without epsilon)
X *
X * @param[in] v   vector
X * @param[in] val value
X */
XCGLM_INLINE
Xbool
Xglms_vec3_eq(vec3s v, float val) {
X  return glm_vec3_eq(v.raw, val);
X}
X
X/*!
X * @brief check if vector is equal to value (with epsilon)
X *
X * @param[in] v   vector
X * @param[in] val value
X */
XCGLM_INLINE
Xbool
Xglms_vec3_eq_eps(vec3s v, float val) {
X  return glm_vec3_eq_eps(v.raw, val);
X}
X
X/*!
X * @brief check if vectors members are equal (without epsilon)
X *
X * @param[in] v   vector
X */
XCGLM_INLINE
Xbool
Xglms_vec3_eq_all(vec3s v) {
X  return glm_vec3_eq_all(v.raw);
X}
X
X/*!
X * @brief check if vector is equal to another (without epsilon)
X *
X * @param[in] a vector
X * @param[in] b vector
X */
XCGLM_INLINE
Xbool
Xglms_vec3_eqv(vec3s a, vec3s b) {
X  return glm_vec3_eqv(a.raw, b.raw);
X}
X
X/*!
X * @brief check if vector is equal to another (with epsilon)
X *
X * @param[in] a vector
X * @param[in] b vector
X */
XCGLM_INLINE
Xbool
Xglms_vec3_eqv_eps(vec3s a, vec3s b) {
X  return glm_vec3_eqv_eps(a.raw, b.raw);
X}
X
X/*!
X * @brief max value of vector
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_max(vec3s v) {
X  return glm_vec3_max(v.raw);
X}
X
X/*!
X * @brief min value of vector
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_min(vec3s v) {
X  return glm_vec3_min(v.raw);
X}
X
X/*!
X * @brief check if all items are NaN (not a number)
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglms_vec3_isnan(vec3s v) {
X  return glm_vec3_isnan(v.raw);
X}
X
X/*!
X * @brief check if all items are INFINITY
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglms_vec3_isinf(vec3s v) {
X  return glm_vec3_isinf(v.raw);
X}
X
X/*!
X * @brief check if all items are valid number
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglms_vec3_isvalid(vec3s v) {
X  return glm_vec3_isvalid(v.raw);
X}
X
X/*!
X * @brief get sign of 32 bit float as +1, -1, 0
X *
X * Important: It returns 0 for zero/NaN input
X *
X * @param   v   vector
X * @returns     sign vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_sign(vec3s v) {
X  vec3s r;
X  glm_vec3_sign(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief absolute value of each vector item
X *
X * @param[in]  v    vector
X * @return          destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_abs(vec3s v) {
X  vec3s r;
X  glm_vec3_abs(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief fractional part of each vector item
X *
X * @param[in]  v    vector
X * @return          dest destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_fract(vec3s v) {
X  vec3s r;
X  glm_vec3_fract(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief vector reduction by summation
X * @warning could overflow
X *
X * @param[in]  v    vector
X * @return     sum of all vector's elements
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_hadd(vec3s v) {
X  return glm_vec3_hadd(v.raw);
X}
X
X/*!
X * @brief square root of each vector item
X *
X * @param[in]  v    vector
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_sqrt(vec3s v) {
X  vec3s r;
X  glm_vec3_sqrt(v.raw, r.raw);
X  return r;
X}
X
X#endif /* cglms_vec3s_ext_h */
e21395184c02ef8dd90484943a2eb658
echo x - cglm/struct/vec4.h
sed 's/^X//' >cglm/struct/vec4.h << 'af370160563352b49a30483f4593453d'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLMS_VEC4_ONE_INIT
X   GLMS_VEC4_BLACK_INIT
X   GLMS_VEC4_ZERO_INIT
X   GLMS_VEC4_ONE
X   GLMS_VEC4_BLACK
X   GLMS_VEC4_ZERO
X
X Functions:
X   CGLM_INLINE vec4s glms_vec4(vec3s v3, float last);
X   CGLM_INLINE vec3s glms_vec4_copy3(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_copy(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_ucopy(vec4s v);
X   CGLM_INLINE void  glms_vec4_pack(vec4s dst[], vec4 src[], size_t len);
X   CGLM_INLINE void  glms_vec4_unpack(vec4 dst[], vec4s src[], size_t len);
X   CGLM_INLINE float glms_vec4_dot(vec4s a, vec4s b);
X   CGLM_INLINE float glms_vec4_norm2(vec4s v);
X   CGLM_INLINE float glms_vec4_norm(vec4s v);
X   CGLM_INLINE float glms_vec4_norm_one(vec4s v);
X   CGLM_INLINE float glms_vec4_norm_inf(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_add(vec4s a, vec4s b);
X   CGLM_INLINE vec4s glms_vec4_adds(vec4s v, float s);
X   CGLM_INLINE vec4s glms_vec4_sub(vec4s a, vec4s b);
X   CGLM_INLINE vec4s glms_vec4_subs(vec4s v, float s);
X   CGLM_INLINE vec4s glms_vec4_mul(vec4s a, vec4s b);
X   CGLM_INLINE vec4s glms_vec4_scale(vec4s v, float s);
X   CGLM_INLINE vec4s glms_vec4_scale_as(vec4s v, float s);
X   CGLM_INLINE vec4s glms_vec4_div(vec4s a, vec4s b);
X   CGLM_INLINE vec4s glms_vec4_divs(vec4s v, float s);
X   CGLM_INLINE vec4s glms_vec4_addadd(vec4s a, vec4s b, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_subadd(vec4s a, vec4s b, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_muladd(vec4s a, vec4s b, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_muladds(vec4s a, float s, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_maxadd(vec4s a, vec4s b, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_minadd(vec4s a, vec4s b, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_negate(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_inv(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_normalize(vec4s v);
X   CGLM_INLINE float glms_vec4_distance(vec4s a, vec4s b);
X   CGLM_INLINE float glms_vec4_distance2(vec4s a, vec4s b);
X   CGLM_INLINE vec4s glms_vec4_maxv(vec4s a, vec4s b);
X   CGLM_INLINE vec4s glms_vec4_minv(vec4s a, vec4s b);
X   CGLM_INLINE vec4s glms_vec4_clamp(vec4s v, float minVal, float maxVal);
X   CGLM_INLINE vec4s glms_vec4_lerp(vec4s from, vec4s to, float t);
X   CGLM_INLINE vec4s glms_vec4_lerpc(vec4s from, vec4s to, float t);
X   CGLM_INLINE vec4s glms_vec4_mix(vec4s from, vec4s to, float t);
X   CGLM_INLINE vec4s glms_vec4_mixc(vec4s from, vec4s to, float t);
X   CGLM_INLINE vec4s glms_vec4_step_uni(float edge, vec4s x);
X   CGLM_INLINE vec4s glms_vec4_step(vec4s edge, vec4s x);
X   CGLM_INLINE vec4s glms_vec4_smoothstep_uni(float edge0, float edge1, vec4s x);
X   CGLM_INLINE vec4s glms_vec4_smoothstep(vec4s edge0, vec4s edge1, vec4s x);
X   CGLM_INLINE vec4s glms_vec4_smoothinterp(vec4s from, vec4s to, float t);
X   CGLM_INLINE vec4s glms_vec4_smoothinterpc(vec4s from, vec4s to, float t);
X   CGLM_INLINE vec4s glms_vec4_cubic(float s);
X   CGLM_INLINE vec4s glms_vec4_swizzle(vec4s v, int mask);
X */
X
X#ifndef cglms_vec4s_h
X#define cglms_vec4s_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../util.h"
X#include "../vec4.h"
X#include "vec4-ext.h"
X
X#define GLMS_VEC4_ONE_INIT   {GLM_VEC4_ONE_INIT}
X#define GLMS_VEC4_BLACK_INIT {GLM_VEC4_BLACK_INIT}
X#define GLMS_VEC4_ZERO_INIT  {GLM_VEC4_ZERO_INIT}
X
X#define GLMS_VEC4_ONE        ((vec4s)GLM_VEC4_ONE_INIT)
X#define GLMS_VEC4_BLACK      ((vec4s)GLM_VEC4_BLACK_INIT)
X#define GLMS_VEC4_ZERO       ((vec4s)GLM_VEC4_ZERO_INIT)
X
X/*!
X * @brief init vec4 using vec3
X *
X * @param[in]  v3   vector3
X * @param[in]  last last item
X * @returns         destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4(vec3s v3, float last) {
X  vec4s r;
X  glm_vec4(v3.raw, last, r.raw);
X  return r;
X}
X
X/*!
X * @brief copy first 3 members of [a] to [dest]
X *
X * @param[in]  v    source
X * @returns         vec3
X */
XCGLM_INLINE
Xvec3s
Xglms_vec4_copy3(vec4s v) {
X  vec3s r;
X  glm_vec4_copy3(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief copy all members of [a] to [dest]
X *
X * @param[in]  v    source
X * @returns         destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_copy(vec4s v) {
X  vec4s r;
X  glm_vec4_copy(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief copy all members of [a] to [dest]
X *
X * alignment is not required
X *
X * @param[in]  v    source
X * @returns         destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_ucopy(vec4s v) {
X  vec4s r;
X  glm_vec4_ucopy(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief pack an array of vec4 into an array of vec4s
X *
X * @param[out] dst array of vec4
X * @param[in]  src array of vec4s
X * @param[in]  len number of elements
X */
XCGLM_INLINE
Xvoid
Xglms_vec4_pack(vec4s dst[], vec4 src[], size_t len) {
X  size_t i;
X
X  for (i = 0; i < len; i++) {
X    glm_vec4_copy(src[i], dst[i].raw);
X  }
X}
X
X/*!
X * @brief unpack an array of vec4s into an array of vec4
X *
X * @param[out] dst array of vec4s
X * @param[in]  src array of vec4
X * @param[in]  len number of elements
X */
XCGLM_INLINE
Xvoid
Xglms_vec4_unpack(vec4 dst[], vec4s src[], size_t len) {
X  size_t i;
X
X  for (i = 0; i < len; i++) {
X    glm_vec4_copy(src[i].raw, dst[i]);
X  }
X}
X
X/*!
X * @brief make vector zero
X *
X * @returns      zero vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_zero(void) {
X  vec4s r;
X  glm_vec4_zero(r.raw);
X  return r;
X}
X
X/*!
X * @brief make vector one
X *
X * @returns      one vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_one(void) {
X  vec4s r;
X  glm_vec4_one(r.raw);
X  return r;
X}
X
X/*!
X * @brief vec4 dot product
X *
X * @param[in] a vector1
X * @param[in] b vector2
X *
X * @return dot product
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_dot(vec4s a, vec4s b) {
X  return glm_vec4_dot(a.raw, b.raw);
X}
X
X/*!
X * @brief norm * norm (magnitude) of vec
X *
X * we can use this func instead of calling norm * norm, because it would call
X * sqrtf fuction twice but with this func we can avoid func call, maybe this is
X * not good name for this func
X *
X * @param[in] v vec4
X *
X * @return norm * norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_norm2(vec4s v) {
X  return glm_vec4_norm2(v.raw);
X}
X
X/*!
X * @brief norm (magnitude) of vec4
X *
X * @param[in] v vector
X *
X * @return norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_norm(vec4s v) {
X  return glm_vec4_norm(v.raw);
X}
X
X/*!
X * @brief L1 norm of vec4
X * Also known as Manhattan Distance or Taxicab norm.
X * L1 Norm is the sum of the magnitudes of the vectors in a space.
X * It is calculated as the sum of the absolute values of the vector components.
X * In this norm, all the components of the vector are weighted equally.
X *
X * This computes:
X * R = |v[0]| + |v[1]| + |v[2]| + |v[3]|
X *
X * @param[in] v vector
X *
X * @return L1 norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_norm_one(vec4s v) {
X  return glm_vec4_norm_one(v.raw);
X}
X
X/*!
X * @brief Infinity norm of vec4
X * Also known as Maximum norm.
X * Infinity Norm is the largest magnitude among each element of a vector.
X * It is calculated as the maximum of the absolute values of the vector components.
X *
X * This computes:
X * inf norm = max(|v[0]|, |v[1]|, |v[2]|, |v[3]|)
X *
X * @param[in] v vector
X *
X * @return Infinity norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_norm_inf(vec4s v) {
X  return glm_vec4_norm_inf(v.raw);
X}
X
X/*!
X * @brief add b vector to a vector store result in dest
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_add(vec4s a, vec4s b) {
X  vec4s r;
X  glm_vec4_add(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief add scalar to v vector store result in dest (d = v + vec(s))
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_adds(vec4s v, float s) {
X  vec4s r;
X  glm_vec4_adds(v.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief subtract b vector from a vector store result in dest (d = a - b)
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_sub(vec4s a, vec4s b) {
X  vec4s r;
X  glm_vec4_sub(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief subtract scalar from v vector store result in dest (d = v - vec(s))
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_subs(vec4s v, float s) {
X  vec4s r;
X  glm_vec4_subs(v.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply two vector (component-wise multiplication)
X *
X * @param a    vector1
X * @param b    vector2
X * @returns    dest = (a[0] * b[0], a[1] * b[1], a[2] * b[2], a[3] * b[3])
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_mul(vec4s a, vec4s b) {
X  vec4s r;
X  glm_vec4_mul(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply/scale vec4 vector with scalar: result = v * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_scale(vec4s v, float s) {
X  vec4s r;
X  glm_vec4_scale(v.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief make vec4 vector scale as specified: result = unit(v) * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_scale_as(vec4s v, float s) {
X  vec4s r;
X  glm_vec4_scale_as(v.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief div vector with another component-wise division: d = a / b
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         result = (a[0]/b[0], a[1]/b[1], a[2]/b[2], a[3]/b[3])
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_div(vec4s a, vec4s b) {
X  vec4s r;
X  glm_vec4_div(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief div vec4 vector with scalar: d = v / s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_divs(vec4s v, float s) {
X  vec4s r;
X  glm_vec4_divs(v.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief add two vectors and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += (a + b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_addadd(vec4s a, vec4s b, vec4s dest) {
X  glm_vec4_addadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief sub two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += (a - b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_subadd(vec4s a, vec4s b, vec4s dest) {
X  glm_vec4_subadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief mul two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += (a * b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_muladd(vec4s a, vec4s b, vec4s dest) {
X  glm_vec4_muladd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief mul vector with scalar and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         dest += (a * b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_muladds(vec4s a, float s, vec4s dest) {
X  glm_vec4_muladds(a.raw, s, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief add max of two vector to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += max(a, b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_maxadd(vec4s a, vec4s b, vec4s dest) {
X  glm_vec4_maxadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief add min of two vector to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += min(a, b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_minadd(vec4s a, vec4s b, vec4s dest) {
X  glm_vec4_minadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief negate vector components and store result in dest
X *
X * @param[in]  v     vector
X * @returns          result vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_negate(vec4s v) {
X  glm_vec4_negate(v.raw);
X  return v;
X}
X
X/*!
X * @brief normalize vec4 and store result in same vec
X *
X * @param[in] v   vector
X * @returns       normalized vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_normalize(vec4s v) {
X  glm_vec4_normalize(v.raw);
X  return v;
X}
X
X/**
X * @brief distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return returns distance
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_distance(vec4s a, vec4s b) {
X  return glm_vec4_distance(a.raw, b.raw);
X}
X
X/**
X * @brief squared distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return returns squared distance
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_distance2(vec4s a, vec4s b) {
X  return glm_vec4_distance2(a.raw, b.raw);
X}
X
X/*!
X * @brief max values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_maxv(vec4s a, vec4s b) {
X  vec4s r;
X  glm_vec4_maxv(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief min values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_minv(vec4s a, vec4s b) {
X  vec4s r;
X  glm_vec4_minv(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief clamp vector's individual members between min and max values
X *
X * @param[in]       v       vector
X * @param[in]       minVal  minimum value
X * @param[in]       maxVal  maximum value
X * @returns                 clamped vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_clamp(vec4s v, float minVal, float maxVal) {
X  glm_vec4_clamp(v.raw, minVal, maxVal);
X  return v;
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount)
X * @returns           destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_lerp(vec4s from, vec4s to, float t) {
X  vec4s r;
X  glm_vec4_lerp(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief linear interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount) clamped between 0 and 1
X * @returns           destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_lerpc(vec4s from, vec4s to, float t) {
X  vec4s r;
X  glm_vec4_lerpc(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount)
X * @returns           destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_mix(vec4s from, vec4s to, float t) {
X  vec4s r;
X  glm_vec4_mix(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief linear interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount) clamped between 0 and 1
X * @returns           destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_mixc(vec4s from, vec4s to, float t) {
X  vec4s r;
X  glm_vec4_mixc(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief threshold function (unidimensional)
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @returns             0.0 if x < edge, else 1.0
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_step_uni(float edge, vec4s x) {
X  vec4s r;
X  glm_vec4_step_uni(edge, x.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief threshold function
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @returns             0.0 if x < edge, else 1.0
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_step(vec4s edge, vec4s x) {
X  vec4s r;
X  glm_vec4_step(edge.raw, x.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief threshold function with a smooth transition (unidimensional)
X *
X * @param[in]   edge0   low threshold
X * @param[in]   edge1   high threshold
X * @param[in]   x       value to test against threshold
X * @returns             destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_smoothstep_uni(float edge0, float edge1, vec4s x) {
X  vec4s r;
X  glm_vec4_smoothstep_uni(edge0, edge1, x.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief threshold function with a smooth transition
X *
X * @param[in]   edge0   low threshold
X * @param[in]   edge1   high threshold
X * @param[in]   x       value to test against threshold
X * @returns             destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_smoothstep(vec4s edge0, vec4s edge1, vec4s x) {
X  vec4s r;
X  glm_vec4_smoothstep(edge0.raw, edge1.raw, x.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief smooth Hermite interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   t       interpolant (amount)
X * @returns             destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_smoothinterp(vec4s from, vec4s to, float t) {
X  vec4s r;
X  glm_vec4_smoothinterp(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief smooth Hermite interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   t       interpolant (amount) clamped between 0 and 1
X * @returns             destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_smoothinterpc(vec4s from, vec4s to, float t) {
X  vec4s r;
X  glm_vec4_smoothinterpc(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief helper to fill vec4 as [S^3, S^2, S, 1]
X *
X * @param[in]   s     parameter
X * @returns           destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_cubic(float s) {
X  vec4s r;
X  glm_vec4_cubic(s, r.raw);
X  return r;
X}
X
X/*!
X * @brief swizzle vector components
X *
X * you can use existin masks e.g. GLM_XXXX, GLM_WZYX
X *
X * @param[in]  v    source
X * @param[in]  mask mask
X * @returns swizzled vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_swizzle(vec4s v, int mask) {
X  vec4s dest;
X  glm_vec4_swizzle(v.raw, mask, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_vec4s_h */
af370160563352b49a30483f4593453d
echo x - cglm/struct/vec4-ext.h
sed 's/^X//' >cglm/struct/vec4-ext.h << '35a8b505207e09af32f5d24001d3d838'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*!
X * @brief SIMD like functions
X */
X
X/*
X Functions:
X   CGLM_INLINE vec4s glms_vec4_broadcast(float val);
X   CGLM_INLINE vec4s glms_vec4_fill(float val);
X   CGLM_INLINE bool  glms_vec4_eq(vec4s v, float val);
X   CGLM_INLINE bool  glms_vec4_eq_eps(vec4s v, float val);
X   CGLM_INLINE bool  glms_vec4_eq_all(vec4s v);
X   CGLM_INLINE bool  glms_vec4_eqv(vec4s a, vec4s b);
X   CGLM_INLINE bool  glms_vec4_eqv_eps(vec4s a, vec4s b);
X   CGLM_INLINE float glms_vec4_max(vec4s v);
X   CGLM_INLINE float glms_vec4_min(vec4s v);
X   CGLM_INLINE bool  glms_vec4_isnan(vec4s v);
X   CGLM_INLINE bool  glms_vec4_isinf(vec4s v);
X   CGLM_INLINE bool  glms_vec4_isvalid(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_sign(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_abs(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_fract(vec4s v);
X   CGLM_INLINE float glms_vec4_hadd(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_sqrt(vec4s v);
X */
X
X#ifndef cglms_vec4s_ext_h
X#define cglms_vec4s_ext_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../util.h"
X#include "../vec4-ext.h"
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param val value
X * @returns   dest
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_broadcast(float val) {
X  vec4s r;
X  glm_vec4_broadcast(val, r.raw);
X  return r;
X}
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param val value
X * @returns   dest
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_fill(float val) {
X  vec4s r;
X  glm_vec4_fill(r.raw, val);
X  return r;
X}
X
X/*!
X * @brief check if vector is equal to value (without epsilon)
X *
X * @param v   vector
X * @param val value
X */
XCGLM_INLINE
Xbool
Xglms_vec4_eq(vec4s v, float val) {
X  return glm_vec4_eq(v.raw, val);
X}
X
X/*!
X * @brief check if vector is equal to value (with epsilon)
X *
X * @param v   vector
X * @param val value
X */
XCGLM_INLINE
Xbool
Xglms_vec4_eq_eps(vec4s v, float val) {
X  return glm_vec4_eq_eps(v.raw, val);
X}
X
X/*!
X * @brief check if vectors members are equal (without epsilon)
X *
X * @param v   vector
X */
XCGLM_INLINE
Xbool
Xglms_vec4_eq_all(vec4s v) {
X  return glm_vec4_eq_all(v.raw);
X}
X
X/*!
X * @brief check if vector is equal to another (without epsilon)
X *
X * @param a vector
X * @param b vector
X */
XCGLM_INLINE
Xbool
Xglms_vec4_eqv(vec4s a, vec4s b) {
X  return glm_vec4_eqv(a.raw, b.raw);
X}
X
X/*!
X * @brief check if vector is equal to another (with epsilon)
X *
X * @param a vector
X * @param b vector
X */
XCGLM_INLINE
Xbool
Xglms_vec4_eqv_eps(vec4s a, vec4s b) {
X  return glm_vec4_eqv_eps(a.raw, b.raw);
X}
X
X/*!
X * @brief max value of vector
X *
X * @param v vector
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_max(vec4s v) {
X  return glm_vec4_max(v.raw);
X}
X
X/*!
X * @brief min value of vector
X *
X * @param v vector
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_min(vec4s v) {
X  return glm_vec4_min(v.raw);
X}
X
X/*!
X * @brief check if one of items is NaN (not a number)
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglms_vec4_isnan(vec4s v) {
X  return glm_vec4_isnan(v.raw);
X}
X
X/*!
X * @brief check if one of items is INFINITY
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglms_vec4_isinf(vec4s v) {
X  return glm_vec4_isinf(v.raw);
X}
X
X/*!
X * @brief check if all items are valid number
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglms_vec4_isvalid(vec4s v) {
X  return glm_vec4_isvalid(v.raw);
X}
X
X/*!
X * @brief get sign of 32 bit float as +1, -1, 0
X *
X * Important: It returns 0 for zero/NaN input
X *
X * @param   v   vector
X * @returns     sign vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_sign(vec4s v) {
X  vec4s r;
X  glm_vec4_sign(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief absolute value of each vector item
X *
X * @param[in]  v    vector
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_abs(vec4s v) {
X  vec4s r;
X  glm_vec4_abs(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief fractional part of each vector item
X *
X * @param[in]  v    vector
X * @returns          dest destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_fract(vec4s v) {
X  vec4s r;
X  glm_vec4_fract(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief vector reduction by summation
X * @warning could overflow
X *
X * @param[in]  v    vector
X * @return     sum of all vector's elements
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_hadd(vec4s v) {
X  return glm_vec4_hadd(v.raw);
X}
X
X/*!
X * @brief square root of each vector item
X *
X * @param[in]  v    vector
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_sqrt(vec4s v) {
X  vec4s r;
X  glm_vec4_sqrt(v.raw, r.raw);
X  return r;
X}
X
X#endif /* cglms_vec4s_ext_h */
35a8b505207e09af32f5d24001d3d838
echo x - cglm/struct/affine.h
sed 's/^X//' >cglm/struct/affine.h << 'e94591641a92571ad5097633a68da5b0'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_translate(mat4s m, vec3s v);
X   CGLM_INLINE mat4s glms_translate_x(mat4s m, float x);
X   CGLM_INLINE mat4s glms_translate_y(mat4s m, float y);
X   CGLM_INLINE mat4s glms_translate_z(mat4s m, float z);
X   CGLM_INLINE mat4s glms_translate_make(vec3s v);
X   CGLM_INLINE mat4s glms_scale_to(mat4s m, vec3s v);
X   CGLM_INLINE mat4s glms_scale_make(vec3s v);
X   CGLM_INLINE mat4s glms_scale(mat4s m, vec3s v);
X   CGLM_INLINE mat4s glms_scale_uni(mat4s m, float s);
X   CGLM_INLINE mat4s glmx_rotate_x(mat4s m, float angle);
X   CGLM_INLINE mat4s glms_rotate_y(mat4s m, float angle);
X   CGLM_INLINE mat4s glms_rotate_z(mat4s m, float angle);
X   CGLM_INLINE mat4s glms_rotate_make(float angle, vec3s axis);
X   CGLM_INLINE mat4s glms_rotate(mat4s m, float angle, vec3s axis);
X   CGLM_INLINE mat4s glms_rotate_at(mat4s m, vec3s pivot, float angle, vec3s axis);
X   CGLM_INLINE mat4s glms_rotate_atm(mat4s m, vec3s pivot, float angle, vec3s axis);
X   CGLM_INLINE vec3s glms_decompose_scalev(mat4s m);
X   CGLM_INLINE bool  glms_uniscaled(mat4s m);
X   CGLM_INLINE void  glms_decompose_rs(mat4s m, mat4s * r, vec3s * s);
X   CGLM_INLINE void  glms_decompose(mat4s m, vec4s t, mat4s * r, vec3s * s);
X */
X
X#ifndef cglms_affines_h
X#define cglms_affines_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../affine.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X
XCGLM_INLINE
Xmat4s
Xglms_mat4_mul(mat4s m1, mat4s m2);
X
X/*!
X * @brief translate existing transform matrix by v vector
X *        and stores result in same matrix
X *
X * @param[in]       m   affine transfrom
X * @param[in]       v   translate vector [x, y, z]
X * @returns             affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_translate(mat4s m, vec3s v) {
X  glm_translate(m.raw, v.raw);
X  return m;
X}
X
X/*!
X * @brief translate existing transform matrix by x factor
X *
X * @param[in]       m   affine transfrom
X * @param[in]       x   x factor
X * @returns             affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_translate_x(mat4s m, float x) {
X  glm_translate_x(m.raw, x);
X  return m;
X}
X
X/*!
X * @brief translate existing transform matrix by y factor
X *
X * @param[in]       m   affine transfrom
X * @param[in]       y   y factor
X * @returns             affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_translate_y(mat4s m, float y) {
X  glm_translate_y(m.raw, y);
X  return m;
X}
X
X/*!
X * @brief translate existing transform matrix by z factor
X *
X * @param[in]       m   affine transfrom
X * @param[in]       z   z factor
X * @returns             affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_translate_z(mat4s m, float z) {
X  glm_translate_z(m.raw, z);
X  return m;
X}
X
X/*!
X * @brief creates NEW translate transform matrix by v vector
X *
X * @param[in]   v   translate vector [x, y, z]
X * @returns         affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_translate_make(vec3s v) {
X  mat4s m;
X  glm_translate_make(m.raw, v.raw);
X  return m;
X}
X
X/*!
X * @brief creates NEW scale matrix by v vector
X *
X * @param[in]   v  scale vector [x, y, z]
X * @returns affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_scale_make(vec3s v) {
X  mat4s m;
X  glm_scale_make(m.raw, v.raw);
X  return m;
X}
X
X/*!
X * @brief scales existing transform matrix by v vector
X *        and stores result in same matrix
X *
X * @param[in]    m   affine transfrom
X * @param[in]    v   scale vector [x, y, z]
X * @returns          affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_scale(mat4s m, vec3s v) {
X  mat4s r;
X  glm_scale_to(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief applies uniform scale to existing transform matrix v = [s, s, s]
X *        and stores result in same matrix
X *
X * @param[in]    m   affine transfrom
X * @param[in]    s   scale factor
X * @returns          affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_scale_uni(mat4s m, float s) {
X  glm_scale_uni(m.raw, s);
X  return m;
X}
X
X/*!
X * @brief rotate existing transform matrix around X axis by angle
X *        and store result in dest
X *
X * @param[in]   m       affine transfrom
X * @param[in]   angle   angle (radians)
X * @returns             rotated matrix
X */
XCGLM_INLINE
Xmat4s
Xglmx_rotate_x(mat4s m, float angle) {
X  mat4s r;
X  glm_rotate_x(m.raw, angle, r.raw);
X  return r;
X}
X
X/*!
X * @brief rotate existing transform matrix around Y axis by angle
X *        and store result in dest
X *
X * @param[in]   m       affine transfrom
X * @param[in]   angle   angle (radians)
X * @returns             rotated matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_rotate_y(mat4s m, float angle) {
X  mat4s r;
X  glm_rotate_y(m.raw, angle, r.raw);
X  return r;
X}
X
X/*!
X * @brief rotate existing transform matrix around Z axis by angle
X *        and store result in dest
X *
X * @param[in]   m       affine transfrom
X * @param[in]   angle   angle (radians)
X * @returns             rotated matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_rotate_z(mat4s m, float angle) {
X  mat4s r;
X  glm_rotate_z(m.raw, angle, r.raw);
X  return r;
X}
X
X/*!
X * @brief creates NEW rotation matrix by angle and axis
X *
X * axis will be normalized so you don't need to normalize it
X *
X * @param[in]  angle  angle (radians)
X * @param[in]  axis   axis
X * @returns           affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_rotate_make(float angle, vec3s axis) {
X  mat4s m;
X  glm_rotate_make(m.raw, angle, axis.raw);
X  return m;
X}
X
X/*!
X * @brief rotate existing transform matrix around given axis by angle
X *
X * @param[in]       m       affine transfrom
X * @param[in]       angle   angle (radians)
X * @param[in]       axis    axis
X * @returns                 affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_rotate(mat4s m, float angle, vec3s axis) {
X  glm_rotate(m.raw, angle, axis.raw);
X  return m;
X}
X
X/*!
X * @brief rotate existing transform
X *        around given axis by angle at given pivot point (rotation center)
X *
X * @param[in]       m       affine transfrom
X * @param[in]       pivot   rotation center
X * @param[in]       angle   angle (radians)
X * @param[in]       axis    axis
X * @returns                 affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_rotate_at(mat4s m, vec3s pivot, float angle, vec3s axis) {
X  glm_rotate_at(m.raw, pivot.raw, angle, axis.raw);
X  return m;
X}
X
X/*!
X * @brief creates NEW rotation matrix by angle and axis at given point
X *
X * this creates rotation matrix, it assumes you don't have a matrix
X *
X * this should work faster than glm_rotate_at because it reduces
X * one glm_translate.
X *
X * @param[in]  m      affine transfrom
X * @param[in]  pivot  rotation center
X * @param[in]  angle  angle (radians)
X * @param[in]  axis   axis
X * @returns           affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_rotate_atm(mat4s m, vec3s pivot, float angle, vec3s axis) {
X  glm_rotate_atm(m.raw, pivot.raw, angle, axis.raw);
X  return m;
X}
X
X/*!
X * @brief decompose scale vector
X *
X * @param[in]  m  affine transform
X * @returns       scale vector (Sx, Sy, Sz)
X */
XCGLM_INLINE
Xvec3s
Xglms_decompose_scalev(mat4s m) {
X  vec3s r;
X  glm_decompose_scalev(m.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief returns true if matrix is uniform scaled. This is helpful for
X *        creating normal matrix.
X *
X * @param[in] m m
X *
X * @return boolean
X */
XCGLM_INLINE
Xbool
Xglms_uniscaled(mat4s m) {
X  return glm_uniscaled(m.raw);
X}
X
X/*!
X * @brief decompose rotation matrix (mat4) and scale vector [Sx, Sy, Sz]
X *        DON'T pass projected matrix here
X *
X * @param[in]  m affine transform
X * @param[out] r rotation matrix
X * @param[out] s scale matrix
X */
XCGLM_INLINE
Xvoid
Xglms_decompose_rs(mat4s m, mat4s * __restrict r, vec3s * __restrict s) {
X  glm_decompose_rs(m.raw, r->raw, s->raw);
X}
X
X/*!
X * @brief decompose affine transform, TODO: extract shear factors.
X *        DON'T pass projected matrix here
X *
X * @param[in]  m affine transfrom
X * @param[out] t translation vector
X * @param[out] r rotation matrix (mat4)
X * @param[out] s scaling vector [X, Y, Z]
X */
XCGLM_INLINE
Xvoid
Xglms_decompose(mat4s m, vec4s * __restrict t, mat4s * __restrict r, vec3s * __restrict s) {
X  glm_decompose(m.raw, t->raw, r->raw, s->raw);
X}
X
X#endif /* cglms_affines_h */
e94591641a92571ad5097633a68da5b0
echo x - cglm/struct/io.h
sed 's/^X//' >cglm/struct/io.h << 'c6b60cc3ed20b299e298c2daf5984caa'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_mat4_print(mat4 matrix, FILE *ostream);
X   CGLM_INLINE void glm_mat3_print(mat3 matrix, FILE *ostream);
X   CGLM_INLINE void glm_vec4_print(vec4 vec, FILE *ostream);
X   CGLM_INLINE void glm_vec3_print(vec3 vec, FILE *ostream);
X   CGLM_INLINE void glm_ivec3_print(ivec3 vec, FILE *ostream);
X   CGLM_INLINE void glm_versor_print(versor vec, FILE *ostream);
X */
X
X#ifndef cglms_ios_h
X#define cglms_ios_h
X
X#include "../common.h"
X#include "../io.h"
X#include "mat4.h"
X
X#include <stdio.h>
X#include <stdlib.h>
X
XCGLM_INLINE
Xvoid
Xglms_mat4_print(mat4s             matrix,
X                FILE * __restrict ostream) {
X
X  glm_mat4_print(matrix.raw, ostream);
X}
X
XCGLM_INLINE
Xvoid
Xglms_mat3_print(mat3s             matrix,
X                FILE * __restrict ostream) {
X  glm_mat3_print(matrix.raw, ostream);
X}
X
XCGLM_INLINE
Xvoid
Xglms_vec4_print(vec4s             vec,
X                FILE * __restrict ostream) {
X  glm_vec4_print(vec.raw, ostream);
X}
X
XCGLM_INLINE
Xvoid
Xglms_vec3_print(vec3s             vec,
X                FILE * __restrict ostream) {
X  glm_vec3_print(vec.raw, ostream);
X}
X
XCGLM_INLINE
Xvoid
Xglms_ivec3_print(ivec3s            vec,
X                 FILE * __restrict ostream) {
X  glm_ivec3_print(vec.raw, ostream);
X}
X
XCGLM_INLINE
Xvoid
Xglms_versor_print(versors           vec,
X                  FILE * __restrict ostream) {
X  glm_versor_print(vec.raw, ostream);
X}
X
XCGLM_INLINE
Xvoid
Xglms_aabb_print(vec3s                   bbox[2],
X                const char * __restrict tag,
X                FILE       * __restrict ostream) {
X  vec3 rawBbox[2];
X
X  glms_vec3_unpack(rawBbox, bbox, 2);
X  glm_aabb_print(rawBbox, tag, ostream);
X}
X
X#endif /* cglms_ios_h */
c6b60cc3ed20b299e298c2daf5984caa
echo x - cglm/struct/cam.h
sed 's/^X//' >cglm/struct/cam.h << 'd0f41fdfdb1ad1c3e0a84bdeb0e7bd0c'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_frustum(float left,    float right,
X                                  float bottom,  float top,
X                                  float nearVal, float farVal)
X   CGLM_INLINE mat4s glms_ortho(float left,    float right,
X                                float bottom,  float top,
X                                float nearVal, float farVal)
X   CGLM_INLINE mat4s glms_ortho_aabb(vec3s box[2]);
X   CGLM_INLINE mat4s glms_ortho_aabb_p(vec3s box[2],  float padding);
X   CGLM_INLINE mat4s glms_ortho_aabb_pz(vec3s box[2], float padding);
X   CGLM_INLINE mat4s glms_ortho_default(float aspect)
X   CGLM_INLINE mat4s glms_ortho_default_s(float aspect, float size)
X   CGLM_INLINE mat4s glms_perspective(float fovy,
X                                      float aspect,
X                                      float nearVal,
X                                      float farVal)
X   CGLM_INLINE void  glms_persp_move_far(mat4s proj, float deltaFar)
X   CGLM_INLINE mat4s glms_perspective_default(float aspect)
X   CGLM_INLINE void  glms_perspective_resize(mat4s proj, float aspect)
X   CGLM_INLINE mat4s glms_lookat(vec3s eye, vec3s center, vec3s up)
X   CGLM_INLINE mat4s glms_look(vec3s eye, vec3s dir, vec3s up)
X   CGLM_INLINE mat4s glms_look_anyup(vec3s eye, vec3s dir)
X   CGLM_INLINE void  glms_persp_decomp(mat4s  proj,
X                                       float *nearv, float *farv,
X                                       float *top,   float *bottom,
X                                       float *left,  float *right)
X   CGLM_INLINE void  glms_persp_decompv(mat4s proj, float dest[6])
X   CGLM_INLINE void  glms_persp_decomp_x(mat4s proj, float *left, float *right)
X   CGLM_INLINE void  glms_persp_decomp_y(mat4s proj, float *top, float *bottom)
X   CGLM_INLINE void  glms_persp_decomp_z(mat4s proj, float *nearv, float *farv)
X   CGLM_INLINE void  glms_persp_decomp_far(mat4s proj, float *farVal)
X   CGLM_INLINE void  glms_persp_decomp_near(mat4s proj, float *nearVal)
X   CGLM_INLINE float glms_persp_fovy(mat4s proj)
X   CGLM_INLINE float glms_persp_aspect(mat4s proj)
X   CGLM_INLINE vec4s glms_persp_sizes(mat4s proj, float fovy)
X */
X
X#ifndef cglms_cam_h
X#define cglms_cam_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../plane.h"
X#include "../cam.h"
X
X/*!
X * @brief set up perspective peprojection matrix
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearVal near clipping plane
X * @param[in]  farVal  far clipping plane
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_frustum(float left,    float right,
X             float bottom,  float top,
X             float nearVal, float farVal) {
X  mat4s dest;
X  glm_frustum(left, right, bottom, top, nearVal, farVal, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearVal near clipping plane
X * @param[in]  farVal  far clipping plane
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho(float left,    float right,
X           float bottom,  float top,
X           float nearVal, float farVal) {
X  mat4s dest;
X  glm_ortho(left, right, bottom, top, nearVal, farVal, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box   AABB
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb(vec3s box[2]) {
X  mat4s dest;
X  vec3  rawBox[2];
X
X  glms_vec3_unpack(rawBox, box, 2);
X  glm_ortho_aabb(rawBox, dest.raw);
X
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb_p(vec3s box[2], float padding) {
X  mat4s dest;
X  vec3  rawBox[2];
X
X  glms_vec3_unpack(rawBox, box, 2);
X  glm_ortho_aabb_p(rawBox, padding, dest.raw);
X
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding for near and far
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb_pz(vec3s box[2], float padding) {
X  mat4s dest;
X  vec3  rawBox[2];
X
X  glms_vec3_unpack(rawBox, box, 2);
X  glm_ortho_aabb_pz(rawBox, padding, dest.raw);
X
X  return dest;
X}
X
X/*!
X * @brief set up unit orthographic projection matrix
X *
X * @param[in]  aspect aspect ration ( width / height )
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_default(float aspect) {
X  mat4s dest;
X  glm_ortho_default(aspect, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix with given CUBE size
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[in]  size   cube size
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_default_s(float aspect, float size) {
X  mat4s dest;
X  glm_ortho_default_s(aspect, size, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up perspective projection matrix
X *
X * @param[in]  fovy    field of view angle
X * @param[in]  aspect  aspect ratio ( width / height )
X * @param[in]  nearVal near clipping plane
X * @param[in]  farVal  far clipping planes
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective(float fovy, float aspect, float nearVal, float farVal) {
X  mat4s dest;
X  glm_perspective(fovy, aspect, nearVal, farVal, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief extend perspective projection matrix's far distance
X *
X * this function does not guarantee far >= near, be aware of that!
X *
X * @param[in, out] proj      projection matrix to extend
X * @param[in]      deltaFar  distance from existing far (negative to shink)
X */
XCGLM_INLINE
Xvoid
Xglms_persp_move_far(mat4s proj, float deltaFar) {
X  glm_persp_move_far(proj.raw, deltaFar);
X}
X
X/*!
X * @brief set up perspective projection matrix with default near/far
X *        and angle values
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective_default(float aspect) {
X  mat4s dest;
X  glm_perspective_default(aspect, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief resize perspective matrix by aspect ratio ( width / height )
X *        this makes very easy to resize proj matrix when window /viewport
X *        reized
X *
X * @param[in, out] proj   perspective projection matrix
X * @param[in]      aspect aspect ratio ( width / height )
X */
XCGLM_INLINE
Xvoid
Xglms_perspective_resize(mat4s proj, float aspect) {
X  glm_perspective_resize(aspect, proj.raw);
X}
X
X/*!
X * @brief set up view matrix
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  center center vector
X * @param[in]  up     up vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_lookat(vec3s eye, vec3s center, vec3s up) {
X  mat4s dest;
X  glm_lookat(eye.raw, center.raw, up.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up view matrix
X *
X * convenient wrapper for lookat: if you only have direction not target self
X * then this might be useful. Because you need to get target from direction.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[in]  up     up vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_look(vec3s eye, vec3s dir, vec3s up) {
X  mat4s dest;
X  glm_look(eye.raw, dir.raw, up.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up view matrix
X *
X * convenient wrapper for look: if you only have direction and if you don't
X * care what UP vector is then this might be useful to create view matrix
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_look_anyup(vec3s eye, vec3s dir) {
X  mat4s dest;
X  glm_look_anyup(eye.raw, dir.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection.
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearVal near
X * @param[out] farVal  far
X * @param[out] top     top
X * @param[out] bottom  bottom
X * @param[out] left    left
X * @param[out] right   right
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp(mat4s proj,
X                  float * __restrict nearVal, float * __restrict farVal,
X                  float * __restrict top,     float * __restrict bottom,
X                  float * __restrict left,    float * __restrict right) {
X  glm_persp_decomp(proj.raw, nearVal, farVal, top, bottom, left, right);
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection.
X *        this makes easy to get all values at once
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] dest   array
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decompv(mat4s proj, float dest[6]) {
X  glm_persp_decompv(proj.raw, dest);
X}
X
X/*!
X * @brief decomposes left and right values of perspective projection.
X *        x stands for x axis (left / right axis)
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] left  left
X * @param[out] right right
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_x(mat4s proj,
X                    float * __restrict left,
X                    float * __restrict right) {
X  glm_persp_decomp_x(proj.raw, left, right);
X}
X
X/*!
X * @brief decomposes top and bottom values of perspective projection.
X *        y stands for y axis (top / botom axis)
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] top    top
X * @param[out] bottom bottom
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_y(mat4s proj,
X                    float * __restrict top,
X                    float * __restrict bottom) {
X  glm_persp_decomp_y(proj.raw, top, bottom);
X}
X
X/*!
X * @brief decomposes near and far values of perspective projection.
X *        z stands for z axis (near / far axis)
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearVal near
X * @param[out] farVal  far
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_z(mat4s proj,
X                    float * __restrict nearVal,
X                    float * __restrict farVal) {
X  glm_persp_decomp_z(proj.raw, nearVal, farVal);
X}
X
X/*!
X * @brief decomposes far value of perspective projection.
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] farVal far
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_far(mat4s proj, float * __restrict farVal) {
X  glm_persp_decomp_far(proj.raw, farVal);
X}
X
X/*!
X * @brief decomposes near value of perspective projection.
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearVal near
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_near(mat4s proj, float * __restrict nearVal) {
X  glm_persp_decomp_near(proj.raw, nearVal);
X}
X
X/*!
X * @brief returns field of view angle along the Y-axis (in radians)
X *
X * if you need to degrees, use glm_deg to convert it or use this:
X * fovy_deg = glm_deg(glm_persp_fovy(projMatrix))
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglms_persp_fovy(mat4s proj) {
X  return glm_persp_fovy(proj.raw);
X}
X
X/*!
X * @brief returns aspect ratio of perspective projection
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglms_persp_aspect(mat4s proj) {
X  return glm_persp_aspect(proj.raw);
X}
X
X/*!
X * @brief returns sizes of near and far planes of perspective projection
X *
X * @param[in]  proj perspective projection matrix
X * @param[in]  fovy fovy (see brief)
X * @returns    sizes as vector, sizes order: [Wnear, Hnear, Wfar, Hfar]
X */
XCGLM_INLINE
Xvec4s
Xglms_persp_sizes(mat4s proj, float fovy) {
X  vec4s dest;
X  glm_persp_sizes(proj.raw, fovy, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_cam_h */
d0f41fdfdb1ad1c3e0a84bdeb0e7bd0c
echo x - cglm/struct/quat.h
sed 's/^X//' >cglm/struct/quat.h << '6c776d451d54f4a3135cff51d9eaf38c'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLMS_QUAT_IDENTITY_INIT
X   GLMS_QUAT_IDENTITY
X
X Functions:
X   CGLM_INLINE versors glms_quat_identity(void)
X   CGLM_INLINE void    glms_quat_identity_array(versor *q, size_t count)
X   CGLM_INLINE versors glms_quat_init(float x, float y, float z, float w)
X   CGLM_INLINE versors glms_quatv(float angle, vec3s axis)
X   CGLM_INLINE versors glms_quat(float angle, float x, float y, float z)
X   CGLM_INLINE float   glms_quat_norm(versors q)
X   CGLM_INLINE versors glms_quat_normalize(versors q)
X   CGLM_INLINE float   glms_quat_dot(versors p, versors q)
X   CGLM_INLINE versors glms_quat_conjugate(versors q)
X   CGLM_INLINE versors glms_quat_inv(versors q)
X   CGLM_INLINE versors glms_quat_add(versors p, versors q)
X   CGLM_INLINE versors glms_quat_sub(versors p, versors q)
X   CGLM_INLINE vec3s   glms_quat_imagn(versors q)
X   CGLM_INLINE float   glms_quat_imaglen(versors q)
X   CGLM_INLINE float   glms_quat_angle(versors q)
X   CGLM_INLINE vec3s   glms_quat_axis(versors q)
X   CGLM_INLINE versors glms_quat_mul(versors p, versors q)
X   CGLM_INLINE mat4s   glms_quat_mat4(versors q)
X   CGLM_INLINE mat4s   glms_quat_mat4t(versors q)
X   CGLM_INLINE mat3s   glms_quat_mat3(versors q)
X   CGLM_INLINE mat3s   glms_quat_mat3t(versors q)
X   CGLM_INLINE versors glms_quat_lerp(versors from, versors to, float t)
X   CGLM_INLINE versors glms_quat_lerpc(versors from, versors to, float t)
X   CGLM_INLINE versors glms_quat_slerp(versors from, versors to, float t)
X   CGLM_INLINE mat4s.  glms_quat_look(vec3s eye, versors ori)
X   CGLM_INLINE versors glms_quat_for(vec3s dir, vec3s fwd, vec3s up)
X   CGLM_INLINE versors glms_quat_forp(vec3s from, vec3s to, vec3s fwd, vec3s up)
X   CGLM_INLINE vec3s   glms_quat_rotatev(versors q, vec3s v)
X   CGLM_INLINE mat4s   glms_quat_rotate(mat4s m, versors q)
X   CGLM_INLINE mat4s   glms_quat_rotate_at(mat4s m, versors q, vec3s pivot)
X   CGLM_INLINE mat4s   glms_quat_rotate_atm(versors q, vec3s pivot)
X */
X
X#ifndef cglms_quat_h
X#define cglms_quat_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../plane.h"
X#include "../quat.h"
X
X/*
X * IMPORTANT:
X * ----------------------------------------------------------------------------
X * cglm stores quat as [x, y, z, w] since v0.3.6
X *
X * it was [w, x, y, z] before v0.3.6 it has been changed to [x, y, z, w]
X * with v0.3.6 version.
X * ----------------------------------------------------------------------------
X */
X
X#define GLMS_QUAT_IDENTITY_INIT  {GLM_QUAT_IDENTITY_INIT}
X#define GLMS_QUAT_IDENTITY       ((versors)GLMS_QUAT_IDENTITY_INIT)
X
X/*!
X * @brief makes given quat to identity
X *
X * @returns identity quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_identity(void) {
X  versors dest;
X  glm_quat_identity(dest.raw);
X  return dest;
X}
X
X/*!
X * @brief make given quaternion array's each element identity quaternion
X *
X * @param[in, out]  q     quat array (must be aligned (16)
X *                        if alignment is not disabled)
X *
X * @param[in]       count count of quaternions
X */
XCGLM_INLINE
Xvoid
Xglms_quat_identity_array(versors * __restrict q, size_t count) {
X  CGLM_ALIGN(16) versor v = GLM_QUAT_IDENTITY_INIT;
X  size_t i;
X
X  for (i = 0; i < count; i++) {
X    glm_vec4_copy(v, q[i].raw);
X  }
X}
X
X/*!
X * @brief inits quaterion with raw values
X *
X * @param[in]   x     x
X * @param[in]   y     y
X * @param[in]   z     z
X * @param[in]   w     w (real part)
X * @returns quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_init(float x, float y, float z, float w) {
X  versors dest;
X  glm_quat_init(dest.raw, x, y, z, w);
X  return dest;
X}
X
X/*!
X * @brief creates NEW quaternion with axis vector
X *
X * @param[in]   angle angle (radians)
X * @param[in]   axis  axis
X * @returns quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quatv(float angle, vec3s axis) {
X  versors dest;
X  glm_quatv(dest.raw, angle, axis.raw);
X  return dest;
X}
X
X/*!
X * @brief creates NEW quaternion with individual axis components
X *
X * @param[in]   angle angle (radians)
X * @param[in]   x     axis.x
X * @param[in]   y     axis.y
X * @param[in]   z     axis.z
X * @returns quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat(float angle, float x, float y, float z) {
X  versors dest;
X  glm_quat(dest.raw, angle, x, y, z);
X  return dest;
X}
X
X/*!
X * @brief returns norm (magnitude) of quaternion
X *
X * @param[out]  q  quaternion
X */
XCGLM_INLINE
Xfloat
Xglms_quat_norm(versors q) {
X  return glm_quat_norm(q.raw);
X}
X
X/*!
X * @brief normalize quaternion
X *
X * @param[in]  q  quaternion
X * @returns    quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_normalize(versors q) {
X  versors dest;
X  glm_quat_normalize_to(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief dot product of two quaternion
X *
X * @param[in]  p  quaternion 1
X * @param[in]  q  quaternion 2
X * @returns    dot product
X */
XCGLM_INLINE
Xfloat
Xglms_quat_dot(versors p, versors q) {
X  return glm_quat_dot(p.raw, q.raw);
X}
X
X/*!
X * @brief conjugate of quaternion
X *
X * @param[in]   q     quaternion
X * @returns    conjugate
X */
XCGLM_INLINE
Xversors
Xglms_quat_conjugate(versors q) {
X  versors dest;
X  glm_quat_conjugate(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief inverse of non-zero quaternion
X *
X * @param[in]  q    quaternion
X * @returns    inverse quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_inv(versors q) {
X  versors dest;
X  glm_quat_inv(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief add (componentwise) two quaternions and store result in dest
X *
X * @param[in]   p    quaternion 1
X * @param[in]   q    quaternion 2
X * @returns result quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_add(versors p, versors q) {
X  versors dest;
X  glm_quat_add(p.raw, q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief subtract (componentwise) two quaternions and store result in dest
X *
X * @param[in]   p    quaternion 1
X * @param[in]   q    quaternion 2
X * @returns result quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_sub(versors p, versors q) {
X  versors dest;
X  glm_quat_sub(p.raw, q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief returns normalized imaginary part of quaternion
X *
X * @param[in]   q    quaternion
X */
XCGLM_INLINE
Xvec3s
Xglms_quat_imagn(versors q) {
X  vec3s dest;
X  glm_normalize_to(q.imag.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief returns length of imaginary part of quaternion
X *
X * @param[in]   q    quaternion
X */
XCGLM_INLINE
Xfloat
Xglms_quat_imaglen(versors q) {
X  return glm_quat_imaglen(q.raw);
X}
X
X/*!
X * @brief returns angle of quaternion
X *
X * @param[in]   q    quaternion
X */
XCGLM_INLINE
Xfloat
Xglms_quat_angle(versors q) {
X  return glm_quat_angle(q.raw);
X}
X
X/*!
X * @brief axis of quaternion
X *
X * @param[in]   q    quaternion
X * @returns axis of quaternion
X */
XCGLM_INLINE
Xvec3s
Xglms_quat_axis(versors q) {
X  vec3s dest;
X  glm_quat_axis(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief multiplies two quaternion and stores result in dest
X *        this is also called Hamilton Product
X *
X * According to WikiPedia:
X * The product of two rotation quaternions [clarification needed] will be
X * equivalent to the rotation q followed by the rotation p
X *
X * @param[in]   p     quaternion 1
X * @param[in]   q     quaternion 2
X * @returns  result quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_mul(versors p, versors q) {
X  versors dest;
X  glm_quat_mul(p.raw, q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief convert quaternion to mat4
X *
X * @param[in]   q     quaternion
X * @returns  result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_quat_mat4(versors q) {
X  mat4s dest;
X  glm_quat_mat4(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief convert quaternion to mat4 (transposed)
X *
X * @param[in]   q     quaternion
X * @returns  result matrix as transposed
X */
XCGLM_INLINE
Xmat4s
Xglms_quat_mat4t(versors q) {
X  mat4s dest;
X  glm_quat_mat4t(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief convert quaternion to mat3
X *
X * @param[in]   q     quaternion
X * @returns  result matrix
X */
XCGLM_INLINE
Xmat3s
Xglms_quat_mat3(versors q) {
X  mat3s dest;
X  glm_quat_mat3(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief convert quaternion to mat3 (transposed)
X *
X * @param[in]   q     quaternion
X * @returns  result matrix
X */
XCGLM_INLINE
Xmat3s
Xglms_quat_mat3t(versors q) {
X  mat3s dest;
X  glm_quat_mat3t(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief interpolates between two quaternions
X *        using linear interpolation (LERP)
X *
X * @param[in]   from  from
X * @param[in]   to    to
X * @param[in]   t     interpolant (amount)
X * @returns  result quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_lerp(versors from, versors to, float t) {
X  versors dest;
X  glm_quat_lerp(from.raw, to.raw, t, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief interpolates between two quaternions
X *        using linear interpolation (LERP)
X *
X * @param[in]   from  from
X * @param[in]   to    to
X * @param[in]   t     interpolant (amount) clamped between 0 and 1
X * @returns  result quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_lerpc(versors from, versors to, float t) {
X  versors dest;
X  glm_quat_lerpc(from.raw, to.raw, t, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief interpolates between two quaternions
X *        using spherical linear interpolation (SLERP)
X *
X * @param[in]   from  from
X * @param[in]   to    to
X * @param[in]   t     amout
X * @returns result quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_slerp(versors from, versors to, float t) {
X  versors dest;
X  glm_quat_slerp(from.raw, to.raw, t, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief creates view matrix using quaternion as camera orientation
X *
X * @param[in]   eye   eye
X * @param[in]   ori   orientation in world space as quaternion
X * @returns  view matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_quat_look(vec3s eye, versors ori) {
X  mat4s dest;
X  glm_quat_look(eye.raw, ori.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief creates look rotation quaternion
X *
X * @param[in]   dir   direction to look
X * @param[in]   fwd   forward vector
X * @param[in]   up    up vector
X * @returns  destination quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_for(vec3s dir, vec3s fwd, vec3s up) {
X  versors dest;
X  glm_quat_for(dir.raw, fwd.raw, up.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief creates look rotation quaternion using source and
X *        destination positions p suffix stands for position
X *
X * @param[in]   from  source point
X * @param[in]   to    destination point
X * @param[in]   fwd   forward vector
X * @param[in]   up    up vector
X * @returns  destination quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_forp(vec3s from, vec3s to, vec3s fwd, vec3s up) {
X  versors dest;
X  glm_quat_forp(from.raw, to.raw, fwd.raw, up.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief rotate vector using using quaternion
X *
X * @param[in]   q     quaternion
X * @param[in]   v     vector to rotate
X * @returns  rotated vector
X */
XCGLM_INLINE
Xvec3s
Xglms_quat_rotatev(versors q, vec3s v) {
X  vec3s dest;
X  glm_quat_rotatev(q.raw, v.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief rotate existing transform matrix using quaternion
X *
X * @param[in]   m     existing transform matrix
X * @param[in]   q     quaternion
X * @returns  rotated matrix/transform
X */
XCGLM_INLINE
Xmat4s
Xglms_quat_rotate(mat4s m, versors q) {
X  glm_quat_rotate(m.raw, q.raw, m.raw);
X  return m;
X}
X
X/*!
X * @brief rotate existing transform matrix using quaternion at pivot point
X *
X * @param[in, out]   m     existing transform matrix
X * @param[in]        q     quaternion
X * @returns pivot
X */
XCGLM_INLINE
Xmat4s
Xglms_quat_rotate_at(mat4s m, versors q, vec3s pivot) {
X  glm_quat_rotate_at(m.raw, q.raw, pivot.raw);
X  return m;
X}
X
X/*!
X * @brief rotate NEW transform matrix using quaternion at pivot point
X *
X * this creates rotation matrix, it assumes you don't have a matrix
X *
X * this should work faster than glm_quat_rotate_at because it reduces
X * one glm_translate.
X *
X * @param[in]   q     quaternion
X * @returns pivot
X */
XCGLM_INLINE
Xmat4s
Xglms_quat_rotate_atm(versors q, vec3s pivot) {
X  mat4s dest;
X  glm_quat_rotate_atm(dest.raw, q.raw, pivot.raw);
X  return dest;
X}
X
X#endif /* cglms_quat_h */
6c776d451d54f4a3135cff51d9eaf38c
echo x - cglm/struct/euler.h
sed 's/^X//' >cglm/struct/euler.h << '9644eddca827cfe9ccfca6fd5d309863'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X NOTE:
X  angles must be passed as [X-Angle, Y-Angle, Z-angle] order
X  For instance you don't pass angles as [Z-Angle, X-Angle, Y-angle] to
X  glm_euler_zxy funciton, All RELATED functions accept angles same order
X  which is [X, Y, Z].
X */
X
X/*
X Types:
X   enum glm_euler_seq
X
X Functions:
X   CGLM_INLINE vec3s glms_euler_angles(mat4s m)
X   CGLM_INLINE mat4s glms_euler_xyz(vec3s angles)
X   CGLM_INLINE mat4s glms_euler_xzy(vec3s angles)
X   CGLM_INLINE mat4s glms_euler_yxz(vec3s angles)
X   CGLM_INLINE mat4s glms_euler_yzx(vec3s angles)
X   CGLM_INLINE mat4s glms_euler_zxy(vec3s angles)
X   CGLM_INLINE mat4s glms_euler_zyx(vec3s angles)
X   CGLM_INLINE mat4s glms_euler_by_order(vec3s angles, glm_euler_seq ord)
X */
X
X#ifndef cglms_euler_h
X#define cglms_euler_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../euler.h"
X
X/*!
X * @brief extract euler angles (in radians) using xyz order
X *
X * @param[in]  m    affine transform
X * @returns angles vector [x, y, z]
X */
XCGLM_INLINE
Xvec3s
Xglms_euler_angles(mat4s m) {
X  vec3s dest;
X  glm_euler_angles(m.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @returns rotation matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_euler_xyz(vec3s angles) {
X  mat4s dest;
X  glm_euler_xyz(angles.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @returns rotation matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_euler_xzy(vec3s angles) {
X  mat4s dest;
X  glm_euler_xzy(angles.raw, dest.raw);
X  return dest;
X}
X
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @returns rotation matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_euler_yxz(vec3s angles) {
X  mat4s dest;
X  glm_euler_yxz(angles.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @returns rotation matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_euler_yzx(vec3s angles) {
X  mat4s dest;
X  glm_euler_yzx(angles.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @returns rotation matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_euler_zxy(vec3s angles) {
X  mat4s dest;
X  glm_euler_zxy(angles.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @returns rotation matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_euler_zyx(vec3s angles) {
X  mat4s dest;
X  glm_euler_zyx(angles.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[in]  ord    euler order
X * @returns rotation matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_euler_by_order(vec3s angles, glm_euler_seq ord) {
X  mat4s dest;
X  glm_euler_by_order(angles.raw, ord, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_euler_h */
9644eddca827cfe9ccfca6fd5d309863
echo x - cglm/struct/plane.h
sed 's/^X//' >cglm/struct/plane.h << 'f6526be472b034521a7b938e014ea3f8'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglms_planes_h
X#define cglms_planes_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../plane.h"
X#include "vec4.h"
X
X/*
X Plane equation:  Ax + By + Cz + D = 0;
X
X It stored in vec4 as [A, B, C, D]. (A, B, C) is normal and D is distance
X*/
X
X/*
X Functions:
X   CGLM_INLINE vec4s glms_plane_normalize(vec4s plane);
X */
X
X/*!
X * @brief normalizes a plane
X *
X * @param[in] plane plane to normalize
X * @returns         normalized plane
X */
XCGLM_INLINE
Xvec4s
Xglms_plane_normalize(vec4s plane) {
X  glm_plane_normalize(plane.raw);
X  return plane;
X}
X
X#endif /* cglms_planes_h */
f6526be472b034521a7b938e014ea3f8
echo x - cglm/struct/frustum.h
sed 's/^X//' >cglm/struct/frustum.h << '94ee749c1e6996dcd214cbab40eadf04'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglms_frustums_h
X#define cglms_frustums_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../frustum.h"
X#include "plane.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X
X/* you can override clip space coords
X   but you have to provide all with same name
X   e.g.: define GLM_CSCOORD_LBN {0.0f, 0.0f, 1.0f, 1.0f} */
X#ifndef GLM_CUSTOM_CLIPSPACE
X
X/* near */
X#define GLMS_CSCOORD_LBN {-1.0f, -1.0f, -1.0f, 1.0f}
X#define GLMS_CSCOORD_LTN {-1.0f,  1.0f, -1.0f, 1.0f}
X#define GLMS_CSCOORD_RTN { 1.0f,  1.0f, -1.0f, 1.0f}
X#define GLMS_CSCOORD_RBN { 1.0f, -1.0f, -1.0f, 1.0f}
X
X/* far */
X#define GLMS_CSCOORD_LBF {-1.0f, -1.0f,  1.0f, 1.0f}
X#define GLMS_CSCOORD_LTF {-1.0f,  1.0f,  1.0f, 1.0f}
X#define GLMS_CSCOORD_RTF { 1.0f,  1.0f,  1.0f, 1.0f}
X#define GLMS_CSCOORD_RBF { 1.0f, -1.0f,  1.0f, 1.0f}
X
X#endif
X
X/*!
X * @brief extracts view frustum planes
X *
X * planes' space:
X *  1- if m = proj:     View Space
X *  2- if m = viewProj: World Space
X *  3- if m = MVP:      Object Space
X *
X * You probably want to extract planes in world space so use viewProj as m
X * Computing viewProj:
X *   glm_mat4_mul(proj, view, viewProj);
X *
X * Exracted planes order: [left, right, bottom, top, near, far]
X *
X * @param[in]  m    matrix (see brief)
X * @param[out] dest extracted view frustum planes (see brief)
X */
XCGLM_INLINE
Xvoid
Xglms_frustum_planes(mat4s m, vec4s dest[6]) {
X  vec4 rawDest[6];
X  glm_frustum_planes(m.raw, rawDest);
X  glms_vec4_pack(dest, rawDest, 6);
X}
X
X/*!
X * @brief extracts view frustum corners using clip-space coordinates
X *
X * corners' space:
X *  1- if m = invViewProj: World Space
X *  2- if m = invMVP:      Object Space
X *
X * You probably want to extract corners in world space so use invViewProj
X * Computing invViewProj:
X *   glm_mat4_mul(proj, view, viewProj);
X *   ...
X *   glm_mat4_inv(viewProj, invViewProj);
X *
X * if you have a near coord at i index, you can get it's far coord by i + 4
X *
X * Find center coordinates:
X *   for (j = 0; j < 4; j++) {
X *     glm_vec3_center(corners[i], corners[i + 4], centerCorners[i]);
X *   }
X *
X * @param[in]  invMat matrix (see brief)
X * @param[out] dest   exracted view frustum corners (see brief)
X */
XCGLM_INLINE
Xvoid
Xglms_frustum_corners(mat4s invMat, vec4s dest[8]) {
X  vec4 rawDest[8];
X  glm_frustum_corners(invMat.raw, rawDest);
X  glms_vec4_pack(dest, rawDest, 8);
X}
X
X/*!
X * @brief finds center of view frustum
X *
X * @param[in]  corners view frustum corners
X * @returns            view frustum center
X */
XCGLM_INLINE
Xvec4s
Xglms_frustum_center(vec4s corners[8]) {
X  vec4 rawCorners[8];
X  vec4s r;
X
X  glms_vec4_unpack(rawCorners, corners, 8);
X  glm_frustum_center(rawCorners, r.raw);
X  return r;
X}
X
X/*!
X * @brief finds bounding box of frustum relative to given matrix e.g. view mat
X *
X * @param[in]  corners view frustum corners
X * @param[in]  m       matrix to convert existing conners
X * @param[out] box     bounding box as array [min, max]
X */
XCGLM_INLINE
Xvoid
Xglms_frustum_box(vec4s corners[8], mat4s m, vec3s box[2]) {
X  vec4 rawCorners[8];
X  vec3 rawBox[2];
X
X  glms_vec4_unpack(rawCorners, corners, 8);
X  glm_frustum_box(rawCorners, m.raw, rawBox);
X  glms_vec3_pack(box, rawBox, 2);
X}
X
X/*!
X * @brief finds planes corners which is between near and far planes (parallel)
X *
X * this will be helpful if you want to split a frustum e.g. CSM/PSSM. This will
X * find planes' corners but you will need to one more plane.
X * Actually you have it, it is near, far or created previously with this func ;)
X *
X * @param[in]  corners view  frustum corners
X * @param[in]  splitDist     split distance
X * @param[in]  farDist       far distance (zFar)
X * @param[out] planeCorners  plane corners [LB, LT, RT, RB]
X */
XCGLM_INLINE
Xvoid
Xglms_frustum_corners_at(vec4s corners[8],
X                        float splitDist,
X                        float farDist,
X                        vec4s planeCorners[4]) {
X  vec4 rawCorners[8];
X  vec4 rawPlaneCorners[4];
X
X  glms_vec4_unpack(rawCorners, corners, 8);
X  glm_frustum_corners_at(rawCorners, splitDist, farDist, rawPlaneCorners);
X  glms_vec4_pack(planeCorners, rawPlaneCorners, 8);
X}
X
X#endif /* cglms_frustums_h */
94ee749c1e6996dcd214cbab40eadf04
echo x - cglm/struct/box.h
sed 's/^X//' >cglm/struct/box.h << '4df42ab649e608dadfbb255c8264d409'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglms_boxs_h
X#define cglms_boxs_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../box.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X
X/*!
X * @brief apply transform to Axis-Aligned Bounding Box
X *
X * @param[in]  box  bounding box
X * @param[in]  m    transform matrix
X * @param[out] dest transformed bounding box
X */
XCGLM_INLINE
Xvoid
Xglms_aabb_transform(vec3s box[2], mat4s m, vec3s dest[2]) {
X  vec3 rawBox[2];
X  vec3 rawDest[2];
X
X  glms_vec3_unpack(rawBox, box, 2);
X  glm_aabb_transform(rawBox, m.raw, rawDest);
X  glms_vec3_pack(dest, rawDest, 2);
X}
X
X/*!
X * @brief merges two AABB bounding box and creates new one
X *
X * two box must be in same space, if one of box is in different space then
X * you should consider to convert it's space by glm_box_space
X *
X * @param[in]  box1 bounding box 1
X * @param[in]  box2 bounding box 2
X * @param[out] dest merged bounding box
X */
XCGLM_INLINE
Xvoid
Xglms_aabb_merge(vec3s box1[2], vec3s box2[2], vec3s dest[2]) {
X  vec3 rawBox1[2];
X  vec3 rawBox2[2];
X  vec3 rawDest[2];
X
X  glms_vec3_unpack(rawBox1, box1, 2);
X  glms_vec3_unpack(rawBox2, box2, 2);
X  glm_aabb_merge(rawBox1, rawBox2, rawDest);
X  glms_vec3_pack(dest, rawDest, 2);
X}
X
X/*!
X * @brief crops a bounding box with another one.
X *
X * this could be useful for gettng a bbox which fits with view frustum and
X * object bounding boxes. In this case you crop view frustum box with objects
X * box
X *
X * @param[in]  box     bounding box 1
X * @param[in]  cropBox crop box
X * @param[out] dest    cropped bounding box
X */
XCGLM_INLINE
Xvoid
Xglms_aabb_crop(vec3s box[2], vec3s cropBox[2], vec3s dest[2]) {
X  vec3 rawBox[2];
X  vec3 rawCropBox[2];
X  vec3 rawDest[2];
X
X  glms_vec3_unpack(rawBox, box, 2);
X  glms_vec3_unpack(rawCropBox, cropBox, 2);
X  glm_aabb_crop(rawBox, rawCropBox, rawDest);
X  glms_vec3_pack(dest, rawDest, 2);
X}
X
X/*!
X * @brief crops a bounding box with another one.
X *
X * this could be useful for gettng a bbox which fits with view frustum and
X * object bounding boxes. In this case you crop view frustum box with objects
X * box
X *
X * @param[in]  box      bounding box
X * @param[in]  cropBox  crop box
X * @param[in]  clampBox miniumum box
X * @param[out] dest     cropped bounding box
X */
XCGLM_INLINE
Xvoid
Xglms_aabb_crop_until(vec3s box[2],
X                     vec3s cropBox[2],
X                     vec3s clampBox[2],
X                     vec3s dest[2]) {
X  glms_aabb_crop(box, cropBox, dest);
X  glms_aabb_merge(clampBox, dest, dest);
X}
X
X/*!
X * @brief check if AABB intersects with frustum planes
X *
X * this could be useful for frustum culling using AABB.
X *
X * OPTIMIZATION HINT:
X *  if planes order is similar to LEFT, RIGHT, BOTTOM, TOP, NEAR, FAR
X *  then this method should run even faster because it would only use two
X *  planes if object is not inside the two planes
X *  fortunately cglm extracts planes as this order! just pass what you got!
X *
X * @param[in]  box     bounding box
X * @param[in]  planes  frustum planes
X */
XCGLM_INLINE
Xbool
Xglms_aabb_frustum(vec3s box[2], vec4s planes[6]) {
X  vec3 rawBox[2];
X  vec4 rawPlanes[6];
X
X  glms_vec3_unpack(rawBox, box, 2);
X  glms_vec4_unpack(rawPlanes, planes, 6);
X  return glm_aabb_frustum(rawBox, rawPlanes);
X}
X
X/*!
X * @brief invalidate AABB min and max values
X *
X * @param[in, out]  box bounding box
X */
XCGLM_INLINE
Xvoid
Xglms_aabb_invalidate(vec3s box[2]) {
X  box[0] = glms_vec3_broadcast(FLT_MAX);
X  box[1] = glms_vec3_broadcast(-FLT_MAX);
X}
X
X/*!
X * @brief check if AABB is valid or not
X *
X * @param[in]  box bounding box
X */
XCGLM_INLINE
Xbool
Xglms_aabb_isvalid(vec3s box[2]) {
X  vec3 rawBox[2];
X  glms_vec3_unpack(rawBox, box, 2);
X  return glm_aabb_isvalid(rawBox);
X}
X
X/*!
X * @brief distance between of min and max
X *
X * @param[in]  box bounding box
X */
XCGLM_INLINE
Xfloat
Xglms_aabb_size(vec3s box[2]) {
X  return glm_vec3_distance(box[0].raw, box[1].raw);
X}
X
X/*!
X * @brief radius of sphere which surrounds AABB
X *
X * @param[in]  box bounding box
X */
XCGLM_INLINE
Xfloat
Xglms_aabb_radius(vec3s box[2]) {
X  return glms_aabb_size(box) * 0.5f;
X}
X
X/*!
X * @brief computes center point of AABB
X *
X * @param[in]   box  bounding box
X * @returns center of bounding box
X */
XCGLM_INLINE
Xvec3s
Xglms_aabb_center(vec3s box[2]) {
X  return glms_vec3_center(box[0], box[1]);
X}
X
X/*!
X * @brief check if two AABB intersects
X *
X * @param[in]   box    bounding box
X * @param[in]   other  other bounding box
X */
XCGLM_INLINE
Xbool
Xglms_aabb_aabb(vec3s box[2], vec3s other[2]) {
X  vec3 rawBox[2];
X  vec3 rawOther[2];
X
X  glms_vec3_unpack(rawBox, box, 2);
X  glms_vec3_unpack(rawOther, other, 2);
X  return glm_aabb_aabb(rawBox, rawOther);
X}
X
X/*!
X * @brief check if AABB intersects with sphere
X *
X * https://github.com/erich666/GraphicsGems/blob/master/gems/BoxSphere.c
X * Solid Box - Solid Sphere test.
X *
X * @param[in]   box    solid bounding box
X * @param[in]   s      solid sphere
X */
XCGLM_INLINE
Xbool
Xglms_aabb_sphere(vec3s box[2], vec4s s) {
X  vec3 rawBox[2];
X
X  glms_vec3_unpack(rawBox, box, 2);
X  return glm_aabb_sphere(rawBox, s.raw);
X}
X
X/*!
X * @brief check if point is inside of AABB
X *
X * @param[in]   box    bounding box
X * @param[in]   point  point
X */
XCGLM_INLINE
Xbool
Xglms_aabb_point(vec3s box[2], vec3s point) {
X  vec3 rawBox[2];
X
X  glms_vec3_unpack(rawBox, box, 2);
X  return glm_aabb_point(rawBox, point.raw);
X}
X
X/*!
X * @brief check if AABB contains other AABB
X *
X * @param[in]   box    bounding box
X * @param[in]   other  other bounding box
X */
XCGLM_INLINE
Xbool
Xglms_aabb_contains(vec3s box[2], vec3s other[2]) {
X  vec3 rawBox[2];
X  vec3 rawOther[2];
X
X  glms_vec3_unpack(rawBox, box, 2);
X  glms_vec3_unpack(rawOther, other, 2);
X  return glm_aabb_contains(rawBox, rawOther);
X}
X
X#endif /* cglms_boxs_h */
4df42ab649e608dadfbb255c8264d409
echo x - cglm/struct/project.h
sed 's/^X//' >cglm/struct/project.h << '14a0d20e87f21ff6658937b6f294d282'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglms_projects_h
X#define cglms_projects_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../project.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X
X/*!
X * @brief maps the specified viewport coordinates into specified space [1]
X *        the matrix should contain projection matrix.
X *
X * if you don't have ( and don't want to have ) an inverse matrix then use
X * glm_unproject version. You may use existing inverse of matrix in somewhere
X * else, this is why glm_unprojecti exists to save save inversion cost
X *
X * [1] space:
X *  1- if m = invProj:     View Space
X *  2- if m = invViewProj: World Space
X *  3- if m = invMVP:      Object Space
X *
X * You probably want to map the coordinates into object space
X * so use invMVP as m
X *
X * Computing viewProj:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *   glm_mat4_inv(viewProj, invMVP);
X *
X * @param[in]  pos      point/position in viewport coordinates
X * @param[in]  invMat   matrix (see brief)
X * @param[in]  vp       viewport as [x, y, width, height]
X * @returns             unprojected coordinates
X */
XCGLM_INLINE
Xvec3s
Xglms_unprojecti(vec3s pos, mat4s invMat, vec4s vp) {
X  vec3s r;
X  glm_unprojecti(pos.raw, invMat.raw, vp.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief maps the specified viewport coordinates into specified space [1]
X *        the matrix should contain projection matrix.
X *
X * this is same as glm_unprojecti except this function get inverse matrix for
X * you.
X *
X * [1] space:
X *  1- if m = proj:     View Space
X *  2- if m = viewProj: World Space
X *  3- if m = MVP:      Object Space
X *
X * You probably want to map the coordinates into object space
X * so use MVP as m
X *
X * Computing viewProj and MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  pos      point/position in viewport coordinates
X * @param[in]  m        matrix (see brief)
X * @param[in]  vp       viewport as [x, y, width, height]
X * @returns             unprojected coordinates
X */
XCGLM_INLINE
Xvec3s
Xglms_unproject(vec3s pos, mat4s m, vec4s vp) {
X  vec3s r;
X  glm_unproject(pos.raw, m.raw, vp.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief map object coordinates to window coordinates
X *
X * Computing MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  pos      object coordinates
X * @param[in]  m        MVP matrix
X * @param[in]  vp       viewport as [x, y, width, height]
X * @returns projected coordinates
X */
XCGLM_INLINE
Xvec3s
Xglms_project(vec3s pos, mat4s m, vec4s vp) {
X  vec3s r;
X  glm_project(pos.raw, m.raw, vp.raw, r.raw);
X  return r;
X}
X
X#endif /* cglms_projects_h */
14a0d20e87f21ff6658937b6f294d282
echo x - cglm/struct/sphere.h
sed 's/^X//' >cglm/struct/sphere.h << '2abf948c73f986f0a1aca8b9fa84a894'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglms_spheres_h
X#define cglms_spheres_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../sphere.h"
X#include "mat4.h"
X
X/*
X  Sphere Representation in cglm: [center.x, center.y, center.z, radii]
X
X  You could use this representation or you can convert it to vec4 before call
X  any function
X */
X
X/*!
X * @brief helper for getting sphere radius
X *
X * @param[in]   s  sphere
X *
X * @return returns radii
X */
XCGLM_INLINE
Xfloat
Xglms_sphere_radii(vec4s s) {
X  return glm_sphere_radii(s.raw);
X}
X
X/*!
X * @brief apply transform to sphere, it is just wrapper for glm_mat4_mulv3
X *
X * @param[in]  s    sphere
X * @param[in]  m    transform matrix
X * @returns         transformed sphere
X */
XCGLM_INLINE
Xvec4s
Xglms_sphere_transform(vec4s s, mat4 m) {
X  vec4s r;
X  glm_sphere_transform(s.raw, m, r.raw);
X  return r;
X}
X
X/*!
X * @brief merges two spheres and creates a new one
X *
X * two sphere must be in same space, for instance if one in world space then
X * the other must be in world space too, not in local space.
X *
X * @param[in]  s1   sphere 1
X * @param[in]  s2   sphere 2
X * returns          merged/extended sphere
X */
XCGLM_INLINE
Xvec4s
Xglms_sphere_merge(vec4s s1, vec4s s2) {
X  vec4s r;
X  glm_sphere_merge(s1.raw, s2.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief check if two sphere intersects
X *
X * @param[in]   s1  sphere
X * @param[in]   s2  other sphere
X */
XCGLM_INLINE
Xbool
Xglms_sphere_sphere(vec4s s1, vec4s s2) {
X  return glm_sphere_sphere(s1.raw, s2.raw);
X}
X
X/*!
X * @brief check if sphere intersects with point
X *
X * @param[in]   s      sphere
X * @param[in]   point  point
X */
XCGLM_INLINE
Xbool
Xglms_sphere_point(vec4s s, vec3s point) {
X  return glm_sphere_point(s.raw, point.raw);
X}
X
X#endif /* cglms_spheres_h */
2abf948c73f986f0a1aca8b9fa84a894
echo x - cglm/struct/color.h
sed 's/^X//' >cglm/struct/color.h << '1cf35cfa709adadd478fa03c8f6474c2'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglms_colors_h
X#define cglms_colors_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../color.h"
X#include "vec3.h"
X
X/*!
X * @brief averages the color channels into one value
X *
X * @param[in]  rgb RGB color
X */
XCGLM_INLINE
Xfloat
Xglms_luminance(vec3s rgb) {
X  return glm_luminance(rgb.raw);
X}
X
X#endif /* cglms_colors_h */
1cf35cfa709adadd478fa03c8f6474c2
echo x - cglm/struct/curve.h
sed 's/^X//' >cglm/struct/curve.h << '27a9d509513b731ffd521d5bd9d02566'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglms_curves_h
X#define cglms_curves_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../curve.h"
X#include "vec4.h"
X#include "mat4.h"
X
X/*!
X * @brief helper function to calculate S*M*C multiplication for curves
X *
X * This function does not encourage you to use SMC,
X * instead it is a helper if you use SMC.
X *
X * if you want to specify S as vector then use more generic glm_mat4_rmc() func.
X *
X * Example usage:
X *  B(s) = glm_smc(s, GLM_BEZIER_MAT, (vec4){p0, c0, c1, p1})
X *
X * @param[in]  s  parameter between 0 and 1 (this will be [s3, s2, s, 1])
X * @param[in]  m  basis matrix
X * @param[in]  c  position/control vector
X *
X * @return B(s)
X */
XCGLM_INLINE
Xfloat
Xglms_smc(float s, mat4s m, vec4s c) {
X  return glm_smc(s, m.raw, c.raw);
X}
X
X#endif /* cglms_curves_h */
27a9d509513b731ffd521d5bd9d02566
exit

